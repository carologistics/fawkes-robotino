;---------------------------------------------------------------------------
;  steps.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri Jan 27 11:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

;Once a Step-Something Op is invoked, The Step Goal (! (step ..)) that caused it to fire is always
;satisfied no matter if the step itself finished. To know if it succeeded you need to check the agent-state
;Or device a way to make sure to react on the step-failure. { like the OPRS's Active/Passive preserve
; (& (! (step do-something ..)) (% (predicate-to-preserve .. )) }
;If Step Goal fails it means there is no Ops with a :context that matches the WM it was 
;expected to be called in. And that you did something wrong assuming that :context.

(
	(defop step-drive-to
		:invocation( ! (step drive-to machine $mps-name side $side) )
		:context()  
		:body(
			(! (printf (Format "STEP: Drive-To .. machine %s is %s \n" $mps-name)))
			(=> (agent-state STEP-RUNNING))

			;Sides allowed
			(? (MEMQ $side (. "input" "output" .)))
			(if (? (= $side "input" ))
				(! (= $place (string-cat $mps-name "-I")))
				else 
				(! (= $place (string-cat $mps-name "-O"))))

			(if (! (execute (skill "drive_to" "place" $place) )) 
				(=> (agent-state STEP-FINISHD))
				else
				(=> (agent-state STEP-FAILD)) )
			)
		)

	(defop step-fetch-base-from-bs
		:invocation(! (step fetch-base-from-bs machine $mps-name side $side))
		:context ( 	(machine $mps-name "BS" $m-state $m-prepared $m-zone $m-pose $m-loaded-with)
				 	(MEMQ $m-state (. "PROCESSING" "READY-AT-OUTPUT" "DOWN" .)) ;The Mps Has to had been instructed or down
				 	(holding NONE))
		:body(
			(! (printf (Format "STEP: Fetch-From-Base .. machine %s is %s \n" $mps-name  $m-s)))
			;Todo: This could be replace by a unified checking mechanism 
			(if (? (= $m-state "DOWN") )
				(=> (agent-state STEP-PENDING))
				(^ (& (machine $mps-name "BS" @new-state @m-prepared @m-zone @m-pose @m-loaded-with)
					  (MEMQ (val @new-state) (. "PROCESSING" "READY-AT-OUTPUT" .))))) ;Wait for it to be UP.ToDo:WATCHDOG!
				

			(=> (agent-state STEP-RUNNING))
			(if (! (execute (skill "get_product_from" "place" $mps-name "side" $side)) ) 
				(=> (agent-state STEP-FINISHD))
				(=> (holding BASE))
				else
				(=> (agent-state STEP-FAILD)))
			)
		:documentation " Fetch the base from the base station. Here the robot assumed to be already at the BS and already 
						instructed it. If Machine is BROKEN when the step goal is posted. this will fails
						 TODO: handle what happens when BROKEN"

		;questions: is it better if i just passed the active side..
		;Why is it not both active at the same time...is that like a rule or something
		;am a little worried that i can lose the choice to 
		;optimize this side choice thing and leave it up to the robots somehow to go to whatever side

		;I can have a check for preconditions of each step and decide what to 
		;do from a separate op where steps are mapped to their Pre-conditions.  
		;Or just react to it from here
		)

		(defop step-get-cap-from-shelf
			:invocation( ! 	(step get-from-shelf machine $mps-name))
			:context ( 		(cap-station $mps $assigned-cap-color $cap-loaded-status $caps-on-shelf )
							(holding NONE))
			:body(
				(! (printf (Format "STEP: Get-From-Shelf \n")))
				(=> (agent-state STEP-RUNNING))
	
				;TODO: dynamically determine which position. 
			 	;Change the # on shelf even if the skill fails 
				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "RIGHT")) 	(! (= $new-caps-on-shelf  2))
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "MIDDLE")) 	(! (= $new-caps-on-shelf  1))
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "LEFT")) 	(! (= $new-caps-on-shelf  3)) ))) 
			
				(if (! (execute (skill "get_product_from" "place" $mps-name "shelf" $slot)))
					(=> (agent-state STEP-FINISHD))
					(=> (holding CAP))
				else
					(=> (agent-state STEP-FAILD)))
			
			)
		:effects ( (=> (cap-station $mps $assigned-cap-color $cap-loaded-status $new-caps-on-shelf)) )
		)

		(defop step-insert-product-into-mps
			:invocation ( ! (step insert machine $mps))
			:context 	(  	(~ (holding NONE)) ;that should be a work-peace
							(machine $mps $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
						 	(MEMQ $mps-state (. "PREPARED" .)))
							;Maybe check if side is empty OR handle it if not
							;Maybe check if the holding peace is a base or product work-peace
							;Mps has to be instructed already before u do that. 
			:body(
				(! (printf (FORMAT "STEP: Insert Product into %s \n" $mps)))
				(=> (agent-state STEP-RUNNING))

				(if (! (execute (skill "bring_product_to" "place" $mps)))
					;UPDATE WORLD MODEL
					(if (?  (cap-station $mps $cap-color $loaded-status $caps-on-shelf )) 
						(=> (cap-station $mps $cap-color CAP_NOT_LOADED $caps-on-shelf))) 
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD)))
				)
			:effects ( (=> (holding NONE)) )
			:documentation "Insert a product work-peace in a machine's Input for processing of a production step (RS , DS , CS). 
							Should only be called after correctly instructing the machine.
							On succeeding, What ever processing step is assumed to be complete and the world model is updated.
							After the call the Agent is assumed to not hold anything (even if skill failed) TODO:check if holding"
			
			)

		(defop step-insert-cap-from-shelf
			:invocation	( !	(step insert already-at-mps machine $mps ))
			:context 	( 	(machine $mps $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(cap-station $mps $cap-color CAP_NOT_LOADED $caps-on-shelf)
							(MEMQ $mps-state (. "PREPARED" .))
							(~ (holding NONE))) ;same comments from insert-product
			:body(
				(! (printf (FORMAT "STEP:  Insert Cap from %s  shelf \n" $mps )))

				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "LEFT")) 	
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "RIGHT")) 	
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "MIDDLE")) ))) 
			
				(if (! (execute (skill "bring_product_to" "place" $mps "atmps" $slot)))
					(=> (cap-station $mps $cap-color CAP_LOADED $caps-on-shelf)) 
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD))
					)
				)
			:effects ((=> (holding NONE)))
			:documentation "Insert a Caped-Base, that just been picked up from the CS shelf, into the CS to load it with that Cap
							Should only be called after the CS has been instructed to RETRIEVE_CAP.
							On succeeding, the cap station is assumed to be loaded with a cap
							After the call, the agent hold nothing (even if skill failed) TODO:check if holding"
			)
	
	)


