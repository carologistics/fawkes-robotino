;---------------------------------------------------------------------------
;  steps.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri Jan 27 11:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

;Once a Step-Something Op is invoked, The Step Goal (! (step ..)) that caused it to fire is always
;satisfied no matter if the step itself finished. To know if it succeeded you need to check the agent-state
;Or device a way to make sure to react on the step-failure. { like the OPRS's Active/Passive preserve
; (& (! (step do-something ..)) (% (predicate-to-preserve .. )) }
;If Step Goal fails it means there is no Ops with a :context that matches the WM it was 
;expected to be called in. And that you did something wrong assuming that :context.

(

	(defop step-drive-to
		:invocation( !	(step (drive-to machine $mps-name side $side) ))
		:context()  
		:body(
			(! (printf (Format "STEP: Drive-To .. machine %s \n" $mps-name)))
			(=> (agent-state STEP-RUNNING))

			;Sides allowed
			(? (MEMQ $side (. "input" "output" .)))
			(if (? (= $side "input" ))
				(! (= $place (string-cat $mps-name "-I")))
				else 
				(! (= $place (string-cat $mps-name "-O"))))

			(if (! (execute (skill "drive_to" "place" $place) ))
				;TODO:add bs-station-side-switching 
				(=> (agent-state STEP-FINISHD))
				else
				(=> (agent-state STEP-FAILD)) )
			)
		)



	(defop step-get-base
		:invocation( !	(step (get-base machine $mps-name side $side)))
		:context ( 		(machine $mps-name "BS" $m-state $m-prepared $m-zone $m-pose $m-loaded-with)
				 		(MEMQ $m-state (. "PROCESSING" "READY-AT-OUTPUT" "DOWN" .)) ;The Mps Has to had been instructed or down
				 		(holding NONE))
		:body(
			(! (printf (Format "STEP: Get-Base .. machine %s is %s \n" $mps-name  $m-s)))
			;Todo: This could be replace by a unified checking mechanism 
			(if (? (= $m-state "DOWN") )
				(=> (agent-state STEP-PENDING))
				(^ (& (machine $mps-name "BS" @new-state @m-prepared @m-zone @m-pose @m-loaded-with)
					  (MEMQ (val @new-state) (. "PROCESSING" "READY-AT-OUTPUT" .))))) ;Wait for it to be UP.ToDo:WATCHDOG!
				
			;TODO: Have the id generated on READY-AT-OUTPUT or create it here since I should only be able to fetch if there is a base

			(=> (agent-state STEP-RUNNING))
			(if (! (execute (skill "get_product_from" "place" $mps-name "side" $side)) ) 
				(=> (agent-state STEP-FINISHD))
				(=> (holding BASE));put the id
				else
				(=> (agent-state STEP-FAILD)))
			)
		:documentation " Fetch the base from the base station. Here the robot assumed to be already at the BS and already 
						instructed it. If Machine is BROKEN when the step goal is posted. this will fails
						 TODO: handle what happens when BROKEN"

		;questions: is it better if i just passed the active side..
		;Why is it not both active at the same time...is that like a rule or something
		;am a little worried that i can lose the choice to 
		;optimize this side choice thing and leave it up to the robots somehow to go to whatever side

		;I can have a check for preconditions of each step and decide what to 
		;do from a separate op where steps are mapped to their Pre-conditions.  
		;Or just react to it from here
		)


	(defop step-get-output 
		:invocation( ! 	(step (get-output machine $mps)) )
		:context ( 	 	(machine $mps $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(~ (= $mps-type "BS"))
						(MEMQ $mps-state (. "READY-AT-OUTPUT" .))
			 			(holding NONE)
			 			)

		:body(
			(! (printf (FORMAT " STEP: get-output from \n")))
			(=> (agent-state STEP-RUNNING))

			(if (! (execute (skill "get_product_from" "place" $mps "side" "output")))
				(=> (agent-state STEP-FINISHD))
				(=> (holding Product))  
				else
				(=> (agent-state STEP-FAILD))
				)
			)
		:documentation "Fetch a work-peace from an mps output (except BS, there is Fetch-base for that).
						Only works if the machine is READY-AT-OUTPUT.
						On succeeding, the agent is holding the work peace"; TODO:Get the id from the machine fact later on
		)


		(defop step-get-cap
			:invocation( ! 	(step (get-cap machine $mps-name)))
			:context ( 		(cap-station $mps-name $assigned-cap-color $cap-loaded-status $caps-on-shelf )
							(holding NONE))
			:body(
				(! (printf (Format "STEP: Get-From-Shelf \n")))
				(=> (agent-state STEP-RUNNING))
	
				;TODO: dynamically determine which position. 
			 	;Change the # on shelf even if the skill fails 
				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "RIGHT")) 	(! (= $new-caps-on-shelf  2))
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "MIDDLE")) 	(! (= $new-caps-on-shelf  1))
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "LEFT")) 	(! (= $new-caps-on-shelf  3)) ))) 
			
				(if (! (execute (skill "get_product_from" "place" $mps-name "shelf" $slot)))
					(=> (agent-state STEP-FINISHD))
					(=> (holding CAP))
				else
					(=> (agent-state STEP-FAILD)))
			
			)
		:effects ( (=> (cap-station $mps $assigned-cap-color $cap-loaded-status $new-caps-on-shelf)) )
		)



		(defop step-insert
			:invocation ( ! (step (insert machine $mps)))
			:context 	(  	(~ (holding NONE)) ;that should be a work-peace
							(machine $mps $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
						 	(MEMQ $mps-state (. "PREPARED"  "READY-AT-OUTPUT" "DOWN" .)))
							;Maybe check if side is empty OR handle it if not
							;Maybe check if the holding peace is a base or product work-peace
							;Mps has to be instructed already before u do that. 
			:body(
				(! (printf (FORMAT "STEP: Insert Product into %s \n" $mps)))
				(=> (agent-state STEP-RUNNING))

				(if (! (execute (skill "bring_product_to" "place" $mps)))
					;UPDATE WORLD MODEL
					(if (?  (cap-station $mps $cap-color $loaded-status $caps-on-shelf )) 
						(=> (cap-station $mps $cap-color CAP_NOT_LOADED $caps-on-shelf))) 
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD)))
				)
			:effects ( (=> (holding NONE)) )
			:documentation "Insert a product work-peace in a machine's Input for processing of a production step (RS , DS , CS). 
							Should only be called after correctly instructing the machine.
							On succeeding, What ever processing step is assumed to be complete and the world model is updated.
							After the call the Agent is assumed to not hold anything (even if skill failed) TODO:check if holding"
			
			)



		(defop step-insert-atmps
			:invocation	( !	(step (insert-atmps machine $mps)))
			:context 	( 	(machine $mps $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(cap-station $mps $cap-color CAP_NOT_LOADED $caps-on-shelf)
							(MEMQ $mps-state (. "PREPARED" .))
							(~ (holding NONE))) ;same comments from insert-product
			:body(
				(! (printf (FORMAT "STEP:  Insert Cap from %s  shelf \n" $mps )))

				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "LEFT")) 	
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "RIGHT")) 	
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "MIDDLE")) ))) 
			
				(if (! (execute (skill "bring_product_to" "place" $mps "atmps" $slot)))
					(=> (cap-station $mps $cap-color CAP_LOADED $caps-on-shelf)) 
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD))
					)
				)
			:effects ((=> (holding NONE)))
			:documentation "Insert a Caped-Base, that just been picked up from the CS shelf, into the CS to load it with that Cap
							Should only be called after the CS has been instructed to RETRIEVE_CAP.
							On succeeding, the cap station is assumed to be loaded with a cap
							After the call, the agent hold nothing (even if skill failed) TODO:check if holding"
			)


		(defop step-instruct-mps
			:invocation ( !	(step (instruct-mps machine $mps-name $args)))
			:context ( (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with )
						)
			:body (
				;(allowed-states IDLE BROKEN PREPARED PROCESSING PROCESSED READY-AT-OUTPUT WAIT-IDLE DOWN))
				(! (printf (FORMAT "STEP:  Instruct %s \n" $mps-name  )))
				(=> (agent-state STEP-RUNNING))

  				;Handle unexpected calls
				(if (? (MEMQ $mps-state (. "DOWN" "WAIT_IDE" .)))
					( ! (printf (FORMAT "WARN: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-PENDING))
					(^ (& 	(machine $mps-name $mps-type @new-state @m-prepared @m-zone @m-pose @m-loaded-with)
					 		(MEMQ (val @new-state) (. "DOWN" "WAIT_IDE" .))))) ;Wait for it to be UP.ToDo:WATCHDOG!
				
				(if (? (MEMQ $mps-state (. "PREPARED" "READY-AT-OUTPUT" "PROCESSING" "PROCESSED" .)))
					( ! (printf (FORMAT "ERROR: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-FAILD))
					(fail))

				(if (? (MEMQ $mps-state (. "BROKEN" .)))
					( ! (printf (FORMAT "ERROR: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-FAILD))
					(fail))

				(if (! (instruct-mps machine $mps-name $args ))
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD))
					)
				)
			:effects()
			)

	)


