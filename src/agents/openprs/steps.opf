;---------------------------------------------------------------------------
;  steps.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri Jan 27 11:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

;Once a Step-Something Op is invoked, The Step Goal (! (step ..)) that caused it to fire is always
;satisfied no matter if the step itself finished. To know if it succeeded you need to check the agent-state
;Or device a way to make sure to react on the step-failure. { like the OPRS's Active/Passive preserve
; (& (! (step do-something ..)) (% (predicate-to-preserve .. )) }
;If Step Goal fails it means there is no Ops with a :context that matches the WM it was 
;expected to be called in. And that you did something wrong assuming that :context.

(

	(defop step-drive-to
		:invocation( !	(step (drive-to machine $mps-name side $side) ))
		:context()  
		:body(
			(! (printf (Format "STEP: Drive-To .. machine %s \n" $mps-name)))
			(=> (agent-state STEP-RUNNING))
			;Sides allowed
			(? (MEMQ $side (. "input" "output" .)))
			(if (? (= $side "input" ))
				(! (= $place (string-cat $mps-name "-I")))
				else 
				(! (= $place (string-cat $mps-name "-O")))
				)

			(if (! (execute (skill "drive_to" "place" $place) ))
				;do nothing
				else
				(=> (step-failed (drive-to machine $mps-name side $side) )) 
				(fail)
				)
			)
		:effects ( (=> (agent-state STEP-FINISHD)) )
		)

	(defop step-fail-drive-to 
			:invocation  (step-failed (drive-to machine $mps-name side $side))
			:context()
			:body()
			:effects ( (=> (agent-state STEP-FAILD)) )
			)


	(defop step-get-base
		:invocation( !	(step (get-base machine $mps-name side $side)))
		:context ( 		(machine $mps-name "BS" $m-state $m-prepared $m-zone $m-pose $m-loaded-with)
				 		(MEMQ $m-state (. "PROCESSING" "READY-AT-OUTPUT" "DOWN" .)) ;The Mps Has to had been instructed or down
				 		(holding NONE)
				 		;(base-station $mps-name $active-side $failed-side)
				 		(workpiece $ws-id  (base $base-color) (rings none) (cap none) (place $mps-name $side)) 
				 		) 
		:body(
			(! (printf (Format "STEP: Get-Base .. machine %s \n" $mps-name)))
			;Todo: This could be replace by a unified checking mechanism 
			(if (? (= $m-state "DOWN") )
				(=> (agent-state STEP-PENDING))
				(^ (& (machine $mps-name "BS" @new-state @m-prepared @m-zone @m-pose @m-loaded-with)
					  (MEMQ (val @new-state) (. "PROCESSING" "READY-AT-OUTPUT" .))))) ;Wait for it to be UP.ToDo:WATCHDOG!
				
			;TODO: Have the id generated on READY-AT-OUTPUT or create it here since I should only be able to fetch if there is a base

			(=> (agent-state STEP-RUNNING))
			(if (! (execute (skill "get_product_from" "place" $mps-name "side" $side)) ) 
				(=> (agent-state STEP-FINISHD))
				(=> (workpiece $ws-id  (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
				(=> (holding $ws-id));put the id
				else
				(? (machine $mps-name "BS" @m-state @m-prepared @m-zone @m-pose @m-loaded-with))
				(if (? (~ (= (val @m-state) "READY-AT-OUTPUT")))
					(=> (workpiece $ws-id  (base $base-color) (rings none) (cap none) (place LOST LOST))))
				(=> (agent-state STEP-FAILD)))
			)
		:documentation " Fetch the base from the base station. Here the robot assumed to be already at the BS and already 
						instructed it. If Machine is BROKEN when the step goal is posted. this will fails
						 TODO: handle what happens when BROKEN"

		;questions: is it better if i just passed the active side..
		;Why is it not both active at the same time...is that like a rule or something
		;am a little worried that i can lose the choice to 
		;optimize this side choice thing and leave it up to the robots somehow to go to whatever side

		;I can have a check for preconditions of each step and decide what to 
		;do from a separate op where steps are mapped to their Pre-conditions.  
		;Or just react to it from here
		)


	(defop step-get-output 
		:invocation( ! 	(step (get-output machine $mps-name)) )
		:context ( 	 	(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(~ (= $mps-type "BS"))
						(MEMQ $mps-state (. "READY-AT-OUTPUT" .))
			 			(holding NONE)
			 			(workpiece $ws-id $base $rings $cap (place $mps-name "output"));If the peace is not already at output this will fail. But what if it was processing still 
			 			)

		:body(
			(! (printf (FORMAT " STEP: get-output from \n")))
			(=> (agent-state STEP-RUNNING))

			(if (! (execute (skill "get_product_from" "place" $mps-name "side" "output")))
				(=> (agent-state STEP-FINISHD))
				(=> (workpiece $ws-id  $base $rings $cap (place "agent" "gripper")))
				(=> (holding $ws-id))  
				else
				(=> (agent-state STEP-FAILD))
				(? (machine $mps-name $mps-type @m-state @m-prepared @m-zone @m-pose @m-loaded-with))
				(if (? (~ (= (val @m-state) "READY-AT-OUTPUT")))
					(=> (workpiece $ws-id  (base $base-color) (rings none) (cap none) (place LOST LOST))))
				)
			)
		:documentation "Fetch a work-peace from an mps output (except BS, there is Fetch-base for that).
						Only works if the machine is READY-AT-OUTPUT.
						On succeeding, the agent is holding the work peace"; TODO:Get the id from the machine fact later on
		)


		(defop step-get-cap
			:invocation( ! 	(step (get-cap machine $mps-name)))
			:context ( 		(cap-station $mps-name $assigned-cap-color $cap-loaded-status $caps-on-shelf )
							(holding NONE))
			:body(
				(! (printf (Format "STEP: Get-From-Shelf \n")))
				(=> (agent-state STEP-RUNNING))
	
				;TODO: dynamically determine which position. 
			 	;Change the # on shelf even if the skill fails 
				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "RIGHT")) 	(! (= $new-caps-on-shelf  2))
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "MIDDLE")) 	(! (= $new-caps-on-shelf  1))
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "LEFT")) 	(! (= $new-caps-on-shelf  3)) )))

				;If u already here..What ever failed or suceeded consider this position done. 
				;Problem will only happen if i could not get  base but it is still there 
				(=> (cap-station $mps-name $assigned-cap-color $cap-loaded-status $new-caps-on-shelf))

				(if (! (execute (skill "get_product_from" "place" $mps-name "shelf" $slot)))
					(=> (agent-state STEP-FINISHD))
					(! (= $peace-id (rand 1000)))
					(=> (workpiece $peace-id (base UNKNOWN) (rings none) (cap $assigned-cap-color) (place "agent" "gripper") ))
					(=> (holding $peace-id))
				else
					(=> (agent-state STEP-FAILD)) 
					(! (step (get-cap machine $mps-name)))
					)
			
			)
		:effects ( 
		;moved after the caps-on-shelf calc.
		;(=> (cap-station $mps-name $assigned-cap-color $cap-loaded-status $new-caps-on-shelf))
		 )
		)


		(defop step-insert
			:invocation ( ! (step (insert machine $mps-name)))
			:context 	(  	(holding $ws-id) ;that should be a work-peace
							(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
							(~ (= $mps-type "BS"))
						 	(MEMQ $mps-state (. "PREPARED"  "READY-AT-OUTPUT" "DOWN" "IDLE" "WAIT-IDLE".))
			 				(workpiece $ws-id  $base $rings $cap (place "agent" "gripper"));If the peace is not already at output this will fail. But what if it was processing still 
						 	(~ (workpiece $ws-id $base $rings (cap $cap-color) (place  $mps-name "input")))
						 	)
							;Maybe check if side is empty OR handle it if not
							;Maybe check if the holding peace is a base or product work-peace
							;Mps has to be instructed already before u do that. 
			:body(
				(! (printf (FORMAT "STEP: Insert Product into %s \n" $mps-name)))
				(=> (agent-state STEP-RUNNING))

				;Moved here (from the skill sucess branch)coz the skill finishes long enough after the peace is already insterted that
				;if that machine was instructed before the insertion..READY_AT_OUTPUT fires before the skill finishes (and before the 
			  	; Peace place becomes output)
				; (=> (workpiece $ws-id $base $rings $cap (place $mps-name "input")))
				;moved baq
				(if (! (execute (skill "bring_product_to" "place" $mps-name)))
					;UPDATE WORLD MODEL
					;Moved to On_ready-at-output
					; (if (?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
					; 	(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))) 
					(=> (workpiece $ws-id $base $rings $cap (place $mps-name "input")))
					(=> (agent-state STEP-FINISHD))
					else
					;TODO: lose the workpiece after checking if still holding
					(=> (agent-state STEP-FAILD))
					;TODO:Check if still holding first
					(=> (workpiece $ws-id $base $rings $cap (place LOST LOST)))
					)
				)
			:effects ( (=> (holding NONE)) )
			:documentation "Insert a product work-peace in a machine's Input for processing of a production step (RS , DS , CS). 
							Should only be called after correctly instructing the machine.
							On succeeding, What ever processing step is assumed to be complete and the world model is updated.
							After the call the Agent is assumed to not hold anything (even if skill failed) TODO:check if holding"
			
			)


		(defop step-insert-atmps
			:invocation	( !	(step (insert-atmps machine $mps)))
			:context 	( 	(machine $mps-name "CS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf)
							(MEMQ $mps-state (. "PREPARED" "READY-AT-OUTPUT" "DOWN" "IDLE" "WAIT-IDLE".))
							(~ (holding NONE))
							(workpiece $ws-id $base $rings (cap $cap-color) (place "agent" "gripper"))
							(~ (workpiece $ws-id $base $rings (cap $cap-color) (place  $mps-name "input")))
							) 
							;check the work peace more accurately..it should be what u just got from the shelf 
			:body(
				(! (printf (FORMAT "STEP:  Insert Cap from %s  shelf \n" $mps-name )))

				(if (? (= 3 $caps-on-shelf))  				(! (= $slot "LEFT")) 	
				 	else (if (? (= 2 $caps-on-shelf)) 		(! (= $slot "RIGHT")) 	
						 else (if (? (= 1 $caps-on-shelf)) 	(! (= $slot "MIDDLE")) ))) 
			
				(if (! (execute (skill "bring_product_to" "place" $mps-name "atmps" $slot)))
					;Moved to On_ready-at-output
					; (=> (cap-station $mps-name $cap-color CAP_LOADED $caps-on-shelf)) 
					(=> (workpiece $ws-id $base $rings (cap $cap-color) (place $mps-name "input")))
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD))
					;TODO: only lose the work peace after checking if still holding
					(=> (workpiece $ws-id $base $rings $cap (place LOST LOST)))
					)
				)
			:effects ((=> (holding NONE)))
			:documentation "Insert a Caped-Base, that just been picked up from the CS shelf, into the CS to load it with that Cap
							Should only be called after the CS has been instructed to RETRIEVE_CAP.
							On succeeding, the cap station is assumed to be loaded with a cap
							After the call, the agent hold nothing (even if skill failed) TODO:check if holding"
			)


		(defop step-insert-slide
			:invocation ( ! (step (insert-slide machine $mps-name)))
			:context 	(  	(holding $ws-id) ;that should be a work-peace
							(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
			 				(workpiece $ws-id  $base $rings $cap (place "agent" "gripper"));If the peace is not already at output this will fail. But what if it was processing still 
							(ring-station $mps-name (avilible-colors $colors-list) $selected-color $bases-loaded)
							(< $bases-loaded 3)
						 	)
							;Check if slide is already full 
			:body(
				(! (printf (FORMAT "STEP: Insert-slide into %s \n" $mps-name)))
				(=> (agent-state STEP-RUNNING))

				(if (! (execute (skill "bring_product_to" "place" $mps-name "slide" "TRUE")))
					;UPDATE WORLD MODEL
					;Moved to On_ready-at-output
					; (if (?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
					; 	(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))) 
					(=> (ring-station $mps-name (avilible-colors $colors-list) $selected-color (+ $bases-loaded 1)))
					(=> (workpiece $ws-id $base $rings $cap (place $mps-name "slide")))
					(=> (agent-state STEP-FINISHD))
					else
					;TODO: lose the workpiece after checking if still holding
					(=> (agent-state STEP-FAILD))
					;TODO:Check if still holding first
					(=> (workpiece $ws-id $base $rings $cap (place LOST LOST)))
					)
				)
			:effects ( (=> (holding NONE)) )
			:documentation "Insert a product work-peace in a machine's Input for processing of a production step (RS , DS , CS). 
							Should only be called after correctly instructing the machine.
							On succeeding, What ever processing step is assumed to be complete and the world model is updated.
							After the call the Agent is assumed to not hold anything (even if skill failed) TODO:check if holding"
			
			)


		(defop step-instruct-mps
			:invocation ( !	(step (instruct-mps machine $mps-name $args)))
			:context ( (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with )
						)
			:body (
				;(allowed-states IDLE BROKEN PREPARED PROCESSING PROCESSED READY-AT-OUTPUT WAIT-IDLE DOWN))
				(! (printf (FORMAT "STEP:  Instruct %s \n" $mps-name  )))
				(=> (agent-state STEP-RUNNING))

  				;Handle unexpected calls
				(if (? (MEMQ $mps-state (. "DOWN" "WAIT_IDE" .)))
					( ! (printf (FORMAT "WARN: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-PENDING))
					(^ (& 	(machine $mps-name $mps-type @new-state @m-prepared @m-zone @m-pose @m-loaded-with)
					 		(MEMQ (val @new-state) (. "DOWN" "WAIT_IDE" .))))) ;Wait for it to be UP.ToDo:WATCHDOG!
				
				(if (? (MEMQ $mps-state (. "PREPARED" "READY-AT-OUTPUT" "PROCESSING" "PROCESSED" .)))
					( ! (printf (FORMAT "ERROR: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-FAILD))
					(fail))

				(if (? (MEMQ $mps-state (. "BROKEN" .)))
					( ! (printf (FORMAT "ERROR: Trying to instruct %s while its %s" $mps-name $mps-state)))
					(=> (agent-state STEP-FAILD))
					(fail))

				(if (! (instruct-mps machine $mps-name $args ))
					(=> (agent-state STEP-FINISHD))
					else
					(=> (agent-state STEP-FAILD))
					(fail)
					)
				)
			:effects()
			)

	)


