;---------------------------------------------------------------------------
;  production.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Jan 17 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(

; 	(defop produce-c0-imperative
; 		:invocation	(timer "beacon" $last-sec $last-usec $seq)
; 		:context(	(order $id c0 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
; 				 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
; 				 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
; 				 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
; 				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
; 				 	(~ (= $cs-state BROKEN))
; 				 	(~ (= $cs-state DOWN))
; 					(peer-id private $peer-id)
; 				   	(team-color $team-color )
; 				   	(agent-state IDLE)
; 				   	(~ (in-production))
; 				   	)

; 		:body(
; 			(! (start-critical-section))
; 			(=> (in-production))
; 			(! (kill-other-intentions))
; 			(! (end-critical-section))
; 			(! (print "Producing C0..."))
; 			(=> (holding NONE))

; 			(! (print "PRELOADING CAP STATION..."))
; 		 	;(! (step (get-cap 		machine $cs-name)))
; 			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))
; 			;(! (step (insert-atmps  machine $cs-name)))
; 			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))

; 			;(! (step (instruct-mps 	machine $cs-name (args operation RETRIEVE_CAP)))) 
; 			;;( ! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )
; 			( ^ (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )

; 			;(! (step (drive-to		machine $cs-name side "output")))
; 			;(! (step (get-output 	machine $cs-name)))
; 			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place "agent" "gripper")))
; 			(=> (holding NONE)) ;FAKE knowledge to let the robot goup for the base with not poblem..I want to keep the constraint of no holding to make sure what to do it i still habe

; 			(! (print "FETHCHING THE BASE..."))
; 			; (! (step (drive-to 			machine $bs-name side "input"))) ; todos, get the side from a fact that makes sure the active-side is updated
; 			; ; TODO:get the lock
; 			; (! (step (instruct-mps 		machine $bs-name (args side INPUT color $base-color) )));let input be a string or a symobol everywhere
; 			; (! (step (get-base			machine $bs-name side "input")))
; 			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
; 			;(? (workpiece $new-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))


			
; 			(! (print "INSETRING INTO CS..."))
; 			; (! (step (drive-to 		machine $cs-name 	side "input")))
; 			; (! (step (insert 		machine $cs-name)))
; 			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place $cs-name "input")))
; 			; (! (step (instruct-mps 	machine $cs-name 	(args operation MOUNT_CAP))));if u instructed with no cap i think it breaks it
; 			;;(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")))		
; 			(^ (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")))		

; 			;====Delivery
; 			(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place "agent" "gripper")))		
; 			; (! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name "input")))
; 			(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate)))		


; 			)


; 	:effects ()
; 	:documentation "A completly imparative way to produce the c0 product using only a single robot. 
; 					This is only an exemplary Op to test the water. It starts in response for a C0 order and assumes nothing else is happing on the feild
; 					No locks. No coordination and everything is hard coded"

; 	)



; (defop produce-c1-imperative
; 		:invocation	(timer "beacon" $last-sec $last-usec $seq)
; 		:context(	(order $id c1 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
; 				 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
; 				 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
; 				 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
; 				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
; 				 	(machine $rs-name "RS" $rs-state $rs-prepared $rs-zone $rs-pose $rs-loaded-with)
; 				 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
; 				 	(= $ring-to-mount (car $ring-colors))
; 				 	(MEMQ $ring-to-mount $colors-list)
; 					(peer-id private $peer-id)
; 				   	(team-color $team-color )
; 				   	(agent-state IDLE)
; 				   	(~ (in-production))
; 				   	)

; 		:body(
; 			(! (start-critical-section))
; 			(=> (in-production))
; 			(! (kill-other-intentions))
; 			(! (end-critical-section))
; 			(! (print "Producing C1..."))
; 			(=> (holding NONE))


; 			(=> (goal-inmind (workpiece 0 (base $base-color) (rings $ring-to-mount) (cap $cap-color) (place $ds-name $delivery-gate))))


; 			(! (print "PRELOADING CAP STATION..."))
; 			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place "agent" "gripper")))
; 			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place $cs-name "input")))

; 			(^ (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
; 			(~> (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
; 			(=> (workpiece (* -1 (rand 10000)) (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			
; 			;ADD BASES
; 			(? (ring $ring-to-mount $bases-required))
; 			(? (ring-station $rs-name (avilible-colors $colors-list)  @selected-color @bases-loaded))
; 			(while (? (> $bases-required (val @bases-loaded)))
; 				;If there is a negative-ID'd puck..just use it for payment
; 				(if (? (& 	(workpiece $negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
; 							(< $negtive-id 0)
; 							));Maybe even genralize the place to input too or even shelfs
; 					(! (= @payment-base $negtive-id))
; 					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
; 					else
; 					(! (workpiece @payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
; 					)
					
; 					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place $rs-name "slide")))
; 					(? (ring-station $rs-name (avilible-colors $colors-list)  @selected-color @bases-loaded))
; 				)

; 			(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output"))
; 						(< (val @negtive-id) 0)))
; 				(! (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
; 				(=> (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place LOST` LOST)))
; 				(=> (holding NONE)) 
; 				)

; 			;alternatly u can sleep here till the bases are three then start..that is dangerous for many reasons though


; 			(! (print "FETHCHING THE BASE..."))
; 			; ; TODO:get the lock
; 			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
; 			;(? (workpiece $new-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))


; 			(! (print "INSETRING INTO RS..."))
; 			(! (workpiece $new-base-id (base $base-color) (rings none) 				(cap none) 	(place $rs-name "input")))
; 			(^ (workpiece $new-base-id (base $base-color) (rings $ring-to-mount) 	(cap none) 	(place $rs-name "output")))		


			
; 			(! (print "INSETRING INTO CS..."))
; 			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place "agent" "gripper")))
; 			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place $cs-name "input")))
; 			(^ (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $cs-name "output")))		

; 			;====Delivery
; 			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place "agent" "gripper")))		
; 			; (! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name "input")))
; 			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $ds-name $delivery-gate)))		
; 			)


; 	:effects ((~> (in-production)))
; 	:documentation "A completly imparative way to produce the c0 product using only a single robot. 
; 					This is only an exemplary Op to test the water. It starts in response for a C0 order and assumes nothing else is happing on the feild
; 					No locks. No coordination and everything is hard coded"

; 	)



	(defop execute-goal-step
		:invocation (! (GO))
		:context ( 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with) 
				 	(master-of REASONING $robot-name)
				 	 )
		:setting (setting "robot-name" $robot-name) 
		:body(

			(if (? (goal-inmind (workpiece 0 $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)) ))
			else  
			(! (choose-goal-inmind) )
			)
			(? (goal-inmind (workpiece 0 $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)) ))

			(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			(? (machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)) 
			(? (& 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with) 
					(cap-station $cs-name $cap-color $loaded-status $caps-on-shelf)
					(= $goal-cap (cap $cap-color))))

			(if (? (= $goal-rings (rings none)))
				else 
				(if (? (= $goal-rings (rings $first-ring-color)))
					else
					(if (? (= $goal-rings (rings $first-ring-color $second-ring-color)))
						else 
						(if (? (= $goal-rings (rings $first-ring-color $second-ring-color $third-ring-color))))
						)
					)
				)

			(if (? (BOUNDP $first-ring-color))
				(? (&	(machine $first-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
						(ring-station $first-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
						(MEMQ $first-ring-color @avilible-colors-list)
						))
				)

			(if (? (BOUNDP $second-ring-color))
				(? (&	(machine $second-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
						(ring-station $second-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
						(MEMQ $second-ring-color @avilible-colors-list)
						))
				)

			(if (? (BOUNDP $third-ring-color))
				(? (&	(machine $third-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
						(ring-station $third-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
						(MEMQ $third-ring-color @avilible-colors-list)
						))
				)


			(if (? (workpiece @some-id $goal-base $goal-rings $goal-cap (place $cs-name "output")))
				(! (workpiece (val @some-id) $goal-base $goal-rings $goal-cap (place "agent" "gripper")))
				(! (workpiece (val @some-id) $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)))
				(~> (goal-inmind (workpiece 0 $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)))) 
				(succeed)
				)

			;Load_CAP
			(if (? (= $loaded-status CAP_NOT_LOADED))
				(! (workpiece @UNKNOWN-id (base UNKNOWN) (rings none) $goal-cap (place "agent" "gripper")))
				(! (workpiece (val @UNKNOWN-id) (base UNKNOWN) (rings none) $goal-cap (place $cs-name "input")))
				(succeed)
				)

			;cap_station
			(if (? (workpiece @some-id $goal-base $goal-rings (cap none) (place @some-mps "output")))
				(! (workpiece (val @some-id) $goal-base $goal-rings (cap none) (place "agent" "gripper")))
				(! (workpiece (val @some-id) $goal-base $goal-rings (cap none) (place $cs-name "input")))
				(succeed)
				)

			(if (? (|| 	(& (BOUNDP $third-ring-color) 		(workpiece $some-id $goal-base (rings $first-ring-color $second-ring-color) (cap none) (place @some-mps "output"))	(= @some-mps $second-rs-name) 	(= $ring-to-mount $third-ring-color) 	)
						(& (BOUNDP $second-ring-color) 		(workpiece $some-id $goal-base (rings $first-ring-color)					(cap none) (place @some-mps "output")) 	(= @some-mps $first-rs-name) 	(= $ring-to-mount $second-ring-color)	)
						(& (BOUNDP $first-ring-color) 	(~ 	(workpiece $some-id $goal-base (rings $first-ring-color) 					(cap none) (place @some-mps "output"))) (= @some-mps $first-rs-name)	(= $ring-to-mount $first-ring-color) 	) 
						))
				
				(? (ring $ring-to-mount $bases-required))
				(? (& 	(ring-station $rs-name (avilible-colors @colors-list)  @selected-color $bases-loaded)
						(MEMQ $ring-to-mount @colors-list)))
				
				;LOAD BASES IF NEEDED
				(if (? (< $bases-loaded $bases-required))
					 ;TODO:Could be replaced with a check on what wp at slide
					;USE NEGATIVE WP IF ANY 																							
					(if (? (& 	(workpiece $negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
								(< $negtive-id 0)
								));Maybe even genralize the place to input too or even shelfs
						(! (= $payment-base $negtive-id))
						(! (workpiece $payment-base @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
						else
						(! (workpiece $payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
						)
					(! (workpiece $payment-base @dontcare_base @dontcare_rings @dontcare_cap (place $rs-name "slide")))
					(succeed)
					)

				(if (? (BOUNDP $some-id))
					(? (workpiece $some-id $goal-base $existing-rings (cap none) (place @dontcare_mps @dontcare_side)) )
					else
					(! (= $existing-rings (rings none) ))
					)

				(! (workpiece $some-id $goal-base $existing-rings (cap none) (place "agent" "gripper"))) 
				(! (workpiece $some-id $goal-base $existing-rings (cap none) (place $rs-name "input")))
				(succeed)
				)

 			)
		)
	
	; (defop break-goal-needs
	; 	:invocation ( (goal-inmind (workpiece 0 $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)))) )
	; 	:context () 
	; 	:body(

	; 			(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
	; 			(? (machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)) 
	; 			(? &(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with) 
	; 				(cap-station $cs-name $cap-color $loaded-status $caps-on-shelf)
	; 				(= $goal-cap (cap $cap-color)))

	; 			(if (? (= $goal-rings (rings none)))
	; 				else 
	; 				(if (? (= $rings (rings $first-ring-color)))
	; 					else
	; 					(if (? (= $rings (rings $first-ring-color $second-ring-color)))
	; 						else 
	; 						(if (? (= $rings (rings $first-ring-color $second-ring-color $third-ring-color))))
	; 						)
	; 					)
	; 				)

	; 		(if (? (~ (BOUNDP $first-ring-color)))
	; 			(? &	(machine $first-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
	; 					(ring-station $first-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
	; 					(MEMQ $first-ring-color @avilible-colors-list) 
	; 			)

	; 		(if (? (~ (BOUNDP $second-ring-color)))
	; 			(? &	(machine $second-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
	; 					(ring-station $second-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
	; 					(MEMQ $second-ring-color @avilible-colors-list) 
	; 			)

	; 		(if (? (~ (BOUNDP $third-ring-color)))
	; 			(? &	(machine $third-rs-name "RS" @rs-state @rs-prepared @rs-zone @rs-pose @rs-loaded-with) 
	; 					(ring-station $third-rs-name (avilible-colors @avilible-colors-list) @selected-color @bases-loaded)
	; 					(MEMQ $third-ring-color @avilible-colors-list) 
	; 			)

	; 		(=> (need (workpiece 0 $goal-base $goal-rings $goal-cap (place $cs-name "output")) for (workpiece 0 $goal-base $goal-rings $goal-cap (place $ds-name $delivery-gate)) ))

	; 		(=> (need (workpiece 0 $goal-base $goal-rings (cap none) (place $cs-name "input"))  for (workpiece 0 $goal-base $goal-rings $goal-cap (place $cs-name "output")) ))			
	; 		(=> (need (workpiece 0 $goal-base $goal-rings (cap none) (place "agent" "gripper")) for (workpiece 0 $goal-base $goal-rings $goal-cap (place $cs-name "input")) ))
	; 		(=> (need (cap-station $cs-name $cap-color CAP_LOADED @DONT_CARE-on-shelf))) 		for (workpiece 0 $goal-base $goal-rings $goal-cap (place $cs-name "input")) ))
	; 		)
	; 	)



	(defop produce-c3-imperative
		:invocation	(timer "beacon" $last-sec $last-usec $seq)
		:context(	(order $id c3 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
				 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
				 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
				 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
					(peer-id private $peer-id)
				   	(team-color $team-color )
				   	(agent-state IDLE)
				   	(~ (in-production))
				   	)

		:body(
			(! (start-critical-section))
			(=> (in-production))
			(! (kill-other-intentions))
			(! (end-critical-section))
			(! (print "Producing 3..."))
			(=> (holding NONE))

			(! (choose-goal-inmind))


			(! (print "PRELOADING CAP STATION..."))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place "agent" "gripper")))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place $cs-name "input")))

			(^ (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			(~> (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			(=> (workpiece (* -1 (rand 10000)) (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))



			(! (= @ring-colors-list $ring-colors))

			;FIRST RING
			(! (= @color-to-mount 	(car @ring-colors-list)))
			(! (= @ring-colors-list (cdr @ring-colors-list)))

			(? (ring (val @color-to-mount) @bases-required))
			(? (& 	(ring-station @rs-name (avilible-colors @colors-list)  @selected-color @bases-loaded)
					(MEMQ (val @color-to-mount) @colors-list)))
			
			;LOAD BASES
			(while (? (> (val @bases-required) (val @bases-loaded)))
				;If there is a negative-ID'd puck..just use it for payment
				(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
							(< @negtive-id 0)
							));Maybe even genralize the place to input too or even shelfs
					(! (= @payment-base (val @negtive-id)))
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
					else
					(! (workpiece @payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
					)
					
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place (val @rs-name) "slide")))
					(? (ring-station (val @rs-name) (avilible-colors @colors-list)  @selected-color @bases-loaded))
				)

			(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output"))
						(< @negtive-id 0)))
				(! (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
				(=> (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place LOST` LOST)))
				(=> (holding NONE)) 
				)


			(! (print "FETHCHING THE BASE..."))
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))

			(! (print "INSETRING INTO RS..."))
			(! (workpiece $new-base-id (base $base-color) (rings none) 				(cap none) 	(place (val @rs-name) "input")))
			(^ (workpiece $new-base-id (base $base-color) (rings @color-to-mount) 	(cap none) 	(place (val @rs-name) "output")))		




			;SECOND RING
			(! (= @color-to-mount 	(car @ring-colors-list)))
			(! (= @ring-colors-list (cdr @ring-colors-list)))

			(? (ring (val @color-to-mount) @bases-required))
			(? (& 	(ring-station @rs-name (avilible-colors @colors-list)  @selected-color @bases-loaded)
					(MEMQ (val @color-to-mount) @colors-list)))
			
			;LOAD BASES
			(while (? (> (val @bases-required) (val @bases-loaded)))
				;If there is a negative-ID'd puck..just use it for payment
				(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
							(< @negtive-id 0)
							));Maybe even genralize the place to input too or even shelfs
					(! (= @payment-base (val @negtive-id)))
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
					else
					(! (workpiece @payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
					)
					
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place (val @rs-name) "slide")))
					(? (ring-station (val @rs-name) (avilible-colors @colors-list)  @selected-color @bases-loaded))
				)

			(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output"))
						(< @negtive-id 0)))
				(! (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
				(=> (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place LOST` LOST)))
				(=> (holding NONE)) 
				)


			(! (print "FETHCHING THE Producing..."))
			(! (workpiece $new-base-id (base $base-color) (rings $first-ring) (cap none) (place "agent" "gripper")))

			(! (print "INSETRING INTO RS..."))
			(! (workpiece $new-base-id (base $base-color) (rings $first-ring) 					(cap none) 	(place (val @rs-name) "input")))
			(^ (workpiece $new-base-id (base $base-color) (rings $first-ring @color-to-mount) 	(cap none) 	(place (val @rs-name) "output")))		



			;THIRD RING
			(! (= @color-to-mount 	(car @ring-colors-list)))
			(! (= @ring-colors-list (cdr @ring-colors-list)))

			(? (ring (val @color-to-mount) @bases-required))
			(? (& 	(ring-station @rs-name (avilible-colors @colors-list)  @selected-color @bases-loaded)
					(MEMQ (val @color-to-mount) @colors-list)))
			
			;LOAD BASES
			(while (? (> (val @bases-required) (val @bases-loaded)))
				;If there is a negative-ID'd puck..just use it for payment
				(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
							(< @negtive-id 0)
							));Maybe even genralize the place to input too or even shelfs
					(! (= @payment-base (val @negtive-id)))
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
					else
					(! (workpiece @payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
					)
					
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place (val @rs-name) "slide")))
					(? (ring-station (val @rs-name) (avilible-colors @colors-list)  @selected-color @bases-loaded))
				)

			(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output"))
						(< @negtive-id 0)))
				(! (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
				(=> (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place LOST` LOST)))
				(=> (holding NONE)) 
				)


			(! (print "FETHCHING THE Producing..."))
			(! (workpiece $new-base-id (base $base-color) (rings $first-ring $second-ring) (cap none) (place "agent" "gripper")))

			(! (print "INSETRING INTO RS..."))
			(! (workpiece $new-base-id (base $base-color) (rings $first-ring $second-ring) 					(cap none) 	(place (val @rs-name) "input")))
			(^ (workpiece $new-base-id (base $base-color) (rings $first-ring $second-ring @color-to-mount) 	(cap none) 	(place (val @rs-name) "output")))		




			(! (print "INSETRING INTO CS..."))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place "agent" "gripper")))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place $cs-name "input")))
			(^ (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $cs-name "output")))		

			;====Delivery
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place "agent" "gripper")))		
			; (! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name "input")))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $ds-name $delivery-gate)))		
			)


	:effects ()
	:documentation "A completly imparative way to produce the c0 product using only a single robot. 
					This is only an exemplary Op to test the water. It starts in response for a C0 order and assumes nothing else is happing on the feild
					No locks. No coordination and everything is hard coded"

	)
	

	; (defop choose-goal-in-mind
	;     :invocation( ! (choose-goal-inmind) )
	;     :context(   (order $id c1 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
	;           (machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
	;           )
	;     :body(

	;       (! (= $wp-base (base $base-color)))
	;       (! (= $wp-cap (cap $cap-color)))
	;       (! (= @wp-rings (rings NONE))) 

	;       (if (? (= 1 (LENGTH $ring-colors)))  (! (= @wp-rings (rings (car $ring-colors)))) )
	;       (if (? (= 2 (LENGTH $ring-colors)))  (! (= @wp-rings (rings (car $ring-colors) (cadr $ring-colors)))) )
	;       (if (? (= 3 (LENGTH $ring-colors)))  (! (= @wp-rings (rings (car $ring-colors) (cadr $ring-colors) (caddr $ring-colors)))) )
	      
	;       (=> (goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate)) ))
	;       (=> (choose-goal-inmind))
	;     )
	;   )
	
)
