;---------------------------------------------------------------------------
;  production.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Jan 17 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(

	(defop produce-c0-imperative
		:invocation	(timer "beacon" $last-sec $last-usec $seq)
		:context(	(order $id c0 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
				 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
				 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
				 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
				 	(~ (= $cs-state BROKEN))
				 	(~ (= $cs-state DOWN))
					(peer-id private $peer-id)
				   	(team-color $team-color )
				   	(agent-state IDLE)
				   	(~ (in-production))
				   	)

		:body(
			(! (start-critical-section))
			(=> (in-production))
			(! (kill-other-intentions))
			(! (end-critical-section))
			(! (print "Producing C0..."))
			(=> (holding NONE))

			(! (print "PRELOADING CAP STATION..."))
		 	;(! (step (get-cap 		machine $cs-name)))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))
			;(! (step (insert-atmps  machine $cs-name)))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))

			;(! (step (instruct-mps 	machine $cs-name (args operation RETRIEVE_CAP)))) 
			;;( ! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )
			( ^ (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )

			;(! (step (drive-to		machine $cs-name side "output")))
			;(! (step (get-output 	machine $cs-name)))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place "agent" "gripper")))
			(=> (holding NONE)) ;FAKE knowledge to let the robot go for the base with not poblem..I want to keep the constraint of no holding to make sure what to do it i still habe

			(! (print "FETHCHING THE BASE..."))
			; (! (step (drive-to 			machine $bs-name side "input"))) ; todos, get the side from a fact that makes sure the active-side is updated
			; ; TODO:get the lock
			; (! (step (instruct-mps 		machine $bs-name (args side INPUT color $base-color) )));let input be a string or a symobol everywhere
			; (! (step (get-base			machine $bs-name side "input")))
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
			;(? (workpiece $new-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))


			
			(! (print "INSETRING INTO CS..."))
			; (! (step (drive-to 		machine $cs-name 	side "input")))
			; (! (step (insert 		machine $cs-name)))
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place $cs-name "input")))
			; (! (step (instruct-mps 	machine $cs-name 	(args operation MOUNT_CAP))));if u instructed with no cap i think it breaks it
			;;(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")))		
			(^ (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")))		

			;====Delivery
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place "agent" "gripper")))		
			; (! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name "input")))
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate)))		
	

			)


	:effects ()
	:documentation "A completly imparative way to produce the c0 product using only a single robot. 
					This is only an exemplary Op to test the water. It starts in response for a C0 order and assumes nothing else is happing on the feild
					No locks. No coordination and everything is hard coded"

	)



(defop produce-c1-imperative
		:invocation	(timer "beacon" $last-sec $last-usec $seq)
		:context(	(order $id c1 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
				 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
				 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
				 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
				 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
				 	(machine $rs-name "RS" $rs-state $rs-prepared $rs-zone $rs-pose $rs-loaded-with)
				 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
				 	(= $ring-to-mount (car $ring-colors))
				 	(MEMQ $ring-to-mount $colors-list)
					(peer-id private $peer-id)
				   	(team-color $team-color )
				   	(agent-state IDLE)
				   	(~ (in-production))
				   	)

		:body(
			(! (start-critical-section))
			(=> (in-production))
			(! (kill-other-intentions))
			(! (end-critical-section))
			(! (print "Producing C1..."))
			(=> (holding NONE))


			(=> (goal-inmind (workpiece 0 (base $base-color) (rings $ring-to-mount) (cap $cap-color) (place $ds-name $delivery-gate))))


			(! (print "PRELOADING CAP STATION..."))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place "agent" "gripper")))
			(! (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap $cap-color) 	(place $cs-name "input")))

			(^ (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			(~> (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			(=> (workpiece (* -1 (rand 10000)) (base UNKNOWN) (rings none) (cap none) 		(place $cs-name "output") ))
			
			;ADD BASES
			(? (ring $ring-to-mount $bases-required))
			(? (ring-station $rs-name (avilible-colors $colors-list)  @selected-color @bases-loaded))
			(while (? (> $bases-required (val @bases-loaded)))
				;If there is a negative-ID'd puck..just use it for payment
				(if (? (& 	(workpiece $negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output")) 
							(< $negtive-id 0)
							));Maybe even genralize the place to input too or even shelfs
					(! (= @payment-base $negtive-id))
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
					else
					(! (workpiece @payment-base (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
					)
					
					(! (workpiece (val @payment-base) @dontcare_base @dontcare_rings @dontcare_cap (place $rs-name "slide")))
					(? (ring-station $rs-name (avilible-colors $colors-list)  @selected-color @bases-loaded))
				)

			(if (? (& 	(workpiece @negtive-id @dontcare_base @dontcare_rings @dontcare_cap (place @dontcare_machine "output"))
						(< (val @negtive-id) 0)))
				(! (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place "agent" "gripper")))
				(=> (workpiece (val @negtive-id) @dontcare_base @dontcare_rings @dontcare_cap (place LOST` LOST)))
				(=> (holding NONE)) 
				)

			;alternatly u can sleep here till the bases are three then start..that is dangerous for many reasons though


			(! (print "FETHCHING THE BASE..."))
			; ; TODO:get the lock
			(! (workpiece $new-base-id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
			;(? (workpiece $new-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))


			(! (print "INSETRING INTO RS..."))
			(! (workpiece $new-base-id (base $base-color) (rings none) 				(cap none) 	(place $rs-name "input")))
			(^ (workpiece $new-base-id (base $base-color) (rings $ring-to-mount) 	(cap none) 	(place $rs-name "output")))		


			
			(! (print "INSETRING INTO CS..."))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place "agent" "gripper")))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap none) 		(place $cs-name "input")))
			(^ (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $cs-name "output")))		

			;====Delivery
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place "agent" "gripper")))		
			; (! (workpiece $new-base-id (base $base-color) (rings none) (cap $cap-color) (place $ds-name "input")))
			(! (workpiece $new-base-id (base $base-color) $final-rings (cap $cap-color) (place $ds-name $delivery-gate)))		
			)


	:effects ()
	:documentation "A completly imparative way to produce the c0 product using only a single robot. 
					This is only an exemplary Op to test the water. It starts in response for a C0 order and assumes nothing else is happing on the feild
					No locks. No coordination and everything is hard coded"

	)

)