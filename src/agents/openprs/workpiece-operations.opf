;---------------------------------------------------------------------------
;  workpiece-operations.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri FEB 6 17:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(


	; (defop CHECK-READY?
	; 	:invocation( ! (is-ready? (NEED $resource AT $place FOR $result CONSTRAINTS $constraints) $ready-in )))
	; 	:context ()
	; 	:body(
	; 		;ARE CONSRAINTS SATISFIED?
	; 		;No-> THEN NOT-READY

	; 		;YES->
	; 		;HOW MANY MAIPULATION STEPS TP GET RESOURCE AVILBLE

	; 		)
	; 	:effects()
	; )


	(defop wp-somewhere-to-gripper
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place "agent" "gripper")) )
		:context ( (holding none) )
		:body(
			(! (printf (FORMAT "WP_Place-->Gripper: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

			;TODO; IF the id was not bound in the goal that fires this op. It will be matched to ANY workpiece that has the same discription...DO I REALLY WANT THIS?!
			;TODO: there is a little problem here that the matching piece does not always exist yet..Meaning sometimes it is still processing 
			;or the machine is down and I will only know the new place when it is ready. ..So for the old place..There is a puck with the same id
			;But not the same discription..The condition will fail ..even thought driving there might actually be a good idea
			(if (? (& (workpiece $wp-id $base $rings $cap (place $mps-name $side))
						(~ (= $side "slide"))
						))																				;WP exists in the world (i,e Database)
				(! (printf (FORMAT "WP_Place --> Gripper: Found a peace at %s %s..Going to get it \n"  $mps-name $side)))
				(if (? (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with))
					(! (step (drive-to machine $mps-name side $side))) 									;Common driving STEP
					(if (? (= $mps-type "BS"))
						(! (step (get-base 	machine $mps-name side $side))) 
						(succeed)
 						)
					(if (? (= $mps-type "RS"))
						(! (step (get-output machine $mps-name)))
						(succeed)
 						)
					(if (? (= $mps-type "CS"))
						; (if (? (& 	(= $base (base UNKNOWN))
						; 			(= $cap (cap $cap-color)) 
						; 			(~ (= $cap-color none))
						; 			))
						; 	(! (step (get-cap machine $mps-name)))	
						; 	else
							(! (step (get-output machine $mps-name)))
							(succeed)
						;	)
						)
					(if (? (= $mps-type "DS"))
						(! (step (get-output machine $mps-name)))
						(succeed)
  						)
					else
					(! (printf (FORMAT "WP_Place --> Gripper: I think the peace is lost..will just fail \n" )))
					(fail)
					)
				else																					;WP Does not exists in the world (i,e Database)
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= $cap (cap $cap-color)) (~ (= $cap-color none))
							))																			;Its a New Caped Shelf Base, Create it
					(? (cap-station $cs-name $cap-color $loaded-status $caps-on-shelf))
					(! (step (drive-to 	machine $cs-name side "input")))
					(! (step (get-cap 	machine $cs-name)))
					(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
					(succeed)
 					)
				(if (? (& 	(= $base (base $base-color)) (~ (= $base-color UNKNOWN))	
							(= $rings (rings none))
							(= $cap (cap none))
							))
					(! (printf (FORMAT "WP_Place --> Gripper: producing a new base \n" )))
					;TODO: match on the base station color..For now just get it from the C-BS, CORRECT THIS SOON
					(! (= $bs-name "C-BS"))
					(! (= $active-side "input"))
					(! (step (drive-to 		machine $bs-name side $active-side)))
					;If there is a base already-at-output, no need to instruct 
					(if (? (~ (machine $bs-name "BS" "READY_AT_OUTPUT" $bs-prepared $bs-zone $bs-pose $bs-loaded-with)))
						(! (step (instruct-mps 	machine "C-BS" (args side INPUT color $base-color)) ))
						(^ (workpiece $wp-id $base $rings $cap (place $bs-name $active-side)));hazardous...find a better way
						)
					(! (step (get-base machine $bs-name side $active-side)))
					(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
					(succeed)
 					)
				)

				(! (printf (FORMAT "WP_Place --> Gripper: Could not handle this peace %s %s %s %s \n"  $wp-id $base $rings $cap )))
				(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 
				(fail)
				;TODO: handle cases that
				;	wp has no or different id but same description and exists somewhere (this could allow me to know what I want but 
				;	not where it is or just that it will exist somewhere still no name)			
			)
		:documentation "Sends the Agent to gripp a workpiece from 'somewhere' if that workpiece exist in the world (ie,matches a WP with
						 the same Id as in the goal, or any similar WP if the id was not bound in the goal_MIGHT CHANGE THAT SOON)
						In case the workpiece is a New base or a New caped-shelf-base and no match found already, Grab a new one"
		)		


	

	(defop wp-gripper-to-input
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name "input")) )
		:context ( 		(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(holding $wp-id)
						) 				;Maybe the input side has to be empty for that (or make a need for it)
		:body (

			(if (? 	(= $mps-type "BS"))
				(! (printf (FORMAT "WP_GRIPPER-->INPUT: Why are you trying to insert to a BS ?!?!..Will fail \n ")))
				(fail)
				)
			(if (? 	(= $mps-type "RS"))
				(! (step (drive-to machine $mps-name side "input")))
				(! (decide-what-to-intstruct $mps-name $args));; I want to have it as a call to be more fixable how it is done or based on what () from a subgoal, or machine handling 
				(! (print $args ))
				(! (step (instruct-mps machine $mps-name $args)))
				(! (step (insert machine $mps-name)))
				(succeed)
				)
			(if (? 	(= $mps-type "DS"))
			
				(succeed)
 				)
			(if (? 	(= $mps-type "CS"))
				(? (cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf))
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= $cap (cap $cap-color))
							))
						(if (? (= $cap-loaded-status CAP_NOT_LOADED))
							(! (step (instruct-mps  machine $mps-name (args operation RETRIEVE_CAP))))
							(! (step (insert-atmps machine $mps-name)))
							(succeed)
 							else
							(! (printf (FORMAT "WP_ GRIPPER-->INPUT: Cap Is already loaded !!!!!!!..will fail\n" )))
							; TODO: Move to a step Release puck for consistency
							(=> (holding none))
							(=> (workpiece $wp-id $base 
												$rings 
												$cap 
												(place LOST LOST)))
							(fail)
							)
						)
				(if (? (& 	(~ (= $base (base UNKNOWN))) 
							(= $cap (cap none)) 
							(= $cap-loaded-status CAP_LOADED) 
							))

					(! (step (drive-to machine $mps-name side "input")))
					(! (step (instruct-mps  machine $mps-name (args operation MOUNT_CAP))))
					(! (step (insert machine $mps-name)))
					(succeed)
 					;Normal workpiece,just let it pass to the insertion step 
					else
					(! (printf (FORMAT " WP_GRIPPER-->INPUT: Something is not right!. CAP_NOT_LOADED or Wrong Puck!..will fail \n")))
					(fail)
					)
				)
			;Default insertion Step
			(! (step (drive-to machine $mps-name side "input")))
			(! (step (insert machine $mps-name)))
			)
		) 


		; (defop execute-wp-input-to-output--CS_MOUNT_CAP
		; 	:invocation ( ! (workpiece $wp-id $base $rings (cap $cap-color) (place $mps-name "output") ) )
		; 	:context ( 		(machine $mps-name "CS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
		; 					(cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf)
		; 				 	(workpiece $wp-id $base $rings (cap none) (place $mps-name "input"))
		; 				 	(= $cap-loaded-status CAP_LOADED)
		; 				 	(~ (= $base (base UNKNOWN)))
		; 				 	)
		; 	:body (
		; 		; (if (? (= $cap-loaded-status CAP_NOT_LOADED))
		; 		; 	(! (printf (FORMAT "NEED input-output--CS: Trying to insert WP and no CAP ....will fail\n" $mps-name )))
		; 		; 	;may be here u need to make sure that there is a cap at the Cap station of get one urgently.
		; 		; 	;but it the workpreace is already at the input ..it is kinda too late for that man..That means u need to remove it
		; 		; 	;to recover from this..Maybe that is a good thing if shit happens...But this is the sort of shit that should not happen
		; 		; 	;Would only happen if Agent THOUGHT that the cap was loaded but its not...other wise such action should not even be avilabe
		; 		; 	;big shit case ,,should not happen..
		; 		; 	(fail)
		; 		; 	)

		; 		;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
		; 		;with high urgencey sleeping this task till a good time come and attempt the instruction..
		; 		;Good to know here is that once u have a work peace in the input..U really need it gone with a MOUNT_CAP instruction 
		; 		;in whatever case (even if it was no longer required).  

		; 		(! (step (instruct-mps  machine $mps-name (args operation MOUNT_CAP))))
		; 		)
		; 	:documentation "Process a Capless workpiece existing currently at the input of a CS, by instructing it with a MOUNT_CAP.
		; 					if the instruction worked you should have the same workpiece with a cap_mounted on the output side after 
		; 					machine is done processing.
		; 					The goal fails if the CAP is not LOADED. Cap loading has to be insured before the goal call.Actually even
		; 					before the the peace is at the input. Its already too late if peace is at input and there is no cap "
		; 	)

		; (defop execute-wp-input-to-output--CS_RETRIVE_CAP
		; 	:invocation ( ! (workpiece $wp-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )
		; 	:context ( 		(machine $mps-name "CS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
		; 					(cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf)
		; 				 	(workpiece $wp-id (base UNKNOWN) $rings (cap $cap-color) (place $mps-name "input"))
		; 				 	(= $cap-loaded-status CAP_NOT_LOADED)
		; 				 	(= $base (base UNKNOWN))
		; 				 	)
		; 	:body (
		; 		;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
		; 		;with high urgencey sleeping this task till a good time come and attempt the instruction..
		; 		;Good to know here is that once u have a work peace in the input..U really need it gone with the instruction 
		; 		;in whatever case (even if it was no longer required).  

		; 		(! (step (instruct-mps  machine $mps-name (args operation RETRIEVE_CAP))))
		; 		)
		; 	:documentation "Process a Caped-shelf-base workpiece existing currently at the input, of a CS waiting for its cap tp be retrived.
		; 					if the instruction worked you should have the capless workpiece on the CS output side after processing is done "
		; 	)
		(defop wp-gripper-to-slide
			:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name "slide")) )
			:context ( 		(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
							(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(holding $wp-id)
							) 				;Maybe the slide does not have enough rings
			:body (
				(! (step (insert-slide machine $mps-name)))
				)
			)
		

		(defop wp-gripper-to-gate--DS_Delivery
			:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name $gate) ) )
			:context ( 		(machine $mps-name "DS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						 	(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						 	(~ (= $gate "input"))
						 	(~ (= $gate "output"))
						 	)
			:body (
				(! (printf (FORMAT "WP_input-->Delivery: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

				;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
				;with high urgencey sleeping this task till a good time come and attempt the instruction..
				;Good to know here is that once u have a work peace in the input..U really need it gone with the instruction 
				;in whatever case (even if it was no longer required).  
					;Just let it pass to the insertion step 
				(! (step (drive-to machine $mps-name side "input")))	
				(! (step (instruct-mps  machine $mps-name (args gate $gate))))
				
				(! (step (insert machine $mps-name)))
				)
			:documentation " "
			)


		(defop decide-what-to-instruct--RS
			:invocation ( ! (decide-what-to-intstruct $mps-name $args))
			:context ( 	(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						(|| (goal-inmind (workpiece $id $goal-base (rings $first-ring) $goal-cap (place $goal-mps $feature)))
							(goal-inmind (workpiece $id $goal-base (rings $first-ring $second-ring) $goal-cap (place $goal-mps $feature)))
							(goal-inmind (workpiece $id $goal-base (rings $first-ring $second-ring $third-ring) $goal-cap (place $goal-mps $feature)))
							) 	
						(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(ring-station $mps-name (avilible-colors $avilible-colors) $selected-color $bases-loaded)
						)
						; (or 	(& 	(= $rings (rings NONE)) 						(= $goal-rings (rings $ring-to-mount)) )
						; 		(& 	(= $rings (rings $first-ring)) 					(= $goal-rings (rings $first-ring $ring-to-mount)) )
						; 		(& 	(= $rings (rings $first-ring $second-ring)) 	(= $goal-rings (rings $first-ring $second-ring $ring-to-mount)) ) )
						;(= $selected-color none)
			:body(
				(if (? (= $first-ring NONE))
					(! (printf "DECIDE WHAT TO INTSRUCT: goal-does not have rings..either wrong call or goal" ))
					(fail)
					)

				(if (? (= $rings (rings none)))
					(! (= $ring-to-mount $first-ring))
					else 
					(if (? (= $rings (rings $first-ring)))
						(! (= $ring-to-mount $second-ring))
						else
						(if (? (= $rings (rings $first-ring $second-ring)))
							(! (= $ring-to-mount $third-ring))
							)					
						)
					)

				(? (~ (= null $ring-to-mount)))
				(? (MEMQ $ring-to-mount $avilible-colors))
				(? (ring $ring-to-mount $required-bases))
				(? (>= $bases-loaded $required-bases))
						
				(! (= $args (args ring_color $ring-to-mount))) 
			)
		)

	)