;---------------------------------------------------------------------------
;  workpiece-operations.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri FEB 6 17:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(


	; (defop CHECK-READY?
	; 	:invocation( ! (is-ready? (NEED $resource AT $place FOR $result CONSTRAINTS $constraints) $ready-in )))
	; 	:context ()
	; 	:body(
	; 		;ARE CONSRAINTS SATISFIED?
	; 		;No-> THEN NOT-READY

	; 		;YES->
	; 		;HOW MANY MAIPULATION STEPS TP GET RESOURCE AVILBLE

	; 		)
	; 	:effects()
	; )


	
	; (defop wp--at-output
	; 	:invocation ( ! (workpiece $id $base $rings $cap (place $mps-name "output")))
	; 	:context	( 	(machine $mps-name $type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
	; 					(agent-name $agent) )
	; 	:body (

	; 		(! (printf (Format "--Achieving Workpiece OUTPUT  at %s \n" $mps-name )))
	; 		; Get a free agent and assume its called $selected-robot..maybe even one that has this thing booked somehow
	; 		; Or even at this level mayb already assume u know which agent u need to have working on this shit so just go for the flow of this
	; 		(=> (achieve-workpiece $agent (workpiece $id $base $rings $cap (place $mps-name "output")) STARTED))
	; 		;maybe wait a bit to allow sending
			
	; 		(if (? (= $type "BS"))
	; 			(? (= $base (base $base-color) ))
	; 			(if (! (step (instruct-mps machine $mps-name (args side OUTPUT color $base-color) )))
	; 				(^ (workpiece @id $base $rings $cap (place $mps-name "output")))
	; 				(=> (achieve-workpiece $agent (workpiece (val @id) $base $rings $cap (place $mps-name "output")) SUCCEEDED))
	; 				GOTO fin
	; 				))

	; 		(if (? (= $type "CS"))
	; 			; (! (= $precond_list (. workpiece .)))
	; 			;Find out what is the CAP operation and check the preconds
	; 			(if (? (& 	(cap-station $mps-name @cap-color CAP_NOT_LOADED @caps-on-shelf)
	; 						(= $cap 	(cap NONE))
	; 						(= $base 	(base UNKNOWN))
	; 						(= $rings 	(rings NONE))))
	; 				(! (= $current-cap (val @cap-color)))
	; 				(! (printf (Format "--Achieving Workpiece Retrieving Cap \n")))
	; 				GOTO  Achieve_CAP_STATION_Workpiece
	; 				)

	; 			(if (? (& 	(cap-station $mps-name @cap-color CAP_LOADED @caps-on-shelf)
	; 						(= $cap 	(cap @cap-color))
	; 						(~ (= $cap 	(cap none)))
	; 						))

	; 				(! (printf (Format "--Achieving Workpiece MOunting Cap \n")))
	; 				(! (= $current-cap NONE))
	; 				GOTO  Achieve_CAP_STATION_Workpiece
	; 				)
	; 			)

	; 		(if (?  (= $type "RS"))
	; 			; (! (= $precond_list (. workpiece .)))
	; 			;Find out which Ring to mount and check the preconds	
	; 			(if (? (= $rings (rings NONE)))
	; 				; Do nothing. Wrong workpiece description
	; 				else 
	; 				(if (? (= $rings (rings @ring-to-mount)))
	; 					(! (= $current-rings (rings NONE)))
	; 					(! (= $ring-to-mount (val @ring-to-mount)))
	; 					else
	; 					(if (? (= $rings (rings @first-ring @ring-to-mount)))
	; 						(! (= $current-rings (rings (val @first-ring))))
	; 						(! (= $ring-to-mount (val @ring-to-mount)))
	; 						else
	; 						(if (? (= $rings (rings @first-ring @second-ring @ring-to-mount)))
	; 							(! (= $current-rings (rings (val @first-ring) (val @second-ring))))
	; 							(! (= $ring-to-mount (val @ring-to-mount)))
	; 							)
	; 						)
	; 					)
	; 				)
	; 			(if(? (~ (BOUNDP $ring-to-mount)))
	; 				(! (printf (FORMAT "Achieving-Output: There is no ring to mount in the goal \n"  )))
	; 				GOTO FAIL 
	; 				)

	; 			(if (? (& 	(ring-station $mps-name (avilible-colors $avilible-colors) $select-ring-color $bases-loaded)
	; 						(MEMQ $ring-to-mount $avilible-colors)
	; 						(ring $ring-to-mount $required-bases)
	; 						(>= $bases-loaded $required-bases)
	; 						(workpiece $id $base $curent-rings $cap (place $name $freature) 
	; 						)))
	; 				(! (printf (FORMAT "Achieving-Output: Will Start Achieving \n"  )))
	; 				GOTO  Achieve_RING_STATION_Workpiece
	; 				)
	; 			)

	; 		GOTO FAIL

	; 		LABEL Achieve_CAP_STATION_Workpiece
	; 		(if (! (workpiece $id $base $rings (cap $current-cap) (place "agent" "gripper")))
	; 			(? (workpiece @some-id $base $rings (cap $current-cap) (place "agent" "gripper")))
	; 			(=> (Achieve-workpiece $agent (workpiece (val @some-id) $base $rings (cap $current-cap) (place "agent" "gripper")) SUCCEEDED))
	; 			(! (print "I have it at the gripper"))
	; 			(if (! (workpiece (val @some-id) $base $rings (cap $current-cap) (place $mps-name "input")))
	; 				(! (print "I have it at the INPUT"))
	; 				(=> (Achieve-workpiece $agent (workpiece (val @some-id) $base $rings (cap $current-cap) (place $mps-name "input")) SUCCEEDED))
	; 				;wait for the output or timeout to fail
	; 				(^ (workpiece (val @some-id) $base $rings $cap (place $mps-name "output")))
	; 				(=> (Achieve-workpiece $agent (workpiece  $some-id $base $rings $cap (place $mps-name "output")) SUCCEEDED))
	; 				GOTO fin
	; 				)
	; 			)

	; 		GOTO FAIL

	; 		LABEL  Achieve_RING_STATION_Workpiece
	; 		(if (! (workpiece $id $base $current-rings $cap (place "agent" "gripper")))
	; 			(=> (Achieve-workpiece $agent (workpiece $id $base $current-rings $cap (place "agent" "gripper")) SUCCEEDED))
	; 			; (if (? (~ (master-of REASONING $agent)))
	; 			; 	(^ (Achieve-workpiece $agent (workpiece $id $base $current-rings $cap (place "agent" "gripper")) FINALIZING))
	; 			; 	)
	; 			(! (print "I have it at the gripper"))
	; 			(! (workpiece $id $base $current-rings $cap (place $mps-name "input")))
	; 				(! (print "I have it at the INPUT"))
	; 				; (=> (Achieve-workpiece $agent (workpiece $id $base $current-rings $cap (place $mps-name "input")) SUCCEEDED))
	; 				; (if (? (~ (master-of REASONING $agent)))
	; 				; 	(^ (Achieve-workpiece $agent (workpiece $id $base $current-rings $cap (place $mps-name "input")) FINALIZING))
	; 				; 	)
	; 				; ;wait for the output or timeout to fail
	; 				(^ (workpiece $id $base $rings $cap (place $mps-name "output")))
	; 				(=> (Achieve-workpiece $agent (workpiece $id $base $rings $cap (place $mps-name "output")) SUCCEEDED))
	; 				GOTO fin
				
	; 			)

	; 		LABEL FAIL
	; 		;Only arrives here if it was not successful
	; 		(=> (achieve-workpiece $agent (workpiece $id $base $rings $cap (place $mps-name "output")) FAILED))
	; 		GOTO fin
			
	; 		LABEL fin
	; 		)
	; 	)



	(defop wp-somewhere-to-gripper
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place $agent "gripper")) )
		:context ( (holding none) )
		:body(
			(! (printf (FORMAT "WP_Place-->Gripper: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

			;TODO; IF the id was not bound in the goal that fires this op. It will be matched to ANY workpiece that has the same description...DO I REALLY WANT THIS?!
			;TODO: there is a little problem here that the matching piece does not always exist yet..Meaning sometimes it is still processing 
			;or the machine is down and I will only know the new place when it is ready. ..So for the old place..There is a puck with the same id
			;But not the same description..The condition will fail ..even thought driving there might actually be a good idea
			(if (? (& (workpiece $wp-id $base $rings $cap (place $mps-name $side))
					(||	(= $side "output")
						(& 	(machine $mps-name "BS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(= $side "input")))
						))																				;WP exists in the world (i,e Database)
				(! (printf (FORMAT "WP_Place --> Gripper: Found a peace at %s %s..Going to get it \n"  $mps-name $side)))
				(if (? (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with))
					(! (step (drive-to machine $mps-name side $side))) 									;Common driving STEP

					(if (? (= $mps-type "BS"))
						(if (? 	(~ (machine $bs-name "BS" "READY-AT-OUTPUT" @bs-prepared @bs-zone @bs-pose @bs-loaded-with)))
							(if (? (= $side "input"))
								(! (= $side-as-symbol INPUT))
								else
								(! (= $side-as-symbol OUTPUT))
								)
							(? (= $base (base $base-color)))
							(! (step (instruct-mps 	machine "C-BS" (args side $side-as-symbol color $base-color)) ))
							(^ (workpiece 0 $base $rings $cap (place $bs-name $side)))
							)
						(! (step (get-base 	machine $mps-name side $side assigend-id $wp-id))) 
						(^ (workpiece $wp-id $base $rings $cap (place $agent "gripper"))) 					;Match to return the created id

						GOTO fin
 						)
					(if (? (= $mps-type "RS"))
						(! (step (get-output machine $mps-name)))
						GOTO fin
 						)
					(if (? (= $mps-type "CS"))
						(if (? (& 	(= $base (base UNKNOWN))
									(= $cap (cap $cap-color)) 
									(~ (= $cap-color none))
									))
							(! (step (get-cap machine $mps-name assigned-id $wp-id)))
							GOTO fin
							else
							(! (step (get-output machine $mps-name)))
							GOTO fin
							)
						)
					(if (? (= $mps-type "DS"))
						; (! (step (get-output machine $mps-name)))
						; GOTO fin
  						)
					else
					(! (printf (FORMAT "WP_Place --> Gripper: I think the peace is lost..will just fail \n" )))
					(! (FAILED))
					)
				else
				(! (printf (FORMAT "WP_Place --> Gripper: ;WP Does not exists in the world (i,e Database) \n" )))
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= (cap $cap-color) $cap)
							(~ (= $cap-color NONE))
							))
					(! (printf (FORMAT "WP_Place --> Gripper: ;Its a New Caped Shelf Base, Get one \n" )))
					(? (cap-station $cs-name $cap-color $loaded-status $caps-on-shelf))
					(! (step (drive-to 	machine $cs-name side "input")))
					(! (step (get-cap 	machine $cs-name assigned-id $wp-id)))
					;Match to return the created id
					; (if (? (~ (BOUNDP $wp-id)))
					 	; (? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
						(^ (workpiece $wp-id $base $rings $cap (place $agent "gripper"))) 					;Match to return the created id
						; else 
						; (^ (workpiece $some-id $base $rings $cap (place "agent" "gripper"))) 				;The id was bound ..  but does not have to be true
					 	; (? (workpiece $some-id $base $rings $cap (place "agent" "gripper"))) 				;The id was bound ..  but does not have to be true
						; )
					
					GOTO fin
 					)
				(if (? (&	(= $base (base $base-color)) (~ (= $base-color UNKNOWN))	
							(= $rings (rings none))
							(= $cap (cap none))
							))
					(! (printf (FORMAT "WP_Place --> Gripper: producing a new base \n" )))
					;TODO: match on the base station color..For now just get it from the C-BS, CORRECT THIS SOON
					(! (= $bs-name "C-BS"))
					(! (= $active-side "input"))
					(! (step (drive-to 		machine $bs-name side $active-side)))
					;If there is a base already-at-output, no need to instruct 
					(if (? 	(~ (machine $bs-name "BS" "READY-AT-OUTPUT" @bs-prepared @bs-zone @bs-pose @bs-loaded-with)))
							(! (step (instruct-mps 	machine "C-BS" (args side INPUT color $base-color)) ))
							(^ (workpiece 0 $base $rings $cap (place $bs-name $active-side)));hazardous...find a better way
						)
					(! (step (get-base machine $bs-name side $active-side assigned-id $wp-id)))
					;Match to return the created id
					; (if (? (~ (BOUNDP $wp-id)))
						; (? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
						(^ (workpiece $wp-id $base $rings $cap (place $agent "gripper"))) 					;Match to return the created id
						; else 
						; (^ (workpiece $some-id $base $rings $cap (place "agent" "gripper"))) 				;The id was bound ..  but does not have to be true
					 	; (? (workpiece $some-id $base $rings $cap (place "agent" "gripper"))) 				;The id was bound ..  but does not have to be true
						; )
					GOTO fin
 					)
				)

				(! (printf (FORMAT "WP_Place --> Gripper: Could not handle this peace %s %s %s %s \n"  $wp-id $base $rings $cap )))
				(? (workpiece $wp-id $base $rings $cap (place $agent "gripper"))) 
				(! (FAILED))

				LABEL fin
				;TODO: handle cases that
				;	wp has no or different id but same description and exists somewhere (this could allow me to know what I want but 
				;	not where it is or just that it will exist somewhere still no name)			
			)
		:documentation "Sends the Agent to gripp a workpiece from 'somewhere' if that workpiece exist in the world (ie,matches a WP with
						 the same Id as in the goal, or any similar WP if the id was not bound in the goal_MIGHT CHANGE THAT SOON)
						In case the workpiece is a New base or a New caped-shelf-base and no match found already, Grab a new one"
		)		


	

	(defop wp-gripper-to-input
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name "input")) )
		:context ( 		(workpiece $wp-id $base $rings $cap (place $agent "gripper"))
						(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(holding $wp-id)
						) 				;Maybe the input side has to be empty for that (or make a need for it)
		:setting 		(setting "robot-name" $agent)
		:body (

			(! (printf (FORMAT "WorkpieceOperation: GRIPPER--->INPUT \n ")))

			(if (? 	(= $mps-type "BS"))
				(! (printf (FORMAT "WP_GRIPPER-->INPUT: Why are you trying to insert to a BS ?!?!..Will fail \n ")))
				(! (FAILED))
				)
			(if (? 	(= $mps-type "RS"))
				(! (step (drive-to machine $mps-name side "input")))
				(! (decide-what-to-intstruct $mps-name $args));; I want to have it as a call to be more fixable how it is done or based on what () from a subgoal, or machine handling 
				(! (print $args ))
				(! (step (instruct-mps machine $mps-name $args)))
				(! (step (insert machine $mps-name)))
				GOTO succeed
				)
			(if (? 	(= $mps-type "DS"))
				GOTO succeed
 				)
			(if (? 	(= $mps-type "CS"))
				(? (cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf))
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= $cap (cap $cap-color))
							))

						(if (? (= $cap-loaded-status CAP_NOT_LOADED))
							(! (step (instruct-mps  machine $mps-name (args operation RETRIEVE_CAP))))
							(! (step (insert-atmps machine $mps-name)))
							GOTO succeed
 							else
							(! (printf (FORMAT "WP_ GRIPPER-->INPUT: Cap Is already loaded !!!!!!!..will fail\n" )))
							; TODO: Move to a step Release puck for consistency
							(=> (holding none))
							(=> (Achieve-workpiece $agent
										(workpiece $wp-id $base 
														$rings 
														$cap 
														(place "LOST" "LOST"))
										SUCCEEDED))
							(! (FAILED))
							)

						else
						
						(if (? (& 	(~ (= $base (base UNKNOWN)))
									(= $cap (cap none))
									(= $cap-loaded-status CAP_LOADED)
									))
							(! (step (drive-to machine $mps-name side "input")))
							(! (step (instruct-mps  machine $mps-name (args operation MOUNT_CAP))))
							(! (step (insert machine $mps-name)))
							GOTO succeed
		 					;Normal workpiece,just let it pass to the insertion step
							else
							(! (printf (FORMAT " WP_GRIPPER-->INPUT: Something is not right!. CAP_NOT_LOADED or Wrong Puck!..will fail \n")))
							(! (FAILED))
							)
						)
				)
			;Default insertion Step
			; (! (step (drive-to machine $mps-name side "input")))
			; (! (step (insert machine $mps-name)))
			LABEL succeed
			)
		) 


		; (defop execute-wp-input-to-output--CS_MOUNT_CAP
		; 	:invocation ( ! (workpiece $wp-id $base $rings (cap $cap-color) (place $mps-name "output") ) )
		; 	:context ( 		(machine $mps-name "CS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
		; 					(cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf)
		; 				 	(workpiece $wp-id $base $rings (cap none) (place $mps-name "input"))
		; 				 	(= $cap-loaded-status CAP_LOADED)
		; 				 	(~ (= $base (base UNKNOWN)))
		; 				 	)
		; 	:body (
		; 		; (if (? (= $cap-loaded-status CAP_NOT_LOADED))
		; 		; 	(! (printf (FORMAT "NEED input-output--CS: Trying to insert WP and no CAP ....will fail\n" $mps-name )))
		; 		; 	;may be here u need to make sure that there is a cap at the Cap station of get one urgently.
		; 		; 	;but it the workpreace is already at the input ..it is kinda too late for that man..That means u need to remove it
		; 		; 	;to recover from this..Maybe that is a good thing if shit happens...But this is the sort of shit that should not happen
		; 		; 	;Would only happen if Agent THOUGHT that the cap was loaded but its not...other wise such action should not even be avilabe
		; 		; 	;big shit case ,,should not happen..
		; 		; 	(fail)
		; 		; 	)

		; 		;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
		; 		;with high urgencey sleeping this task till a good time come and attempt the instruction..
		; 		;Good to know here is that once u have a work peace in the input..U really need it gone with a MOUNT_CAP instruction 
		; 		;in whatever case (even if it was no longer required).  

		; 		(! (step (instruct-mps  machine $mps-name (args operation MOUNT_CAP))))
		; 		)
		; 	:documentation "Process a Capless workpiece existing currently at the input of a CS, by instructing it with a MOUNT_CAP.
		; 					if the instruction worked you should have the same workpiece with a cap_mounted on the output side after 
		; 					machine is done processing.
		; 					The goal fails if the CAP is not LOADED. Cap loading has to be insured before the goal call.Actually even
		; 					before the the peace is at the input. Its already too late if peace is at input and there is no cap "
		; 	)

		; (defop execute-wp-input-to-output--CS_RETRIVE_CAP
		; 	:invocation ( ! (workpiece $wp-id (base UNKNOWN) (rings none) (cap none) (place $mps-name "output") ) )
		; 	:context ( 		(machine $mps-name "CS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
		; 					(cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf)
		; 				 	(workpiece $wp-id (base UNKNOWN) $rings (cap $cap-color) (place $mps-name "input"))
		; 				 	(= $cap-loaded-status CAP_NOT_LOADED)
		; 				 	(= $base (base UNKNOWN))
		; 				 	)
		; 	:body (
		; 		;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
		; 		;with high urgencey sleeping this task till a good time come and attempt the instruction..
		; 		;Good to know here is that once u have a work peace in the input..U really need it gone with the instruction 
		; 		;in whatever case (even if it was no longer required).  

		; 		(! (step (instruct-mps  machine $mps-name (args operation RETRIEVE_CAP))))
		; 		)
		; 	:documentation "Process a Caped-shelf-base workpiece existing currently at the input, of a CS waiting for its cap tp be retrived.
		; 					if the instruction worked you should have the capless workpiece on the CS output side after processing is done "
		; 	)


		(defop wp-gripper-to-slide
			:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name "slide")) )
			:context ( 		(workpiece $wp-id $base $rings $cap (place $agent "gripper")); TODO:robot location is at the mps
							(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
							(holding $wp-id)
							) 				;Maybe the slide does not have enough rings
			:body (
				(! (step (drive-to machine $mps-name side "input")))
				(! (step (insert-slide machine $mps-name)))
				)
			)


		(defop wp-gripper-to-gate--DS_Delivery
			:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name $gate) ) )
			:context ( 		(machine $mps-name "DS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						 	(workpiece $wp-id $base $rings $cap (place $agent "gripper"))
						 	(~ (= $gate "input"))
						 	(~ (= $gate "output"))
						 	(~ (= $gate "slide"))
						 	(~ (= $gate "gripper"))
						 	)
			:body (
				(! (printf (FORMAT "WP_input-->Delivery: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

				;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
				;with high urgencey sleeping this task till a good time come and attempt the instruction..
				;Good to know here is that once u have a work peace in the input..U really need it gone with the instruction 
				;in whatever case (even if it was no longer required).  
					;Just let it pass to the insertion step 
				(! (step (drive-to machine $mps-name side "input")))
				(! (step (instruct-mps  machine $mps-name (args gate $gate))))
				(! (step (insert machine $mps-name)))
				)
			:documentation " "
			)




		(defop decide-what-to-instruct--RS
			:invocation ( ! (decide-what-to-intstruct $mps-name $args))
			:context ( 	(workpiece $wp-id $base $rings $cap (place $agent "gripper"))
						(|| (achieve-workpiece $mps-name (workpiece $id $goal-base (rings $first-ring) $goal-cap (place $mps-name $feature)) STARTED)
							(achieve-workpiece $mps-name (workpiece $id $goal-base (rings $first-ring $second-ring) $goal-cap (place $mps-name $feature)) STARTED)
							(achieve-workpiece $mps-name (workpiece $id $goal-base (rings $first-ring $second-ring $third-ring) $goal-cap (place $mps-name $feature)) STARTED)
							) 	
						(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(ring-station $mps-name (avilible-colors $avilible-colors) $selected-color $bases-loaded)
						(agent-name $agent)
						)
						; (or 	(& 	(= $rings (rings NONE)) 						(= $goal-rings (rings $ring-to-mount)) )
						; 		(& 	(= $rings (rings $first-ring)) 					(= $goal-rings (rings $first-ring $ring-to-mount)) )
						; 		(& 	(= $rings (rings $first-ring $second-ring)) 	(= $goal-rings (rings $first-ring $second-ring $ring-to-mount)) ) )
						;(= $selected-color none)
			:body(
				(! (printf (FORMAT "DECIDE WHAT TO INTSRUCT: ") ))

				(if (? (= $first-ring NONE))
					(! (printf "DECIDE WHAT TO INTSRUCT: goal-does not have rings..either wrong call or goal" ))
					(fail)
					)

				(if (? (= $rings (rings none)))
					(! (= $ring-to-mount $first-ring))
					else 
					(if (? (= $rings (rings $first-ring)))
						(! (= $ring-to-mount $second-ring))
						else
						(if (? (= $rings (rings $first-ring $second-ring)))
							(! (= $ring-to-mount $third-ring))
							)					
						)
					)
				(if (? (~ (BOUNDP $ring-to-mount)))
					(! (printf (FORMAT "DECIDE WHAT TO INTSRUCT: No Ring to mount could be concluded" )))
					)

				(? (~ (= null $ring-to-mount)))
				(? (MEMQ $ring-to-mount $avilible-colors))
				(? (ring $ring-to-mount $required-bases))
				(? (>= $bases-loaded $required-bases))
						
				(! (= $args (args ring_color $ring-to-mount))) 
			)
		)


	)