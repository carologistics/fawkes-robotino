;---------------------------------------------------------------------------
;  workpiece-operations.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri FEB 6 17:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(


	; (defop CHECK-READY?
	; 	:invocation( ! (is-ready? (NEED $resource AT $place FOR $result CONSTRAINTS $constraints) $ready-in )))
	; 	:context ()
	; 	:body(
	; 		;ARE CONSRAINTS SATISFIED?
	; 		;No-> THEN NOT-READY

	; 		;YES->
	; 		;HOW MANY MAIPULATION STEPS TP GET RESOURCE AVILBLE

	; 		)
	; 	:effects()
	; )


	(defop wp-somewhere-to-gripper
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place "agent" "gripper")) )
		:context ( (holding none) )
		:body(
			(! (printf (FORMAT "WP_Place-->Gripper: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

			;TODO; IF the id was not bound in the goal that fires this op. It will be matched to ANY workpiece that has the same discription...DO I REALLY WANT THIS?!
			;TODO: there is a little problem here that the matching piece does not always exist yet..Meaning sometimes it is still processing 
			;or the machine is down and I will only know the new place when it is ready. ..So for the old place..There is a puck with the same id
			;But not the same discription..The condition will fail ..even thought driving there might actually be a good idea
			(if (? (& (workpiece $wp-id $base $rings $cap (place $mps-name $side))
						(~ (= $side "slide"))
						))																				;WP exists in the world (i,e Database)
				(! (printf (FORMAT "WP_Place --> Gripper: Found a peace at %s %s..Going to get it \n"  $mps-name $side)))
				(if (? (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with))
					(! (step (drive-to machine $mps-name side $side))) 									;Common driving STEP
					(if (? (= $mps-type "BS"))
						(! (step (get-base 	machine $mps-name side $side))) 
						(succeed)
 						)
					(if (? (= $mps-type "RS"))
						(! (step (get-output machine $mps-name)))
						(succeed)
 						)
					(if (? (= $mps-type "CS"))
						; (if (? (& 	(= $base (base UNKNOWN))
						; 			(= $cap (cap $cap-color)) 
						; 			(~ (= $cap-color none))
						; 			))
						; 	(! (step (get-cap machine $mps-name)))	
						; 	else
							(! (step (get-output machine $mps-name)))
							(succeed)
						;	)
						)
					(if (? (= $mps-type "DS"))
						(! (step (get-output machine $mps-name)))
						(succeed)
  						)
					else
					(! (printf (FORMAT "WP_Place --> Gripper: I think the peace is lost..will just fail \n" )))
					(fail)
					)
				else																					;WP Does not exists in the world (i,e Database)
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= $cap (cap $cap-color)) (~ (= $cap-color none))
							))																			;Its a New Caped Shelf Base, Create it
					(? (cap-station $cs-name $cap-color $loaded-status $caps-on-shelf))
					(! (step (drive-to 	machine $cs-name side "input")))
					(! (step (get-cap 	machine $cs-name)))
					(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
					(succeed)
 					)
				(if (? (& 	(= $base (base $base-color)) (~ (= $base-color UNKNOWN))	
							(= $rings (rings none))
							(= $cap (cap none))
							))																			;Its a New Base,Create it
					;TODO: match on the base station color..For now just get it from the C-BS, CORRECT THIS SOON
					(! (step (drive-to 		machine "C-BS" side "input")))
					(! (step (instruct-mps 	machine "C-BS" (args side INPUT color $base-color)) ))
					(^ (workpiece $wp-id $base $rings $cap (place "C-BS" "input")));hazardous...find a better way
					(! (step (get-base machine $mps-name side "input")))
					(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 					;Match to return the created id
					(succeed)
 					)
				)

				(! (printf (FORMAT "WP_Place --> Gripper: Could not handle this peace %s %s %s %s \n"  $wp-id $base $rings $cap )))
				(? (workpiece $wp-id $base $rings $cap (place "agent" "gripper"))) 
				(fail)
				;TODO: handle cases that
				;	wp has no or different id but same description and exists somewhere (this could allow me to know what I want but 
				;	not where it is or just that it will exist somewhere still no name)			
			)
		:documentation "Sends the Agent to gripp a workpiece from 'somewhere' if that workpiece exist in the world (ie,matches a WP with
						 the same Id as in the goal, or any similar WP if the id was not bound in the goal_MIGHT CHANGE THAT SOON)
						In case the workpiece is a New base or a New caped-shelf-base and no match found already, Grab a new one"
		)		


	

	(defop wp-gripper-to-input
		:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name "input")) )
		:context ( 		(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(holding $wp-id)
						) 				;Maybe the input side has to be empty for that (or make a need for it)
		:body (

			(if (? 	(= $mps-type "BS"))
				(! (printf (FORMAT "WP_GRIPPER-->INPUT: Why are you trying to insert to a BS ?!?!..Will fail \n ")))
				(fail)
				)
			(if (? 	(= $mps-type "RS"))
				(! (step (drive-to machine $mps-name side "input")))
				(! (decide-what-to-intstruct $mps-name $args));; I want to have it as a call to be more fixable how it is done or based on what () from a subgoal, or machine handling 
				(! (step (instruct-mps machine $mps-name $args)))
				(! (step (insert machine $mps-name)))
				)
			(if (? 	(= $mps-type "DS"))
			
				(succeed)
 				)
			(if (? 	(= $mps-type "CS"))
				(? (cap-station $mps-name $cap-color $cap-loaded-status $caps-on-shelf))
				(if (? (& 	(= $base (base UNKNOWN)) 
							(= $rings (rings none)) 
							(= $cap (cap $cap-color))
							))
						(if (? (= $cap-loaded-status CAP_NOT_LOADED))
							(! (step (instruct-mps  machine $mps-name (args operation RETRIEVE_CAP))))
							(! (step (insert-atmps machine $mps-name)))
							(succeed)
 							else
							(! (printf (FORMAT "WP_ GRIPPER-->INPUT: Cap Is already loaded !!!!!!!..will fail\n" )))
							; TODO: Move to a step Release puck for consistency
							(=> (holding none))
							(=> (workpiece $wp-id $base 
												$rings 
												$cap 
												(place LOST LOST)))
							(fail)
							)
						)
				(if (? (& 	(~ (= $base (base UNKNOWN))) 
							(= $cap (cap none)) 
							(= $cap-loaded-status CAP_LOADED) 
							))

					(! (step (drive-to machine $mps-name side "input")))
					(! (step (instruct-mps  machine $mps-name (args operation MOUNT_CAP))))
					(! (step (insert machine $mps-name)))
					(succeed)
 					;Normal workpiece,just let it pass to the insertion step 
					else
					(! (printf (FORMAT " WP_GRIPPER-->INPUT: Something is not right!. CAP_NOT_LOADED or Wrong Puck!..will fail \n")))
					(fail)
					)
				)
			;Default insertion Step
			(! (step (drive-to machine $mps-name side "input")))
			(! (step (insert machine $mps-name)))
			)
		) 


		(defop wp-input-to-gate--DS_Delivery
			:invocation ( ! (workpiece $wp-id $base $rings $cap (place $mps-name $gate) ) )
			:context ( 		(machine $mps-name "DS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						 	(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						 	(~ (= $gate "input"))
						 	(~ (= $gate "output"))
						 	)
			:body (
				(! (printf (FORMAT "WP_input-->Delivery: workpiece %s %s %s %s \n"  $wp-id $base $rings $cap)))

				;May from here I would need to handle if CS was not cleared (ie, READY_AT_OUTPUT) and issue a cleaning task right away 
				;with high urgencey sleeping this task till a good time come and attempt the instruction..
				;Good to know here is that once u have a work peace in the input..U really need it gone with the instruction 
				;in whatever case (even if it was no longer required).  
					;Just let it pass to the insertion step 
				(! (step (drive-to machine $mps-name side "input")))	
				(! (step (instruct-mps  machine $mps-name (args gate $gate))))
				
				(! (step (insert machine $mps-name)))
				)
			:documentation " "
			)


		(defop decide-what-to-instruct--RS
			:invocation ( ! (decide-what-to-intstruct $mps-name $args))
			:context ( 	(workpiece $wp-id $base $rings $cap (place "agent" "gripper"))
						(goal-inmind (workpiece $id $goal-base $goal-rings $goal-cap (place $goal-mps $goal-feature))) 	
						(machine $mps-name "RS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(ring-station $mps-name (avilible-colors $avilible-colors) $selected-color $bases-loaded)
						(or 	(& 	(= $rings (rings NONE)) 						(= $goal-rings (rings $ring-to-mount)) )
								(& 	(= $rings (rings $first-ring)) 					(= $goal-rings (rings $first-ring $ring-to-mount)) )
								(& 	(= $rings (rings $first-ring $second-ring)) 	(= $goal-rings (rings $first-ring $second-ring $ring-to-mount)) ) )
						(MEMQ $ring-to-mount $avilible-colors)
						(ring $ring-to-mount $required-bases)
						(= $selected-color none)
						(= $bases-loaded $required-bases)
						)
			:body(


				(! (= $args (args ring_color $ring-to-mount))) 
			)
		)

	)