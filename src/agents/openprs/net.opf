;---------------------------------------------------------------------------
;  net.opf - Network OPs for LLSF2014 agent
;
;  Created: Tue Sep 09 11:47:58 2014
;  Copyright  2014  Tim Niemueller [www.niemueller.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(

(defop net-enable-team-private
  :invocation (protobuf-msg "llsf_msgs.GameState" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                              $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)
  :setting (& (setting "peer-private-key" $crypto-key) (setting "peer-private-cipher" $crypto-cipher)
	      (setting "peer-address" $peer-addr)
  	      (setting "peer-cyan-send-port" $cyan-sendp) (setting "peer-cyan-recv-port" $cyan-recvp)
  	      (setting "peer-magenta-send-port" $magenta-sendp) (setting "peer-magenta-recv-port" $magenta-recvp))
  :context (& (~ (peer-id private $private-id))
 	      (setting "team-name" $team-name)
              (|| (equal $team-name (pb-field-value $msg "team_cyan"))
	          (equal $team-name (pb-field-value $msg "team_magenta"))))
  :body (
    (if (? (equal $team-name (pb-field-value $msg "team_cyan")))
      (! (print "Setting up private channel as team CYAN"))
      (! (pb-peer-create-local-crypto $peer-addr $cyan-sendp $cyan-recvp $crypto-key $crypto-cipher @peer-id))
      (! (= @team-color CYAN))
     else
      (! (print "Setting up private channel as team MAGENTA"))
      (! (pb-peer-create-local-crypto $peer-addr $magenta-sendp $magenta-recvp $crypto-key $crypto-cipher @peer-id))
      (! (= @team-color MAGENTA))
    )
  )
  :effects ((=> (peer-id private @peer-id)) (=> (team-color @team-color)))
  :documentation "Setup private team channel.
    Once the (configured) team name has been set in the refbox and is announced
    we know which team color we have. Note this and setup the appropriate (encrypted)
    team channel. Afterwards message can be sent privately among robots and to the
    refbox."
)

(defop net-send-BeaconSignal
  :invocation (time $sec $usec)
  :context (? (& (peer-id private $peer-id)
 	         (team-color $team-color)
	         (timer "beacon" $last-sec $last-usec $seq)
	         (setting "beacon-interval" $beacon-interval)
	         (timeout $sec $usec $last-sec $last-usec $beacon-interval)))
  :setting (& (setting "team-name" $team-name)
  	      (setting "robot-name" $robot-name) (setting "robot-number" $robot-number))
  :body (
    (! (start-critical-section))
    (! (= @next-seq (+ $seq 1)))
    (=> (timer "beacon" $sec $usec @next-seq))
    (! (end-critical-section))
    (! (= @beacon (pb-create "llsf_msgs.BeaconSignal")))
    (! (= @beacon-time (pb-field-value @beacon "time")))
    (! (pb-set-field @beacon-time "sec" $sec))
    (! (pb-set-field @beacon-time "nsec" (* $usec 1000)))
    (! (pb-set-field @beacon "time" @beacon-time)) ; destroys @beacon-time!
    (! (pb-set-field @beacon "seq" @next-seq))
    (! (pb-set-field @beacon "team_name" $team-name))
    (! (pb-set-field @beacon "peer_name" $robot-name))
    (! (pb-set-field @beacon "team_color" $team-color))
    (! (pb-set-field @beacon "number" $robot-number))
    (! (pb-set-field @beacon "number" $robot-number))
    (! (pb-broadcast $peer-id @beacon))
    (! (pb-destroy @beacon))
  )
  :documentation "Periodically send beacon signals.
    Beacon signals are required for the refbox to recognize a robot. After
    the private team channel has been setup periodically send the message."
)

(defop net-recv-BeaconSignal
  :invocation (protobuf-msg "llsf_msgs.BeaconSignal" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                              $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)
  
  :context ()
  :setting (& (setting "team-name" $team-name)
            (setting "robot-name" $robot-name) (setting "robot-number" $robot-number))
  :body (
    (! (= @team-name (pb-field-value $msg "team_name")))
    (! (= @beacon-time (pb-field-value $msg "time")))
    (! (= @sec (pb-field-value @beacon-time "sec")))
    (! (= @nsec (pb-field-value @beacon-time "nsec")))
    (! (= @robot-name (pb-field-value $msg "peer_name")))
    (! (= @robot-number (pb-field-value $msg "number")))
    (! (= @team-color (pb-field-value $msg "team_color")))
    ; TODO: ADD LOCATION INFORMATION
    (=> (heart-beat @robot-name @robot-number @team-name @team-color @sec @nsec))
    
    (? (time $sec $usec))
    (! (start-critical-section))
    (=> (timer (val @robot-name) $sec $usec 0))
    (! (end-critical-section))
  )
  :documentation "Periodically receive and process beacon signals.
    Beacon signals are broadcasted by all robots and refbox to recognize eachother. ."
)


 (defop net-recv-GameState
    :invocation (protobuf-msg "llsf_msgs.GameState" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                                $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)  
    :context ((game-phase $old-phase) 
              (game-state $old-state))         
    :setting (& (setting "team-name" $team-name)
                (setting "robot-name" $robot-name) 
                (setting "robot-number" $robot-number))
    :body(
      (! (= $phase (pb-field-value $msg "phase")))
      (! (= $state (pb-field-value $msg "state")))
      (! (= $sim-time (pb-field-value $msg "game_time")))
      (! (= $sec-time (pb-field-value $sim-time "sec")))
      
      (if (? (~(= $old-phase $phase)))
        (! (printf (FORMAT "switching to different phase %s \n" $phase)))
        (=> (game-phase $phase))
      )
      (if (? (~(= $old-state $state)))
        (! (printf (FORMAT "Game state %s \n" $state)))
        (=> (game-state $state))
      )
  )
  :effects((=> (game-time $sec-time)))
 :documentation
    "replaces game state and phase from the database with the new ones."
  )


(defop net-recv-MachineInfo 
    :invocation (protobuf-msg "llsf_msgs.MachineInfo" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                                $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)
    :context((game-phase $phase)
            (team-color $team-color))
    :setting (& (setting "team-name" $team-name)
                (setting "robot-name" $robot-name) 
                (setting "robot-number" $robot-number))
    :body(
      (? (= $team-color (pb-field-value $msg "team_color")))
      (! (= @machines  (pb-field-list $msg "machines")))
      
      (while (? (~ (null @machines)))
        (! (= @machine (car @machines)))
        (! (= @machines (cdr @machines)))
        (! (= @machine-name (pb-field-value @machine "name")))
        (! (= @machine-type (pb-field-value @machine "type")))
        (! (= @machine-state (pb-field-value @machine "state")))
        (! (= @machine-prepared (pb-field-value @machine "prepared")))
        (! (= @machine-zone (pb-field-value @machine "zone")))
        (! (= @machine-pose (pb-field-value @machine "pose")))   
        (! (= @machine-loaded-with (pb-field-value @machine "loaded_with")))
        (! (= @machine-ringcolors (pb-field-list @machine "ring_colors")))   

        ;Update Machine Information
        (if (? (machine (val @machine-name) @m-type @m-state @m-prepared @m-zone @m-pose @m-loaded-with))
          (if (? (||  (~ (= (val @m-state) @machine-state)) 
                      (~ (= (val @m-prepared) @machine-prepared))
                      (~ (= (val @m-loaded-with) @machine-loaded-with)) 
                       ))
                      ;(~ (= (val @m-pose) @machine-pose))
            (=> (machine @machine-name @machine-type @machine-state @machine-prepared @machine-zone @machine-pose @machine-loaded-with)) 
            (! (printf (FORMAT "UPDATE Machine %s is %s %s %s  \n" (val @machine-name) (val @machine-state) (val @machine-prepared) (val @machine-loaded-with) )))

            )
          else  
            (=> (machine @machine-name @machine-type @machine-state @machine-prepared @machine-zone @machine-pose @machine-loaded-with)) 
            (! (printf (FORMAT "adding MachineInfo %s \n" (val @machine-name))))
          )

        ;Add Information about the ring-stations 
        (if (? (= "RS" @machine-type))
           (if (? (ring-station (val @machine-name) (avilible-colors (val @machine-ringcolors)) @selected-color @bases-loaded ) )
                ;Do nothing. Its there already
            else
                (=> (ring-station @machine-name (avilible-colors @machine-ringcolors) NONE 0 ))
                (! (print "added the RingStation"))
            )
          )

        )
      )
    :effects()
    :documentation
      "Process MachineInfo messages
      TODO: - remove the loaded-with and pose info after knowing what is it for
            - changes of team_color is also propagated
            - maybe put the zone information in a separate fact like clips (zone-exp)
            - maybe find a shorter way to check the conditions for the machine
      "
  )


(defop net-recv-OrderInfo
      :invocation (protobuf-msg "llsf_msgs.OrderInfo" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                                $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)
      :context ((team-color $team-color))
      :body(
        (! (= @orders (pb-field-list $msg "orders")))

        (while (? (~ (null @orders)))
          (! (= @order (car @orders)))
          (! (= @orders (cdr @orders)))
          (! (= @id (pb-field-value @order "id")))
          (! (= @complexity (pb-field-value @order "complexity")))
          (! (= @base-color (pb-field-value @order "base_color")))
          (! (= @ring-colors (pb-field-list @order "ring_colors")))
          (! (= @cap-color (pb-field-value @order "cap_color")))
          (! (= @quantity-requested (pb-field-value @order "quantity_requested")))
          (! (= @quantity-delivered-cyan (pb-field-value @order "quantity_delivered_cyan")))
          (! (= @quantity-delivered-magenta (pb-field-value @order "quantity_delivered_magenta")))
          (! (= @delivery-period-begin (pb-field-value @order "delivery_period_begin")))
          (! (= @delivery-period-end (pb-field-value @order "delivery_period_end")))
          (! (= @delivery-gate (pb-field-value @order "delivery_gate")))  
          
          ; (if (? (~ (order (val @id) $t-complexity $t-base-color $t-ring-colors $t-cap-color $t-quantity-requested $t-quantity-delivered $t-delivery-period-begin $t-delivery-period-end $t-delivery-gate)) )
          ;   (if (? (= $team-color CYAN))
          ;     (! (= @quantity-delivered @quantity_delivered_cyan ))
          ;     else
          ;     (! (= @quantity-delivered @quantity_delivered_magenta )) 
          ;     )
          ;   (! (print "Adding Order"))
          ;   (=> (order @id @complexity @base-color @ring-colors @cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)) 
          ;   )

          (if (? (= $team-color CYAN))
            (! (= @quantity-delivered @quantity-delivered-cyan ))
            else
            (! (= @quantity-delivered @quantity-delivered-magenta )) 
          )            

          (if (? (& (order (val @id) @t-complexity @t-base-color @t-ring-colors @t-cap-color @t-quantity-requested @t-quantity-delivered @t-delivery-period-begin @t-delivery-period-end @t-delivery-gate)
                    (= (val @t-quantity-delivered) (val @quantity-delivered))
                    ))
              ;The Order already exists and delivered was not changed
              ;Quite the Op 
              else
              (! (print "Adding Order"))
              (=> (order (val @id) @complexity @base-color @ring-colors @cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)) 
            )
          )
        )
      :effects()
      :documentation "Process the OrderInfo messages"
  )


(defop net-recv-RingInfo 
  :invocation(protobuf-msg "llsf_msgs.RingInfo" $comp-id $msg-type $rcvd-via $rcvd-at-sec $rcvd-at-usec
                                $rcvd-from-host $rcvd-from-port $client-type $client-id $msg)
  :body( 
    (! (= @rings (pb-field-list $msg "rings")))

    (while (? (~ (null @rings)))
      (! (= @ring (car @rings)))
      (! (= @rings (cdr @rings)))
      (! (= @ring-color (pb-field-value @ring "ring_color")))
      (if (? (~ (ring (val @ring-color) @raw-material)))
        (! (= @raw-material (pb-field-value @ring "raw_material")))
        (=> (ring @ring-color @raw-material))
        (! (print "added RingInfo"))
        )
      )

    )
  :effects()
  :documentation "Process the RingInfo message that contains information about how many bases does a ring colour needs"

  )






)
