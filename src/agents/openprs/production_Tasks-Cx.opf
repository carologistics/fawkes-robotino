;---------------------------------------------------------------------------
;  production_Tasks-Cx.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Mar 10 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------


(
	
;============================================================Tasks===============================================================
;	Wait on and check the precond,
;	Find a free robot
; 	Excute the given procedure given the name of the goal
;	If failed Release the agent

	(defop Task-Achiever-and-monitor
		:invocation (|| (! (Achieve-Task $task-name $agent (precond $precond)))
						(! (Achieve-Task $task-name $agent (precond $precond) $goal-inmind))
						)
					; (goal-inmind (workpiece $g-id (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
		:context( 	(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			;Sleep Wait for Preconditions
			; (^ (val $precond))

			;Select An Agent
			; (if (? (~ (BOUNDP $agent)))
			; 	(! (select-appropriate-agent $agent $task-name))
			; 	)
						
			
			(if (? (BOUNDP $goal-inmind))
				(! (= $task-expression (build-term-comp-from-atom-llist (val $task-name) (. $agent $goal-inmind .)) ))
				else
				(! (= $task-expression (build-term-comp-from-atom-llist (val $task-name) (. $agent .)) ))
				)

			(if (! (val $task-expression))
				(! (printf (FORMAT "TASK MONITOR:: %s %s SUCCEEDED \n " $task-name $agent)))
				else
				(! (printf (FORMAT "TASK MONITOR:: %s %s FAILD  \n" $task-name $agent)))
				)

			;Rlease the agent robot if it was selected
			(if (? (BOUNDP $agent))
			(=> (agent-achieving (val $agent) RELEASING_RESOURCES))
			)
			
			)
		)

	(defop Agent--Release-When-Idle
		:invocation ( agent-achieving $agent RELEASING_RESOURCES)
		:context ()
		:body(
			; ;Release All locks
			; (while (? (lock @some-type $agent (val @resource) @some-priority))
			; 		(=> (lock RELEASE $agent (val @resource) @some-priority))
			; 		)
			;Drive Away
			(if (! (achieve-workpiece (val $agent) (workpiece 0 (base none) (rings none) (cap none) (place "none" "none"))))
				(! (printf (FORMAT "Send a dum WP to drive a way %s \n" (val $agent))))
				)
			(! (printf (FORMAT "GOING TO IDLE %s \n" (val $agent))))

			(=> (agent-achieving (val $agent) IDLE))
			)
		)
		
	(defop Task-Cx--Retrive-Cap
		:invocation ( ! (Task-Cx--Retrive-Cap $agent $goal-inmind))
		:context( 	(= $goal-inmind
						(goal-inmind (workpiece $g-id (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(master-of REASONING $me)
					(agent-name $me)
					)
					; (cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
		:body(

			(^ (in-production $goal-inmind))

			;Wait for preconditions
			(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Retrive-Cap))
				)
			(! (printf (FORMAT "TASK ==> Task-Retrive-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place (val $agent) "gripper"))))

			(^ (workpiece @piece-id (base UNKNOWN) (rings none) (cap $cap-color) (place (val $agent) "gripper")))

			(// 
				((! (achieve-workpiece (val $agent) (workpiece (val @piece-id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))))
				((! (achieve-workpiece $cs-name (workpiece (* -1 (val @piece-id)) (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))))
				)

			(^ (& 	(workpiece $id-ve $base $rings $cap (place $cs-name "output"))
					(> 0 $id-ve )
					))

			; (=> (agent-achieving $agent IDLE))
			; (if (? (~ (= $new-p-rings $g-rings)))
				; (! (= $Goal (BUILD-GOAL 
				
				(if (! (Task-Cx--Clear-Negative-WP-at-output (val $agent) (workpiece $id-ve $base $rings $cap (place $cs-name "output")) ))
					;Regadrless of what happens to the clearing..I have succeeded..This needs to change so that it reflects that faild the clear
					(! (printf (FORMAT "Sub-Task Clearing SUCCEEDED %s" $agent)))
					else 
					(! (printf (FORMAT "Sub-Task Clearing FAILD %s" $agent)))
					)
				; (! (INTENDED-GOAL $Goal))
				)

			)

	(defop Task-Cx--Clear-Negative-WP-at-output
		:invocation (|| (! (Task-Cx--Clear-Negative-WP-at-output $agent))
						(! (Task-Cx--Clear-Negative-WP-at-output $agent $workpiece))
						)
		:context(	(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(if (? (BOUNDP $workpiece))
				(^ (val $workpiece))
				(! (= (workpiece $id-ve $base $rings $cap (place $any-mps "output")) $workpiece ))
				else
				(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "output"))
						(> 0 $id-ve )
						))
				(! (= $workpiece (workpiece $id-ve $base $rings $cap (place $any-mps "output")) ))
				)

			(! (allocat-agent $agent Task-Clear-Negative-Wp))

			(? (workpiece $id-ve $base $rings $cap (place $any-mps "output")))

			(! (printf (FORMAT "TASK ==> Task-Clear-Negative Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $agent "gripper"))))

			(^ (workpiece $id-ve $base $rings $cap (place (val $agent) "gripper")))
			
			(! (= $workpiece-gripped (workpiece $id-ve $base $rings $cap (place $agent "gripper"))))

			(! (Task-Cx--Pay-Material (val $agent) $workpiece-gripped))

			)
		)


	(defop Pick-Random-Material
		:invocation ( ! (Pick-Random-Material $agent $workpiece))
		:context(	(master-of REASONING $me)
					(agent-name $me)
					(game-phase production)
					)
		:body(

			(! (print "Pick a Random Workpiece-----"))


			(? (= $random (rand 3)))
			(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
			(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
			(if (? (= $random 1))
				(! (achieve-workpiece (val $agent) (workpiece 0 (base base_red) (rings none) (cap none) (place (val $agent) "gripper"))))
				(^ (workpiece $id (base base_red) (rings none) (cap none) (place (val $agent) "gripper")))
				;Matche to retrun
				(! (= $workpiece (workpiece $id (base base_red) (rings none) (cap none) (place (val $agent) "gripper"))))
				else (if (? (= $random 2))
						(! (= @cs-name (car (car $cs-list))))
						(! (= @cap-color (car (cadr $cs-list))))
						else
						(! (= @cs-name (cadr (car $cs-list))))
						(! (= @cap-color (cadr (cadr $cs-list))))
						)
				
				(! ( achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap (val @cap-color)) (place (val $agent) "gripper"))))
				(^ (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper")))
				;Match to return
				(! (= $workpiece (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper"))))
				)

			)
		:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
		)


	(defop Task-Cx--Pay-Material
		:invocation(||	(! (Task-Cx--Pay-Material $agent $workpiece))
							(! (Task-Cx--Pay-Material $agent))
						)
		:context()
		:body(

			(! (tag-current-intention task_pay-material))
			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Cx--Pay-Material))
				)

			(! (printf (FORMAT "TASK ==> Task-Pay-Material Allocated to %s \n " $agent)))
			(if (? (~ (BOUNDP $workpiece)))
				(! (Pick-Random-material (val $agent) $workpiece))
				else
				(! (achieve-workpiece (val $agent) (val $workpiece))); Has to be at gripper
				(^ (val $workpiece))
				)
			
			(if (? (& 	(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
						(~ (= $g-rings (rings none)))
						))
			
				(? (|| 	(= $g-rings (rings $g-first-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
						))

				(if (? (= $g-first-ring none))
					GOTO Insert_At_RS_Slide
					)


				(if (? (workpiece $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
					(? (|| 	(= $p-rings (rings $p-first-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
							))
					
					(if (? 	(& 	(BOUNDP $g-first-ring)
								(BOUNDP $p-first-ring)
								(= $p-first-ring $g-first-ring)
								(~ (= $g-first-ring NONE))
								))
						(! (= $first-ring-done $g-first-ring))
						)
					
					(if (? 	(& 	(BOUNDP $g-second-ring)
								(BOUNDP $p-second-ring)
								(= $g-second-ring $p-second-ring)
								))
						(! (= $second-ring-done $g-second-ring))
						)			
					
					(if (? 	(& 	(BOUNDP $g-third-ring)
								(BOUNDP $p-third-ring)
								(= $p-third-ring $g-third-ring)
								))
						(! (= $third-ring-done $g-third-ring))
						)
					)

					(if (? (~ (BOUNDP $first-ring-done)))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-first-ring @colors-list)
								(ring $g-first-ring @raw-material)))

							(! (printf (FORMAT  "Task-pay: Check 1st Ring %s at %s needed: %s loaded: %s \n" $g-first-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-first-ring))
								GOTO Insert_At_RS_Slide
								)
							;(! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							;(if (? (< (LENGTH (car (val @negative-id-list))) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-second-ring)
								(~ (BOUNDP $second-ring-done))))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-second-ring @colors-list)
								(ring $g-second-ring @raw-material)))

								(! (printf (FORMAT  "Task-pay: Check 2nd Ring %s at %s needed: %s loaded: %s   \n" $g-second-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-second-ring))
								GOTO Insert_At_RS_Slide
								)
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-third-ring)
								(~ (BOUNDP $third-ring-done))
								))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-third-ring @colors-list)
								(ring $g-third-ring @raw-material)))


							(! (printf (FORMAT  "Task-Pay: Check 3rd Ring %s at %s needed: %s loaded: %s \n" $g-third-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								(! (= $ring-to-pay $g-third-ring))
								GOTO Insert_At_RS_Slide
								; )
							)
						)
				)


			LABEL Insert_At_RS_Slide
			(if (? 	(BOUNDP $ring-to-pay))
				;There is a Ring with priority. $rs-name is bound now
				(? 	(& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
							(MEMQ $ring-to-pay $colors-list)
							(ring $ring-to-pay $raw-material)
							))
							; (<= $bases-loaded $raw-material)
				(! (printf (FORMAT "Task-Pay-Material: Found a recommended ring. %s at %s \n" $ring-to-pay $rs-name)))
				else	
				(! (printf (FORMAT "Task-Pay-Material: Nothing recommended. \n")))
				)

			
			; Match to detect the new goal
			(! (= (workpiece $m-id $m-base $m-rings $m-cap (place $agent "gripper")) (val $workpiece)))

			(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
						(< $bases-loaded 3)
						))
				(! (printf (FORMAT "Task-Pay-Material: Found a RS with less than 3 bases in slide %s \n " $rs-name)))
				(if (! (achieve-workpiece (val $agent) (workpiece $m-id $m-base $m-rings $m-cap (place $rs-name "slide"))))
					(! (printf (FORMAT "Task-Pay-Material: %s Paid Material at %s \n " $agent $rs-name)))
					else
					(! (printf (FORMAT "Task-Pay-Material: %s Failed to pay..repost goal for revaluation %s \n " $agent $rs-name)))
					(! (Task-Cx--Pay-Material (val $agent) (val $workpiece)))
					)
				
				else
				(if (? (& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
							(< @bases-loaded 3)
							 ))
					(! (printf (FORMAT "Task-Pay-Material: %s Failed to pay..repost goal for revaluation %s \n " $agent $rs-name)))
					(! (Task-Cx--Pay-Material (val $agent) (val $workpiece)))
					else
					;All RS are fully loaded. Lose the workpiece
					(! (achieve-workpiece (val $agent) (workpiece $m-id $m-base $m-rings $m-cap (place "LOST" "LOST"))))
					)
			; (=> (agent-achieving $agent IDLE))
				)
			)
		)


	(defop Task-Cx--Mount-Cap
		:invocation ( ! (Task-Cx--Mount-Cap $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))
			
			(if (? (~ (= $g-rings (rings none))))
				(^ (workpiece $g-id $g-base $g-rings (cap none) (place $some-where $some-feature)))
			)
			
			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-mount-Cap))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id $g-base $g-rings (cap none) (place $agent "gripper")))
			
			(// 
				((! (achieve-workpiece $cs-name (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $cs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place $cs-name "input")))))
				)

			
			; (=> (agent-achieving $agent IDLE))

			)
		)


	(defop Task-Cx--Mount-A-Ring
		:invocation ( ! (Task-Cx--Mount-A-Ring $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			Label Check-Rings
			(? (|| 	(= $g-rings (rings $g-first-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
					))

			(? (~ (= $g-first-ring none)))

			(if (? (workpiece $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
			
				(? (|| 	(= $p-rings (rings $p-first-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
						))
			
				(if (? 	(& 	(BOUNDP $p-first-ring)
							(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							(~ (= $g-first-ring $p-first-ring))
							))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $p-rings (rings none)))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)
				(if (? 	(& 	(BOUNDP $g-second-ring)
							(BOUNDP $p-first-ring)
							(~ (BOUNDP $p-second-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-second-ring))
					(! (= $p-rings (rings $p-first-ring)))
					(! (= $new-p-rings (rings $p-first-ring $ring-to-mount)))
					GOTO wait_precond
					)			
				(if (? 	(& 	(BOUNDP $g-third-ring)
							(BOUNDP $p-first-ring)
							(BOUNDP $p-second-ring)
							(~ (BOUNDP $p-third-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-third-ring))
					(! (= $p-rings (rings $p-first-ring $p-second-ring)))
					(! (= $new-p-rings (rings $p-first-ring $p-second-ring $ring-to-mount)))
					GOTO wait_precond
					)
				else

				(if (? 	(& 	(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							))
					(! (= $p-rings (rings none)))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)

				)
			
			(if (? (~ (BOUNDP $ring-to-mount)))
				(! (printf (FORMAT " Task-Mount-RING::Could Not find deduce ring to mount")))
				(^ (DEBUG-WAIT))
				GOTO Check-Rings
				)

			LABEL wait_precond
			;To match the $rs-name & $bases-needed
			(?	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color @bases-loaded)
					(MEMQ $ring-to-mount $colors-list)
					(ring $ring-to-mount $required-material)
					))

			(^	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
					(>= $bases-loaded $required-material)
					))
			; (^ 	(&	(= $at-slide-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide"))))
			; 		(>= (LENGTH $at-slide-list) $bases-needed)
			; 		))
			;TODO for MutiGoals: Insure the booking of material 


			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Mount-A-Ring))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-A-Ring Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id $g-base $p-rings (cap none) (place $agent "gripper")))
			
			(//
				((! (achieve-workpiece $rs-name (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place $rs-name "input")))))
				)

			;make sure WP is outputed
			(^ (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))
		
			; (=> (agent-achieving $agent IDLE))

			;Recall the mount ring if nothing found
			(if (? (~ (= $new-p-rings $g-rings)))
				; (! (= $Goal (BUILD-GOAL 
				; 	(! (Task-Cx--Mount-A-Ring $some-agent))
				; 	)))
				; (! (INTENDED-GOAL $Goal))
				(! (= $production-tag (make-atom (term-string-cat "production_" $goal-inmind))))
				(! (= @tag-list (find-intentions-id $production-tag)))
				(! (intend-node-after-before-tag  	
								(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-A-Ring $agent-mount-ring (precond TRUE) $goal-inmind )))
								(. .)
								(val @tag-list)))
				)
		)
	)


	(defop Task-Cx--Deliver
		:invocation ( ! (Task-Cx--Deliver $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) )))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			;Precond
			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
			(! (= @rings-list (. .) ))
			(if (? (= $g-rings (rings none)))
				;Nothing.Just empty list
				else
				(if (? (= $g-rings (rings $first-ring)))
					(! (cons @rings-list $first-ring))
					else
					(if (? (= $g-rings (rings $first-ring $second-ring)))
						(! (cons-tail @rings-list $first-ring))
						(! (cons-tail @rings-list $second-ring))
						
						else
						(if (? (= $g-rings (rings $first-ring $second-ring $third-ring)))
							(! (cons-tail @rings-list $first-ring))
							(! (cons-tail @rings-list $second-ring))
							(! (cons-tail @rings-list $third-ring))
							)
						)
					)
				)
			(? (game-time $game-time))
			(if (? (&	(order @o-id @o-type $base-color (val @rings-list) $cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)
						(> $game-time @delivery-period-begin)
						(< $game-time @delivery-period-end)
						))
						GOTO start_delivering
			
			else
			(if (? (&	(order @o-id @o-type $base-color (val @rings-list) $cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)
						(< $game-time @delivery-period-begin)
						))
				(^ (& (> @game-time (val @delivery-period-begin))
						(quote (game-time @game-time))))
				GOTO start_delivering
					
				else
				(if (! (Task-Cx--Clear-Negative-WP-at-output $agent (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")) ))
					;Regadrless of what happens to the clearing..I have succeeded..This needs to change so that it reflects that faild the clear
					(! (printf (FORMAT "Sub-Task Clearing SUCCEEDED %s" $agent)))
					else 
					(! (printf (FORMAT "Sub-Task Clearing FAILD %s" $agent)))
					)
				LABEL fin
				)
			)
									
			
			LABEL start_delivering
			;Still there
			(? (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
		
			;select Agent
			(if (? (~ (BOUNDP $agent)))
				(! (select-appropriate-agent $agent Task-Deliver))
				)
			(! (printf (FORMAT "TASK ==> Task-Deliver Allocated to %s \n " $agent)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $agent "gripper")))

			(! (printf (FORMAT "found the WP with id %s" $id)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))

			LABEL fin
			; (=> (agent-achieving $agent IDLE))

			)
		)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) )
	; 				(= $done-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide")))) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(= $already-done (LENGTH (car $done-list)))
	; 				(<= (+ $already-done $will-be-done) 3)
	; 				)
	; 	:body(
	; 		(? (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))
	; 		(=> (todo (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap $cap-color) (place $rs-name "slide"))))
	; 		)
	; 	)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) ) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(< 0 $will-be-done)
	; 				(~ (achieve-workpiece $achiver-agent $workpiece $status))
	; 				(todo (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place $mpa)))
	; 				)
	; 	:body(


	; 		(! (achieve-workpiece "R-3" (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gipper"))))
			
	; 		( )			
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 		)
	; 	)



	; (defop Task-Cx--Clear-Negarive-WP-at-input
	; 	:invocation ( ! (Task-Cx--Clear-Negarive-WP-at-input $agent))
	; 	:context(	(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "input"))
	; 				(> 0 $id-ve )
	; 				))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place "agent" "gripper"))))


	; 		;TODO: When have the id bound at the goal-inmind ..Just match with that workpeice to see if it has something cool
	; 		(if (? (|| 	(= $wp-rings (rings $first-ring))
	; 					(= $wp-rings (rings $first-ring $second-ring))
	; 					(= $wp-rings (rings $first-ring $selected-ring $third-ring))
	; 					))

	; 			(if (? (& 	(~ (= $first-ring none))
	; 						(~ (workpiece @id @base (rings $first-ring) @cap @place))
	; 						))
	; 				(! (= $ring-to-mount $first-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring) @cap @place)
	; 						(BOUNDP $second-ring)
	; 						))
	; 				(! (= $ring-to-mount $second-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring $second-ring) @cap @place)
	; 						(BOUNDP $third-ring)
	; 						))
	; 				(! (= $ring-to-mount $third-ring))
	; 				)
	; 				GOTO Insert_At_RS_Slide
	; 		)


	; 		(if (? 	(& 	(BOUNDP $ring-to-mount)
	; 					(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(MEMQ $ring-to-mount $colors-list)
	; 					(ring $ring-to-mount $raw-material)
	; 					(< $bases-loaded 3)
	; 					(<= $bases-loaded $raw-material)
	; 					))
	; 			;There is a Ring with priority. $rs-name is bound now
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a recommended ring. Rs %s \n" $rs-name)))
	; 			else	
	; 			(! (printf (FORMAT "Task-Clear-negative: Nothing recommended. \n")))
	; 			)

			
	; 		LABEL Insert_At_RS_Slide
	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)
	; 					))
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a RS with less that 3 bases in slide %s \n " $rs-name)))
	; 			(^ (workpiece $id-ve $base $rings $cap (place "agent" "gripper")))
	; 			(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 			)
	; 		)
	; 	)




	; (defop Generator--Keep-A-Negative-WP-Around
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(= $negative-id-list (n-all-list (. $id-ve .)(& 	(workpiece $id-ve $base $rings $cap (place $some-mps $some-where))
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= $negative-succeeded-list (n-all-list (. $id-ve .)(& 	(achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $some-mps $some-where)) SUCCEEDED)
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= (LENGTH (car $negative-id-list)) 0)
	; 				(= (LENGTH (car $negative-succeeded-list)) 0)
	; 				(game-phase production)
	; 				)
	; 	:body(

	; 		;(= (LENGTH $negative-id-list) 0)
	; 		(! (print "Pay a Random Workpiece-------------------------------"))

	; 		(? (= $random (rand 3)))
	; 		(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
	;  		(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
	; 		(if (? (= $random 1))

	; 			; (=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base base_red) (rings none) (cap none) (place $bs-name "output")) SUCCEEDED))
								
	; 			else (if (? (= $random 2))
	; 					(! (= @cs-name (car (car $cs-list))))
	; 					(! (= @cap-color (car (cadr $cs-list))))
	; 					else
	; 					(! (= @cs-name (cadr (car $cs-list))))
	; 					(! (= @cap-color (cadr (cadr $cs-list))))
	; 					)
	; 			(! (start-critical-section))
	; 			(=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap (val @cap-color)) (place (val @cs-name) "input")) SUCCEEDED))
	; 			(! (end-critical-section))
	; 			; (! (= @goal-list (. .) ))
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input "R-2"))) @goal-list )))
	; 		 ; 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 			)

	; 		)
	; 	:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
	; 	)

	; (defop Intendor-Task--Clear-Negative-WP
	; 	:invocation ( workpiece $id-ve (base $base_red) $rings (cap $cap-color) (place $mps-name $side)) 
	; 	:context ( 	(> 0 $id-ve) 
	; 				(agent-name $me)
	; 				(master-of REASONING $me)
	; 				) 
	; 	:body(

	; 		(! (= @goal-list (. .) ))
	; 		; (if (? (= $side "output"))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output @agent))) @goal-list )))
	; 			; else
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input @agent))) @goal-list )))
	; 			; )
		
	; 		(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	
	; 	)


;-========================================================================================================================================================================

	)