;---------------------------------------------------------------------------
;  production-multiagent.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Mar 10 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(
	; (defop Produce-C0
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
		
	; 	:context ( 	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(game-phase production)
	; 				(~ (in-production))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
		
	; 	:body (
	; 		(! (start-critical-section))
	; 		(=> (in-production))
 ; 			(! (kill-other-intentions))
 ; 			(! (end-critical-section))
 ; 			(! (print "Producing a c0..."))

	; 		; (! (choose-free-agent-for $agent))
	; 		; (? (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))
	; 		; (=> (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))	
			
	; 		 ; (// (	
	; 		 ; 		(! (Task-Retrive-Cap "R-1"))
	; 			; 	(! (Task-Deliver "R-1"))
	; 			; 	(! (Task-Mount-Cap "R-2"))
	; 			; 	(! (Task-Clear-Cap-Station "R-1"))
	; 			; ))

	; 			(! (= @goal-list (. .) ))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Deliver 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Mount-Cap 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Clear-Cap-Station 	"R-1"))) @goal-list )))
	; 		 	(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Retrive-Cap 		"R-1"))) @goal-list )))

	; 		 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	; 	:effects ()
	; 	)


	; (defop Task--Retrive-Cap
	; 	:invocation ( ! (Task-Retrive-Cap $agent) )
	; 	:context( 	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		;Wait for preconditions
	; 		(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input"))))

	; 		)
	; 	)

	; (defop Task--Clear-Cap-Station
	; 	:invocation ( ! (Task-Clear-Cap-Station $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id)(base UNKNOWN) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)))
	; 			(! (print "Found a RS with less that 3 bases in slide"))
	; 			(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap none) (place $rs-name "slide"))))
	; 		)

	; 		)
	; 	)

	; (defop Task--Mount-Cap-c0
	; 	:invocation ( ! (Task-Mount-Cap $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(machine $mps-name "BS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base $base-color) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) (rings none) (cap none) (place $cs-name "input"))))
			
	; 		)
	; 	)

	; (defop Task--Deliver
	; 	:invocation ( ! (Task-Deliver $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base $base-color) $wp-rings (cap $cap-color) (place $cs-name "output")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper")))

	; 		(! (printf (FORMAT "found the WP with id %s" (val @id))))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate))))

	; 		)
	; 	)

;============================================================Tasks===============================================================


	(defop master-main
		:invocation ( game-phase production )
		:context ( 	(master-of REASONING $me)
					(agent-name $me)
					(~ (in-production))
					)
		:body(
			(if (! (choose-goal-inmind c0)))
			(~> (in-production))
			(if (! (Start-producing)))
			(if (! (choose-goal-inmind c1)))
			(~> (in-production))
			(if (! (Start-producing)))
			)
		:effects ( (~> (in-production)) )
		)

	(defop worker-main
		:invocation ( game-phase production )
		:context ()
		:body(
			(if (! (execute (skill "drive_into_field") )))
			)
		:effects ( )
		)


	(defop Produce-Cx
		:invocation ( ! (Start-producing) )		
		:context ( 	(goal-inmind (workpiece $id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate)))
					(master-of REASONING $me)
					(game-phase production)
					(agent-name $me)
					(~ (in-production))
					)
		
		:body (
			(! (start-critical-section))
			(=> (in-production))
 			(! (kill-other-intentions))
 			(! (end-critical-section))
 			(! (printf (FORMAT "Producing a Cx \n..." )))

			; (! (choose-free-agent-for $agent))
			; (? (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))
			; (=> (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))	
			
			 ; (// (	
			 ; 		(! (Task-Retrive-Cap "R-1"))
				; 	(! (Task-Deliver "R-1"))
				; 	(! (Task-Mount-Cap "R-2"))
				; 	(! (Task-Clear-Cap-Station "R-1"))
				; ))

				(! (= @goal-list (. .) ))
			 	(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Retrive-Cap 		$agent))) @goal-list )))

				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output	$clearing-agent))) @goal-list )))

				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay1-agent $workpiece-1))) @goal-list )))
				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay2-agent $workpiece-2))) @goal-list )))
			 	(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay3-agent $workpiece-3))) @goal-list )))
			 				 	
				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-A-ring 		$ring-agent))) @goal-list )))
				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-Cap 			$cap-agent))) @goal-list )))
				(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Deliver 			$deli-agnet))) @goal-list )))

			 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
			 	(! (printf (Format "PRODUCTION COMPLETEEEEEEEEEEEEEEEEEEE\n" )))

			)
		:effects ()
		)

;	Wait on and check the precond,
;	Find a free robot
; 	Excute the given procedure given the name of the goal
;	If failed Release the Agent


	(defop Task-Cx--Retrive-Cap
		:invocation ( ! (Task-Cx--Retrive-Cap $agent) )
		:context( 	(goal-inmind (workpiece $g-id (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			;Wait for preconditions
			(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Retrive-Cap))
				)
			(! (printf (FORMAT "TASK ==> Task-Retrive-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place $agent "gripper"))))

			(^ (workpiece @piece-id (base UNKNOWN) (rings none) (cap $cap-color) (place $agent "gripper")))

			(// 
				((! (achieve-workpiece $cs-name (workpiece (* -1 (val @piece-id)) (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece (val @piece-id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))))
				)

			; (! (= @goal-list (. .) ))
		 ; 	(! (= @goal-list (cons  (BUILD-GOAL 
		 ; 		(! (achieve-workpiece (val $agent) (workpiece (val @piece-id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))) ) @goal-list )))
			; (! (= @goal-list (cons  (BUILD-GOAL 
			; 	(! (achieve-workpiece $cs-name (workpiece (* -1 (val @piece-id)) (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))) ) @goal-list )))
		 ; 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))

			; (! (Task-Cx--Clear-Negative-WP-at-output $agent))

			(=> (agent-achieving $agent IDLE))

			)
		)



	(defop Task-Cx--Clear-Negative-WP-at-output
		:invocation ( ! (Task-Cx--Clear-Negative-WP-at-output $agent))
		:context(	(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "output"))
					(> 0 $id-ve )
					))

			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Clear-Negative-Wp))
				)
			(! (printf (FORMAT "TASK ==> Task-Clear-Negative Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece 0 $base $rings $cap (place $agent "gripper"))))

			(^ (workpiece @id-ve $base $rings $cap (place $agent "gripper")))
			
			(! (= $workpiece (workpiece (val @id-ve) $base $rings $cap (place $agent "gripper"))))

			(! (Task-Cx--Pay-Material (val $agent) $workpiece))

			)
		)


	(defop Pick-Random-Material
		:invocation ( ! (Pick-Random-Material $agent $workpiece))
		:context(	(master-of REASONING $me)
					(agent-name $me)
					(game-phase production)
					)
		:body(

			(! (print "Pick a Random Workpiece-----"))


			(? (= $random (rand 3)))
			(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
	 		(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
			(if (? (= $random 1))
				(! (achieve-workpiece (val $agent) (workpiece 0 (base base_red) (rings none) (cap none) (place $agent "gripper"))))
				(^ (workpiece $id (base base_red) (rings none) (cap none) (place $agent "gripper")))
				;Matche to retrun
				(! (= $workpiece (workpiece $id (base base_red) (rings none) (cap none) (place $agent "gripper"))))
				else (if (? (= $random 2))
						(! (= @cs-name (car (car $cs-list))))
						(! (= @cap-color (car (cadr $cs-list))))
						else
						(! (= @cs-name (cadr (car $cs-list))))
						(! (= @cap-color (cadr (cadr $cs-list))))
						)
				
				(! ( achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper"))))
				(^ (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper")))
				;Match to return
				(! (= $workpiece (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper"))))
				)

			)
		:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
		)


	(defop Task-Cx--Pay-Material
		:invocation( ! (Task-Cx--Pay-Material $agent $workpiece) )
		:context()
		:body(

			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Cx--Pay-Material))
				)

			(! (printf (FORMAT "TASK ==> Task-Pay-Material Allocated to %s \n " $agent)))
			(if (? (~ (BOUNDP $workpiece)))
				(! (Pick-Random-material $agent $workpiece))
				)
			
			(if (? (goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) )))
			
				(? (|| 	(= $g-rings (rings $g-first-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
						))

				(if (? (= $g-first-ring none))
					GOTO Insert_At_RS_Slide
					)


				(if (? (workpeice $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
					(? (|| 	(= $p-rings (rings $p-first-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
							))
					
					(if (? 	(& 	(BOUNDP $g-first-ring)
								(BOUNDP $p-first-ring)
								(= $p-first-ring $g-first-ring)
								(~ (= $g-first-ring NONE))
								))
						(! (= $first-ring-done $g-first-ring))
						)
					
					(if (? 	(& 	(BOUNDP $g-second-ring)
								(BOUNDP $p-second-ring)
								(= $g-second-ring $p-second-ring)
								))
						(! (= $second-ring-done $g-second-ring))
						)			
					
					(if (? 	(& 	(BOUNDP $g-third-ring)
								(BOUNDP $p-third-ring)
								(= $p-third-ring $g-third-ring)
								))
						(! (= $third-ring-done $g-third-ring))
						)
					)

					(if (? (~ (BOUNDP $first-ring-done)))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-first-ring @colors-list)
								(ring $g-first-ring @raw-material)))

							(! (printf (FORMAT  "Task-pay: Check Rings %s %s %s %s \n" $g-first-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-first-ring))
								GOTO Insert_At_RS_Slide
								)
							;(! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							;(if (? (< (LENGTH (car (val @negative-id-list))) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-second-ring)
								(~ (BOUNDP $second-ring-done))))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-first-ring @colors-list)
								(ring $g-first-ring @raw-material)))

								(! (printf (FORMAT  "Task-pay: check Rings %s %s %s %s   \n" $g-second-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-second-ring))
								GOTO Insert_At_RS_Slide
								)
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-third-ring)
								(~ (BOUNDP $third-ring-done))
								))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-first-ring @colors-list)
								(ring $g-first-ring @raw-material)))


							(! (printf (FORMAT  "Task-Pay: check Rings %s %s %s  %s \n" $g-third-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								(! (= $ring-to-pay $g-third-ring))
								GOTO Insert_At_RS_Slide
								; )
							)
						)
				)


			LABEL Insert_At_RS_Slide
			(if (? 	(BOUNDP $ring-to-pay))
				;There is a Ring with priority. $rs-name is bound now
				(? 	(& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
							(MEMQ $ring-to-pay $colors-list)
							(ring $ring-to-pay $raw-material)
							(<= $bases-loaded $raw-material)))
				(! (printf (FORMAT "Task-Pay-Material: Found a recommended ring. %s at %s \n" $ring-to-pay $rs-name)))
				else	
				(! (printf (FORMAT "Task-Pay-Material: Nothing recommended. \n")))
				)

			
			(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
						(< $bases-loaded 3)
						))
				(! (printf (FORMAT "Task-Pay-Material: Found a RS with less that 3 bases in slide %s \n " $rs-name)))
				; (^ (workpiece $id-ve $base $rings $cap (place "agent" "gripper")))
			 	(! (= (workpiece $m-id $m-base $m-rings $m-cap (place $agent "gripper")) $workpiece))
				(! (achieve-workpiece (val $agent) (workpiece $m-id $m-base $m-rings $m-cap (place $rs-name "slide"))))
				)

			(=> (agent-achieving $agent IDLE))

			)
		)


	(defop Task-Cx--Mount-Cap
		:invocation ( ! (Task-Cx--Mount-Cap $agent))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))
			
			(if (? (~ (= $g-rings (rings none))))
				(^ (workpiece $g-id $g-base $g-rings (cap none) (place $some-where $some-feature)))
			)
			
			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-mount-Cap))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place $agent "gripper"))))

			(^ (workpiece $g-id $g-base $g-rings (cap none) (place $agent "gripper")))
			
			(// 
				((! (achieve-workpiece $cs-name (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $cs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place $cs-name "input")))))
				)

			
			(=> (agent-achieving $agent IDLE))

			)
		)


	(defop Task-Cx--Mount-A-Ring
		:invocation ( ! (Task-Cx--Mount-A-Ring $agent))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			Label Check-Rings
			(? (|| 	(= $g-rings (rings $g-first-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
					))

			(? (~ (= $g-first-ring none)))

			(if (? (workpeice $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
			
				(? (|| 	(= $p-rings (rings $p-first-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
						))
			
				(if (? 	(& 	(BOUNDP $p-first-ring)
							(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							(~ (= $g-first-ring $p-first-ring))
							))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $p-rings (rings none)))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)
				(if (? 	(& 	(BOUNDP $g-second-ring)
							(BOUNDP $p-first-ring)
							(~ (BOUNDP $p-second-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-second-ring))
					(! (= $p-rings (rings $p-first-ring)))
					(! (= $new-p-rings (rings $p-first-ring $ring-to-mount)))
					GOTO wait_precond
					)			
				(if (? 	(& 	(BOUNDP $g-third-ring)
							(BOUNDP $p-first-ring)
							(BOUNDP $p-second-ring)
							(~ (BOUNDP $p-third-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-third-ring))
					(! (= $p-rings (rings $p-first-ring $p-second-ring)))
					(! (= $new-p-rings (rings $p-first-ring $p-second-ring $ring-to-mount)))
					GOTO wait_precond
					)
				else

				(if (? 	(& 	(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							))
					(! (= $p-rings (rings none)))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)

				)
			
			(if (? (~ (BOUNDP $ring-to-mount)))
				(! (printf (FORMAT " Task-Mount-RING::Could Not find deduce ring to mount")))
				(^ (DEBUG-WAIT))
				GOTO Check-Rings
				)

			LABEL wait_precond
			;To match the $rs-name & $bases-needed
			(?	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color @bases-loaded)
					(MEMQ $ring-to-mount $colors-list)
					(ring $ring-to-mount $required-material)
					))

			(^	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
					(>= $bases-loaded $required-material)
					))
			; (^ 	(&	(= $at-slide-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide"))))
			; 		(>= (LENGTH $at-slide-list) $bases-needed)
			; 		))
			;TODO for MutiGoals: Insure the booking of material 


			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Mount-A-Ring))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-A-Ring Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place $agent "gripper"))))

			(^ (workpiece $g-id $g-base $p-rings (cap none) (place $agent "gripper")))
			
			(//
				((! (achieve-workpiece $rs-name (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place $rs-name "input")))))
				)

			;make sure WP is outputed
			(^ (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))
		
			(=> (agent-achieving $agent IDLE))

			;Recall the mount ring if nothing found
			(if (? (~ (= $new-p-rings $g-rings)))
				(! (= $Goal (BUILD-GOAL 
					(! (Task-Cx--Mount-A-Ring $some-agent))
					)))
		    	(! (INTENDED-GOAL $Goal))
				)
		)
	)


	(defop Task-Cx--Deliver
		:invocation ( ! (Task-Cx--Deliver $agent))
		:context(	(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			;Precond
			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
			(! (= @rings-list (. .) ))
			(if (? (= $g-rings (rings none)))
				;Nothing.Just empty list
				elseif (? (= $g-rings (rings $first-ring)))
				(! (cons @rings-list $first-ring))
				elseif (? (= $g-rings (rings $first-ring $second-ring)))
				(! (cons-tail @rings-list $first-ring))
				(! (cons-tail @rings-list $second-ring))
				elseif (? (= $g-rings (rings $first-ring $second-ring $third-ring)))
				(! (cons-tail @rings-list $first-ring))
				(! (cons-tail @rings-list $second-ring))
				(! (cons-tail @rings-list $third-ring))
				)

			(? (order $o-id $o-type $base-color (val @rings-list) $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate))
			(? (game-time $game-time))
			(^ (> $game-time $delivery-period-begin))
			;Still there
			(? (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
		
			;select Agent
			(if (? (~ (BOUNDP $agent)))
				(! (select-appropriate-agent $agent Task-Deliver))
				)
			(! (printf (FORMAT "TASK ==> Task-Deliver Allocated to %s \n " $agent)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $agent "gripper"))))

			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $agent "gripper")))

			(! (printf (FORMAT "found the WP with id %s" $id)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))

			(=> (agent-achieving $agent IDLE))

			)
		)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) )
	; 				(= $done-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide")))) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(= $already-done (LENGTH (car $done-list)))
	; 				(<= (+ $already-done $will-be-done) 3)
	; 				)
	; 	:body(
	; 		(? (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))
	; 		(=> (todo (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap $cap-color) (place $rs-name "slide"))))
	; 		)
	; 	)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) ) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(< 0 $will-be-done)
	; 				(~ (achieve-workpiece $achiver-agent $workpiece $status))
	; 				(todo (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place $mpa)))
	; 				)
	; 	:body(


	; 		(! (achieve-workpiece "R-3" (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gipper"))))
			
	; 		( )			
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 		)
	; 	)



	; (defop Task-Cx--Clear-Negarive-WP-at-input
	; 	:invocation ( ! (Task-Cx--Clear-Negarive-WP-at-input $agent))
	; 	:context(	(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "input"))
	; 				(> 0 $id-ve )
	; 				))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place "agent" "gripper"))))


	; 		;TODO: When have the id bound at the goal-inmind ..Just match with that workpeice to see if it has something cool
	; 		(if (? (|| 	(= $wp-rings (rings $first-ring))
	; 					(= $wp-rings (rings $first-ring $second-ring))
	; 					(= $wp-rings (rings $first-ring $selected-ring $third-ring))
	; 					))

	; 			(if (? (& 	(~ (= $first-ring none))
	; 						(~ (workpiece @id @base (rings $first-ring) @cap @place))
	; 						))
	; 				(! (= $ring-to-mount $first-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring) @cap @place)
	; 						(BOUNDP $second-ring)
	; 						))
	; 				(! (= $ring-to-mount $second-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring $second-ring) @cap @place)
	; 						(BOUNDP $third-ring)
	; 						))
	; 				(! (= $ring-to-mount $third-ring))
	; 				)
	; 				GOTO Insert_At_RS_Slide
	; 		)


	; 		(if (? 	(& 	(BOUNDP $ring-to-mount)
	; 					(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(MEMQ $ring-to-mount $colors-list)
	; 					(ring $ring-to-mount $raw-material)
	; 					(< $bases-loaded 3)
	; 					(<= $bases-loaded $raw-material)
	; 					))
	; 			;There is a Ring with priority. $rs-name is bound now
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a recommended ring. Rs %s \n" $rs-name)))
	; 			else	
	; 			(! (printf (FORMAT "Task-Clear-negative: Nothing recommended. \n")))
	; 			)

			
	; 		LABEL Insert_At_RS_Slide
	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)
	; 					))
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a RS with less that 3 bases in slide %s \n " $rs-name)))
	; 			(^ (workpiece $id-ve $base $rings $cap (place "agent" "gripper")))
	; 			(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 			)
	; 		)
	; 	)




	; (defop Generator--Keep-A-Negative-WP-Around
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(= $negative-id-list (n-all-list (. $id-ve .)(& 	(workpiece $id-ve $base $rings $cap (place $some-mps $some-where))
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= $negative-succeeded-list (n-all-list (. $id-ve .)(& 	(achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $some-mps $some-where)) SUCCEEDED)
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= (LENGTH (car $negative-id-list)) 0)
	; 				(= (LENGTH (car $negative-succeeded-list)) 0)
	; 				(game-phase production)
	; 				)
	; 	:body(

	; 		;(= (LENGTH $negative-id-list) 0)
	; 		(! (print "Pay a Random Workpiece-------------------------------"))

	; 		(? (= $random (rand 3)))
	; 		(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
	;  		(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
	; 		(if (? (= $random 1))

	; 			; (=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base base_red) (rings none) (cap none) (place $bs-name "output")) SUCCEEDED))
								
	; 			else (if (? (= $random 2))
	; 					(! (= @cs-name (car (car $cs-list))))
	; 					(! (= @cap-color (car (cadr $cs-list))))
	; 					else
	; 					(! (= @cs-name (cadr (car $cs-list))))
	; 					(! (= @cap-color (cadr (cadr $cs-list))))
	; 					)
	; 			(! (start-critical-section))
	; 			(=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap (val @cap-color)) (place (val @cs-name) "input")) SUCCEEDED))
	; 			(! (end-critical-section))
	; 			; (! (= @goal-list (. .) ))
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input "R-2"))) @goal-list )))
	; 		 ; 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 			)

	; 		)
	; 	:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
	; 	)

	; (defop Intendor-Task--Clear-Negative-WP
	; 	:invocation ( workpiece $id-ve (base $base_red) $rings (cap $cap-color) (place $mps-name $side)) 
	; 	:context ( 	(> 0 $id-ve) 
	; 				(agent-name $me)
	; 				(master-of REASONING $me)
	; 				) 
	; 	:body(

	; 		(! (= @goal-list (. .) ))
	; 		; (if (? (= $side "output"))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output @agent))) @goal-list )))
	; 			; else
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input @agent))) @goal-list )))
	; 			; )
		
	; 		(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	
	; 	)


;-========================================================================================================================================================================

; (defop produce-c0-imperative-multiagent
	; 	:invocation	(timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(order $id c0 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
	; 			 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
	; 			 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
	; 			 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
	; 			 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
	; 			 	(~ (= $cs-state BROKEN))
	; 			 	(~ (= $cs-state DOWN))
	; 				(peer-id private $peer-id)
	; 			   	(team-color $team-color )
	; 			   	(agent-state IDLE)
	; 			   	(~ (in-production))
	; 			   	(master-of REASONING $agent)
	; 			   	(agent-name $agent)
	; 			   	)

	; 	:body(
	; 		(! (start-critical-section))
	; 		(=> (in-production))
	; 		(! (kill-other-intentions))
	; 		(! (end-critical-section))
	; 		(! (print "Producing C0..."))
	; 		(=> (holding NONE))

	; 		(! (print "PRELOADING CAP STATION..."))
	; 		(=> (achieve-workpiece "R-1" (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")) REQUESTING ))

	; 		(=> (achieve-workpiece "R-2" (workpiece $new base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")) REQUESTING ))

	; 		;clearing task
	; 		( ^ (workpiece @some-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output") ) )
	; 		(! (workpiece (val @some-shelf-base-id) (base UNKNOWN) (rings none) (cap none) (place "agent" "gripper")))
	; 		(=> (holding NONE)) ;FAKE knowledge to let the robot goup for the base with not poblem..I want to keep the constraint of no holding to make sure what to do it i still habe
	; )

	; :effects ()
	; )

)