;---------------------------------------------------------------------------
;  production-multiagent.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Mar 10 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(
	; (defop Produce-C0
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
		
	; 	:context ( 	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(game-phase production)
	; 				(~ (in-production))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
		
	; 	:body (
	; 		(! (start-critical-section))
	; 		(=> (in-production))
 ; 			(! (kill-other-intentions))
 ; 			(! (end-critical-section))
 ; 			(! (print "Producing a c0..."))

	; 		; (! (choose-free-agent-for $agent))
	; 		; (? (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))
	; 		; (=> (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))	
			
	; 		 ; (// (	
	; 		 ; 		(! (Task-Retrive-Cap "R-1"))
	; 			; 	(! (Task-Deliver "R-1"))
	; 			; 	(! (Task-Mount-Cap "R-2"))
	; 			; 	(! (Task-Clear-Cap-Station "R-1"))
	; 			; ))

	; 			(! (= @goal-list (. .) ))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Deliver 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Mount-Cap 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Clear-Cap-Station 	"R-1"))) @goal-list )))
	; 		 	(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Retrive-Cap 		"R-1"))) @goal-list )))

	; 		 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	; 	:effects ()
	; 	)


	; (defop Task--Retrive-Cap
	; 	:invocation ( ! (Task-Retrive-Cap $agent) )
	; 	:context( 	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		;Wait for preconditions
	; 		(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input"))))

	; 		)
	; 	)

	; (defop Task--Clear-Cap-Station
	; 	:invocation ( ! (Task-Clear-Cap-Station $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id)(base UNKNOWN) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)))
	; 			(! (print "Found a RS with less that 3 bases in slide"))
	; 			(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap none) (place $rs-name "slide"))))
	; 		)

	; 		)
	; 	)

	; (defop Task--Mount-Cap-c0
	; 	:invocation ( ! (Task-Mount-Cap $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(machine $mps-name "BS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base $base-color) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) (rings none) (cap none) (place $cs-name "input"))))
			
	; 		)
	; 	)

	; (defop Task--Deliver
	; 	:invocation ( ! (Task-Deliver $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base $base-color) $wp-rings (cap $cap-color) (place $cs-name "output")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper")))

	; 		(! (printf (FORMAT "found the WP with id %s" (val @id))))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate))))

	; 		)
	; 	)

;============================================================Tasks===============================================================


	; (defop master-main
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq  )
	; 	:context ( 	(game-phase production)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(~ (in-production))
	; 				)
	; 	:body(

	; 		(! (start-critical-section))
	; 		(=> (in-production))
	; 		; (! (kill-other-intentions))
	; 		(! (end-critical-section))

	; 		(if (! (choose-goal-inmind c0 $goal-inmind))
	; 			(if (! (Start-producing $goal-inmind))
	; 				(! (printf (FORMAT "Production of a goal is FINALIZED..Moving on")))
	; 				)
	; 			)

	; 			(^ (~ (& 	(agent-achieving @agent @status)
	; 						(~ (= @status IDLE))
	; 					)))		
	; 		)
	; 	:effects ( (~> (in-production)) )
	; 	)


	(defop worker-main
		:invocation ( game-phase production )
		:context ()
		:body(
			(if (! (execute (skill "drive_into_field") )))
			)
		:effects ( )
		)


	; (defop Produce-Cx
	; 	:invocation ( ! (Start-producing $goal-inmind) )		
	; 	:context ( 	(goal-inmind (workpiece $id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(= $goal-inmind 
	; 					(goal-inmind (workpiece $id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
	; 				(master-of REASONING $me)
	; 				(game-phase production)
	; 				(agent-name $me)
	; 				)
	; 				; (~ (in-production))
		
	; 	:body (
	; 		; (! (start-critical-section))
	; 		; (=> (in-production))
	; 		; (! (kill-other-intentions))
	; 		; (! (end-critical-section))
	; 		(! (printf (FORMAT "Producing a Cx \n..." )))

	; 		;======================This is the oldest intend goals..Directly intendting the task
	; 		; (! (= @goal-list (. .) ))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Retrive-Cap 		$agent))) @goal-list )))

	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output	$clearing-agent))) @goal-list )))

	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay1-agent $workpiece-1))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay2-agent $workpiece-2))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay3-agent $workpiece-3))) @goal-list )))
							
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-A-ring 		$ring-agent))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-Cap 			$cap-agent))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Deliver 			$deli-agnet))) @goal-list )))
	; 		; (! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		;======================

	; 		;======================Intend the Achieve-task with the task name and parameters as roots in parallel
	; 		(! (= @goal-list (. .) ))
	; 		(! (= @goal-list (cons  
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Deliver $agent-deliver (precond TRUE) $goal-inmind )))
	; 							@goal-list )))

	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay1 (precond TRUE) )))
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay2 (precond TRUE) ))) 
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay3 (precond TRUE) )))
	; 							@goal-list )))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Retrive-Cap $agent-retrive (precond TRUE) $goal-inmind ))) 
	; 							@goal-list)))

	; 		; (! (= @goal-list (cons
	; 		; 					(BUILD-GOAL (! (Achieve-Task Task-Cx--Clear-Negative-WP-at-output $agent-clessar (precond TRUE))))
	; 		; 					@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-A-Ring $agent-mount-ring (precond TRUE) $goal-inmind )))
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-Cap $agent-mount-cap (precond TRUE) $goal-inmind )))
	; 							@goal-list )))
			
	; 		(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		(! (printf (Format "PRODUCTION COMPLETEEEEEEEEEEEEEEEEEEE\n" )))
	; 		;======================
	; 		)
	; 	:effects ()
	; 	)

	

;	Wait on and check the precond,
;	Find a free robot
; 	Excute the given procedure given the name of the goal
;	If failed Release the agent

	(defop Task-Achiever-and-monitor
		:invocation (|| (! (Achieve-Task $task-name $agent (precond $precond)))
						(! (Achieve-Task $task-name $agent (precond $precond) $goal-inmind))
						)
					; (goal-inmind (workpiece $g-id (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
		:context( 	(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			;Sleep Wait for Preconditions
			; (^ (val $precond))

			;Select An Agent
			; (if (? (~ (BOUNDP $agent)))
			; 	(! (select-appropriate-agent $agent $task-name))
			; 	)
						
			
			(if (? (BOUNDP $goal-inmind))
				(! (= $task-expression (build-term-comp-from-atom-llist (val $task-name) (. $agent $goal-inmind .)) ))
				else
				(! (= $task-expression (build-term-comp-from-atom-llist (val $task-name) (. $agent .)) ))
				)

			(if (! (val $task-expression))
				(! (printf (FORMAT "TASK MONITOR:: %s %s SUCCEEDED \n " $task-name $agent)))
				else
				(! (printf (FORMAT "TASK MONITOR:: %s %s FAILD  \n" $task-name $agent)))
				)

			;Rlease the agent robot if it was selected
			(if (? (BOUNDP $agent))
			(=> (agent-achieving (val $agent) RELEASING_RESOURCES))
			)
			
			)
		)

	(defop Agent--Release-When-Idle
		:invocation ( agent-achieving $agent RELEASING_RESOURCES)
		:context ()
		:body(
			; ;Release All locks
			; (while (? (lock @some-type $agent (val @resource) @some-priority))
			; 		(=> (lock RELEASE $agent (val @resource) @some-priority))
			; 		)
			;Drive Away
			(if (! (achieve-workpiece (val $agent) (workpiece 0 (base none) (rings none) (cap none) (place "none" "none"))))
				(! (printf (FORMAT "Send a dum WP to drive a way %s \n" (val $agent))))
				)
			(! (printf (FORMAT "GOING TO IDLE %s \n" (val $agent))))

			(=> (agent-achieving (val $agent) IDLE))
			)
		)
		
	(defop Task-Cx--Retrive-Cap
		:invocation ( ! (Task-Cx--Retrive-Cap $agent $goal-inmind))
		:context( 	(= $goal-inmind
						(goal-inmind (workpiece $g-id (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(master-of REASONING $me)
					(agent-name $me)
					)
					; (cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
		:body(

			(^ (in-production $goal-inmind))

			;Wait for preconditions
			(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Retrive-Cap))
				)
			(! (printf (FORMAT "TASK ==> Task-Retrive-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place (val $agent) "gripper"))))

			(^ (workpiece @piece-id (base UNKNOWN) (rings none) (cap $cap-color) (place (val $agent) "gripper")))

			(// 
				((! (achieve-workpiece (val $agent) (workpiece (val @piece-id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input")))))
				((! (achieve-workpiece $cs-name (workpiece (* -1 (val @piece-id)) (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))))
				)

			(^ (& 	(workpiece $id-ve $base $rings $cap (place $cs-name "output"))
					(> 0 $id-ve )
					))

			; (=> (agent-achieving $agent IDLE))
			; (if (? (~ (= $new-p-rings $g-rings)))
				; (! (= $Goal (BUILD-GOAL 
				
				(if (! (Task-Cx--Clear-Negative-WP-at-output (val $agent) (workpiece $id-ve $base $rings $cap (place $cs-name "output")) ))
					;Regadrless of what happens to the clearing..I have succeeded..This needs to change so that it reflects that faild the clear
					(! (printf (FORMAT "Sub-Task Clearing SUCCEEDED %s" $agent)))
					else 
					(! (printf (FORMAT "Sub-Task Clearing FAILD %s" $agent)))
					)
				; (! (INTENDED-GOAL $Goal))
				)

			)

	(defop Task-Cx--Clear-Negative-WP-at-output
		:invocation (|| (! (Task-Cx--Clear-Negative-WP-at-output $agent))
						(! (Task-Cx--Clear-Negative-WP-at-output $agent $workpiece))
						)
		:context(	(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(if (? (BOUNDP $workpiece))
				(^ (val $workpiece))
				(! (= (workpiece $id-ve $base $rings $cap (place $any-mps "output")) $workpiece ))
				else
				(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "output"))
						(> 0 $id-ve )
						))
				(! (= $workpiece (workpiece $id-ve $base $rings $cap (place $any-mps "output")) ))
				)

			(! (allocat-agent $agent Task-Clear-Negative-Wp))

			(? (workpiece $id-ve $base $rings $cap (place $any-mps "output")))

			(! (printf (FORMAT "TASK ==> Task-Clear-Negative Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $agent "gripper"))))

			(^ (workpiece $id-ve $base $rings $cap (place (val $agent) "gripper")))
			
			(! (= $workpiece-gripped (workpiece $id-ve $base $rings $cap (place $agent "gripper"))))

			(! (Task-Cx--Pay-Material (val $agent) $workpiece-gripped))

			)
		)


	(defop Pick-Random-Material
		:invocation ( ! (Pick-Random-Material $agent $workpiece))
		:context(	(master-of REASONING $me)
					(agent-name $me)
					(game-phase production)
					)
		:body(

			(! (print "Pick a Random Workpiece-----"))


			(? (= $random (rand 3)))
			(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
			(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
			(if (? (= $random 1))
				(! (achieve-workpiece (val $agent) (workpiece 0 (base base_red) (rings none) (cap none) (place (val $agent) "gripper"))))
				(^ (workpiece $id (base base_red) (rings none) (cap none) (place (val $agent) "gripper")))
				;Matche to retrun
				(! (= $workpiece (workpiece $id (base base_red) (rings none) (cap none) (place (val $agent) "gripper"))))
				else (if (? (= $random 2))
						(! (= @cs-name (car (car $cs-list))))
						(! (= @cap-color (car (cadr $cs-list))))
						else
						(! (= @cs-name (cadr (car $cs-list))))
						(! (= @cap-color (cadr (cadr $cs-list))))
						)
				
				(! ( achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap (val @cap-color)) (place (val $agent) "gripper"))))
				(^ (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper")))
				;Match to return
				(! (= $workpiece (workpiece $id (base UNKNOWN) (rings none) (cap (val @cap-color)) (place $agent "gripper"))))
				)

			)
		:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
		)


	(defop Task-Cx--Pay-Material
		:invocation(||	(! (Task-Cx--Pay-Material $agent $workpiece))
							(! (Task-Cx--Pay-Material $agent))
						)
		:context()
		:body(

			(! (tag-current-intention task_pay-material))
			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Cx--Pay-Material))
				)

			(! (printf (FORMAT "TASK ==> Task-Pay-Material Allocated to %s \n " $agent)))
			(if (? (~ (BOUNDP $workpiece)))
				(! (Pick-Random-material (val $agent) $workpiece))
				else
				(! (achieve-workpiece (val $agent) (val $workpiece))); Has to be at gripper
				(^ (val $workpiece))
				)
			
			(if (? (& 	(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
						(~ (= $g-rings (rings none)))
						))
			
				(? (|| 	(= $g-rings (rings $g-first-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring))
						(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
						))

				(if (? (= $g-first-ring none))
					GOTO Insert_At_RS_Slide
					)


				(if (? (workpiece $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
					(? (|| 	(= $p-rings (rings $p-first-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring))
							(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
							))
					
					(if (? 	(& 	(BOUNDP $g-first-ring)
								(BOUNDP $p-first-ring)
								(= $p-first-ring $g-first-ring)
								(~ (= $g-first-ring NONE))
								))
						(! (= $first-ring-done $g-first-ring))
						)
					
					(if (? 	(& 	(BOUNDP $g-second-ring)
								(BOUNDP $p-second-ring)
								(= $g-second-ring $p-second-ring)
								))
						(! (= $second-ring-done $g-second-ring))
						)			
					
					(if (? 	(& 	(BOUNDP $g-third-ring)
								(BOUNDP $p-third-ring)
								(= $p-third-ring $g-third-ring)
								))
						(! (= $third-ring-done $g-third-ring))
						)
					)

					(if (? (~ (BOUNDP $first-ring-done)))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-first-ring @colors-list)
								(ring $g-first-ring @raw-material)))

							(! (printf (FORMAT  "Task-pay: Check 1st Ring %s at %s needed: %s loaded: %s \n" $g-first-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-first-ring))
								GOTO Insert_At_RS_Slide
								)
							;(! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							;(if (? (< (LENGTH (car (val @negative-id-list))) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-second-ring)
								(~ (BOUNDP $second-ring-done))))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-second-ring @colors-list)
								(ring $g-second-ring @raw-material)))

								(! (printf (FORMAT  "Task-pay: Check 2nd Ring %s at %s needed: %s loaded: %s   \n" $g-second-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
								(! (= $ring-to-pay $g-second-ring))
								GOTO Insert_At_RS_Slide
								)
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								; )
						)

					(if (? (&	(BOUNDP $g-third-ring)
								(~ (BOUNDP $third-ring-done))
								))
						(?	(& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
								(MEMQ $g-third-ring @colors-list)
								(ring $g-third-ring @raw-material)))


							(! (printf (FORMAT  "Task-Pay: Check 3rd Ring %s at %s needed: %s loaded: %s \n" $g-third-ring (val @rs-name) (val @raw-material) (val @bases-loaded))))
							(if (? (> (val @raw-material) (val @bases-loaded)))
							; (! (= @negative-id-list (n-all-list (. $id .) (workpiece $id $base $rings $cap (place (val @rs-name) "slide")))))
							; (if (? (< (LENGTH (val @negative-id-list)) (val @raw-material)))
								(! (= $ring-to-pay $g-third-ring))
								GOTO Insert_At_RS_Slide
								; )
							)
						)
				)


			LABEL Insert_At_RS_Slide
			(if (? 	(BOUNDP $ring-to-pay))
				;There is a Ring with priority. $rs-name is bound now
				(? 	(& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
							(MEMQ $ring-to-pay $colors-list)
							(ring $ring-to-pay $raw-material)
							))
							; (<= $bases-loaded $raw-material)
				(! (printf (FORMAT "Task-Pay-Material: Found a recommended ring. %s at %s \n" $ring-to-pay $rs-name)))
				else	
				(! (printf (FORMAT "Task-Pay-Material: Nothing recommended. \n")))
				)

			
			; Match to detect the new goal
			(! (= (workpiece $m-id $m-base $m-rings $m-cap (place $agent "gripper")) (val $workpiece)))

			(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
						(< $bases-loaded 3)
						))
				(! (printf (FORMAT "Task-Pay-Material: Found a RS with less than 3 bases in slide %s \n " $rs-name)))
				(if (! (achieve-workpiece (val $agent) (workpiece $m-id $m-base $m-rings $m-cap (place $rs-name "slide"))))
					(! (printf (FORMAT "Task-Pay-Material: %s Paid Material at %s \n " $agent $rs-name)))
					else
					(! (printf (FORMAT "Task-Pay-Material: %s Failed to pay..repost goal for revaluation %s \n " $agent $rs-name)))
					(! (Task-Cx--Pay-Material (val $agent) (val $workpiece)))
					)
				
				else
				(if (? (& 	(ring-station @rs-name (avilible-colors @colors-list) @selected-color @bases-loaded)
							(< @bases-loaded 3)
							 ))
					(! (printf (FORMAT "Task-Pay-Material: %s Failed to pay..repost goal for revaluation %s \n " $agent $rs-name)))
					(! (Task-Cx--Pay-Material (val $agent) (val $workpiece)))
					else
					;All RS are fully loaded. Lose the workpiece
					(! (achieve-workpiece (val $agent) (workpiece $m-id $m-base $m-rings $m-cap (place "LOST" "LOST"))))
					)
			; (=> (agent-achieving $agent IDLE))
				)
			)
		)


	(defop Task-Cx--Mount-Cap
		:invocation ( ! (Task-Cx--Mount-Cap $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))
			
			(if (? (~ (= $g-rings (rings none))))
				(^ (workpiece $g-id $g-base $g-rings (cap none) (place $some-where $some-feature)))
			)
			
			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-mount-Cap))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-Cap Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id $g-base $g-rings (cap none) (place $agent "gripper")))
			
			(// 
				((! (achieve-workpiece $cs-name (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $cs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $g-rings (cap none) (place $cs-name "input")))))
				)

			
			; (=> (agent-achieving $agent IDLE))

			)
		)


	(defop Task-Cx--Mount-A-Ring
		:invocation ( ! (Task-Cx--Mount-A-Ring $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id $g-base $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			Label Check-Rings
			(? (|| 	(= $g-rings (rings $g-first-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring))
					(= $g-rings (rings $g-first-ring $g-second-ring $g-third-ring))
					))

			(? (~ (= $g-first-ring none)))

			(if (? (workpiece $g-id $g-base $p-rings (cap none) (place $some-mps $some-feature)))
			
				(? (|| 	(= $p-rings (rings $p-first-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring))
						(= $p-rings (rings $p-first-ring $p-second-ring $p-third-ring))
						))
			
				(if (? 	(& 	(BOUNDP $p-first-ring)
							(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							(~ (= $g-first-ring $p-first-ring))
							))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $p-rings (rings none)))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)
				(if (? 	(& 	(BOUNDP $g-second-ring)
							(BOUNDP $p-first-ring)
							(~ (BOUNDP $p-second-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-second-ring))
					(! (= $p-rings (rings $p-first-ring)))
					(! (= $new-p-rings (rings $p-first-ring $ring-to-mount)))
					GOTO wait_precond
					)			
				(if (? 	(& 	(BOUNDP $g-third-ring)
							(BOUNDP $p-first-ring)
							(BOUNDP $p-second-ring)
							(~ (BOUNDP $p-third-ring))
							(~ (= none $p-first-ring))
							))
					(! (= $ring-to-mount $g-third-ring))
					(! (= $p-rings (rings $p-first-ring $p-second-ring)))
					(! (= $new-p-rings (rings $p-first-ring $p-second-ring $ring-to-mount)))
					GOTO wait_precond
					)
				else

				(if (? 	(& 	(BOUNDP $g-first-ring)
							(~ (= none $g-first-ring))
							))
					(! (= $p-rings (rings none)))
					(! (= $ring-to-mount $g-first-ring))
					(! (= $new-p-rings (rings $ring-to-mount)))
					GOTO wait_precond
					)

				)
			
			(if (? (~ (BOUNDP $ring-to-mount)))
				(! (printf (FORMAT " Task-Mount-RING::Could Not find deduce ring to mount")))
				(^ (DEBUG-WAIT))
				GOTO Check-Rings
				)

			LABEL wait_precond
			;To match the $rs-name & $bases-needed
			(?	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color @bases-loaded)
					(MEMQ $ring-to-mount $colors-list)
					(ring $ring-to-mount $required-material)
					))

			(^	(& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
					(>= $bases-loaded $required-material)
					))
			; (^ 	(&	(= $at-slide-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide"))))
			; 		(>= (LENGTH $at-slide-list) $bases-needed)
			; 		))
			;TODO for MutiGoals: Insure the booking of material 


			(if (? (~ (BOUNDP $agent)))
				;select Agent
				(! (select-appropriate-agent $agent Task-Mount-A-Ring))
				)

			(! (printf (FORMAT "TASK ==> Task-Mount-A-Ring Allocated to %s \n " $agent)))

			(! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id $g-base $p-rings (cap none) (place $agent "gripper")))
			
			(//
				((! (achieve-workpiece $rs-name (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))))
				((! (achieve-workpiece (val $agent) (workpiece $g-id $g-base $p-rings (cap none) (place $rs-name "input")))))
				)

			;make sure WP is outputed
			(^ (workpiece $g-id $g-base $new-p-rings (cap none) (place $rs-name "output")))
		
			; (=> (agent-achieving $agent IDLE))

			;Recall the mount ring if nothing found
			(if (? (~ (= $new-p-rings $g-rings)))
				; (! (= $Goal (BUILD-GOAL 
				; 	(! (Task-Cx--Mount-A-Ring $some-agent))
				; 	)))
				; (! (INTENDED-GOAL $Goal))
				(! (= $production-tag (make-atom (term-string-cat "production_" $goal-inmind))))
				(! (= @tag-list (find-intentions-id $production-tag)))
				(! (intend-node-after-before-tag  	
								(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-A-Ring $agent-mount-ring (precond TRUE) $goal-inmind )))
								(. .)
								(val @tag-list)))
				)
		)
	)


	(defop Task-Cx--Deliver
		:invocation ( ! (Task-Cx--Deliver $agent $goal-inmind))
		:context(	(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
					(= $goal-inmind
						(goal-inmind (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate) )))
					(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
					(master-of REASONING $me)
					(agent-name $me)
					)
		:body(

			(^ (in-production $goal-inmind))

			;Precond
			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
			(! (= @rings-list (. .) ))
			(if (? (= $g-rings (rings none)))
				;Nothing.Just empty list
				else
				(if (? (= $g-rings (rings $first-ring)))
					(! (cons @rings-list $first-ring))
					else
					(if (? (= $g-rings (rings $first-ring $second-ring)))
						(! (cons-tail @rings-list $first-ring))
						(! (cons-tail @rings-list $second-ring))
						
						else
						(if (? (= $g-rings (rings $first-ring $second-ring $third-ring)))
							(! (cons-tail @rings-list $first-ring))
							(! (cons-tail @rings-list $second-ring))
							(! (cons-tail @rings-list $third-ring))
							)
						)
					)
				)
			(? (game-time $game-time))
			(if (? (&	(order @o-id @o-type $base-color (val @rings-list) $cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)
						(> $game-time @delivery-period-begin)
						(< $game-time @delivery-period-end)
						))
						GOTO start_delivering
			
			else
			(if (? (&	(order @o-id @o-type $base-color (val @rings-list) $cap-color @quantity-requested @quantity-delivered @delivery-period-begin @delivery-period-end @delivery-gate)
						(< $game-time @delivery-period-begin)
						))
				(^ (& (> @game-time (val @delivery-period-begin))
						(quote (game-time @game-time))))
				GOTO start_delivering
					
				else
				(if (! (Task-Cx--Clear-Negative-WP-at-output $agent (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")) ))
					;Regadrless of what happens to the clearing..I have succeeded..This needs to change so that it reflects that faild the clear
					(! (printf (FORMAT "Sub-Task Clearing SUCCEEDED %s" $agent)))
					else 
					(! (printf (FORMAT "Sub-Task Clearing FAILD %s" $agent)))
					)
				LABEL fin
				)
			)
									
			
			LABEL start_delivering
			;Still there
			(? (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $cs-name "output")))
			
		
			;select Agent
			(if (? (~ (BOUNDP $agent)))
				(! (select-appropriate-agent $agent Task-Deliver))
				)
			(! (printf (FORMAT "TASK ==> Task-Deliver Allocated to %s \n " $agent)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place (val $agent) "gripper"))))

			(^ (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $agent "gripper")))

			(! (printf (FORMAT "found the WP with id %s" $id)))


			(! (achieve-workpiece (val $agent) (workpiece $g-id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))

			LABEL fin
			; (=> (agent-achieving $agent IDLE))

			)
		)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) )
	; 				(= $done-list (n-all-list (. $id .)	 (workpiece $id $base $rings $cap (place $rs-name "slide")))) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(= $already-done (LENGTH (car $done-list)))
	; 				(<= (+ $already-done $will-be-done) 3)
	; 				)
	; 	:body(
	; 		(? (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))
	; 		(=> (todo (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap $cap-color) (place $rs-name "slide"))))
	; 		)
	; 	)

	; (defop TaskGenerator-Cx--Pay-Ring
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(~ (workpiece $id-ve $base $rings $cap (place $mps-name $mps-feature)))
	; 				(~ (= $mps-feature "slide"))
	; 				(~ (< $id 0))
	; 				(ring-station $rs-name $avilible-colors $selected-color $bases-loaded)
	; 				(= $todo-list (n-all-list (. $id .)	 (todo (workpiece $id $base $rings $cap (place $rs-name "slide"))) ) 
	; 				(= $will-be-done (LENGTH (car $todo-list)))
	; 				(< 0 $will-be-done)
	; 				(~ (achieve-workpiece $achiver-agent $workpiece $status))
	; 				(todo (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place $mpa)))
	; 				)
	; 	:body(


	; 		(! (achieve-workpiece "R-3" (workpiece $todo-id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gipper"))))
			
	; 		( )			
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 		)
	; 	)



	; (defop Task-Cx--Clear-Negarive-WP-at-input
	; 	:invocation ( ! (Task-Cx--Clear-Negarive-WP-at-input $agent))
	; 	:context(	(goal-inmind (workpiece $g-id (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (& 	(workpiece $id-ve $base $rings $cap (place $any-mps "input"))
	; 				(> 0 $id-ve )
	; 				))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place "agent" "gripper"))))


	; 		;TODO: When have the id bound at the goal-inmind ..Just match with that workpeice to see if it has something cool
	; 		(if (? (|| 	(= $wp-rings (rings $first-ring))
	; 					(= $wp-rings (rings $first-ring $second-ring))
	; 					(= $wp-rings (rings $first-ring $selected-ring $third-ring))
	; 					))

	; 			(if (? (& 	(~ (= $first-ring none))
	; 						(~ (workpiece @id @base (rings $first-ring) @cap @place))
	; 						))
	; 				(! (= $ring-to-mount $first-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring) @cap @place)
	; 						(BOUNDP $second-ring)
	; 						))
	; 				(! (= $ring-to-mount $second-ring))
	; 				)

	; 			(if (? (& 	(workpiece @id @base (rings $first-ring $second-ring) @cap @place)
	; 						(BOUNDP $third-ring)
	; 						))
	; 				(! (= $ring-to-mount $third-ring))
	; 				)
	; 				GOTO Insert_At_RS_Slide
	; 		)


	; 		(if (? 	(& 	(BOUNDP $ring-to-mount)
	; 					(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(MEMQ $ring-to-mount $colors-list)
	; 					(ring $ring-to-mount $raw-material)
	; 					(< $bases-loaded 3)
	; 					(<= $bases-loaded $raw-material)
	; 					))
	; 			;There is a Ring with priority. $rs-name is bound now
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a recommended ring. Rs %s \n" $rs-name)))
	; 			else	
	; 			(! (printf (FORMAT "Task-Clear-negative: Nothing recommended. \n")))
	; 			)

			
	; 		LABEL Insert_At_RS_Slide
	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list) $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)
	; 					))
	; 			(! (printf (FORMAT "Task-Clear-negative: Found a RS with less that 3 bases in slide %s \n " $rs-name)))
	; 			(^ (workpiece $id-ve $base $rings $cap (place "agent" "gripper")))
	; 			(! (achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $rs-name "slide"))))
	; 			)
	; 		)
	; 	)




	; (defop Generator--Keep-A-Negative-WP-Around
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(= $negative-id-list (n-all-list (. $id-ve .)(& 	(workpiece $id-ve $base $rings $cap (place $some-mps $some-where))
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= $negative-succeeded-list (n-all-list (. $id-ve .)(& 	(achieve-workpiece (val $agent) (workpiece $id-ve $base $rings $cap (place $some-mps $some-where)) SUCCEEDED)
	; 																						(~ (= $some-where "slide"))
	; 																						(< $id-ve 0)
	; 																						)))
	; 				(= (LENGTH (car $negative-id-list)) 0)
	; 				(= (LENGTH (car $negative-succeeded-list)) 0)
	; 				(game-phase production)
	; 				)
	; 	:body(

	; 		;(= (LENGTH $negative-id-list) 0)
	; 		(! (print "Pay a Random Workpiece-------------------------------"))

	; 		(? (= $random (rand 3)))
	; 		(? (= $cs-list (n-all-list (. $cs-name $cap-color .) (cap-station $cs-name $cap-color @loaded-status @some-on-shelf))))
	;  		(? (machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with))
			
	; 		(if (? (= $random 1))

	; 			; (=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base base_red) (rings none) (cap none) (place $bs-name "output")) SUCCEEDED))
								
	; 			else (if (? (= $random 2))
	; 					(! (= @cs-name (car (car $cs-list))))
	; 					(! (= @cap-color (car (cadr $cs-list))))
	; 					else
	; 					(! (= @cs-name (cadr (car $cs-list))))
	; 					(! (= @cap-color (cadr (cadr $cs-list))))
	; 					)
	; 			(! (start-critical-section))
	; 			(=> ( achieve-workpiece $me (workpiece (* -1 (rand 1000)) (base UNKNOWN) (rings none) (cap (val @cap-color)) (place (val @cs-name) "input")) SUCCEEDED))
	; 			(! (end-critical-section))
	; 			; (! (= @goal-list (. .) ))
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input "R-2"))) @goal-list )))
	; 		 ; 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 			)

	; 		)
	; 	:documentation " Assert a workpiece with a negative id in a random place. To be picked up later and payed as a ring"
	; 	)

	; (defop Intendor-Task--Clear-Negative-WP
	; 	:invocation ( workpiece $id-ve (base $base_red) $rings (cap $cap-color) (place $mps-name $side)) 
	; 	:context ( 	(> 0 $id-ve) 
	; 				(agent-name $me)
	; 				(master-of REASONING $me)
	; 				) 
	; 	:body(

	; 		(! (= @goal-list (. .) ))
	; 		; (if (? (= $side "output"))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output @agent))) @goal-list )))
	; 			; else
	; 			; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-input @agent))) @goal-list )))
	; 			; )
		
	; 		(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	
	; 	)


;-========================================================================================================================================================================

; (defop produce-c0-imperative-multiagent
	; 	:invocation	(timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(order $id c0 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
	; 			 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
	; 			 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
	; 			 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
	; 			 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
	; 			 	(~ (= $cs-state BROKEN))
	; 			 	(~ (= $cs-state DOWN))
	; 				(peer-id private $peer-id)
	; 			   	(team-color $team-color )
	; 			   	(agent-state IDLE)
	; 			   	(~ (in-production))
	; 			   	(master-of REASONING $agent)
	; 			   	(agent-name $agent)
	; 			   	)

	; 	:body(
	; 		(! (start-critical-section))
	; 		(=> (in-production))
	; 		(! (kill-other-intentions))
	; 		(! (end-critical-section))
	; 		(! (print "Producing C0..."))
	; 		(=> (holding NONE))

	; 		(! (print "PRELOADING CAP STATION..."))
	; 		(=> (achieve-workpiece "R-1" (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")) REQUESTING ))

	; 		(=> (achieve-workpiece "R-2" (workpiece $new base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")) REQUESTING ))

	; 		;clearing task
	; 		( ^ (workpiece @some-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output") ) )
	; 		(! (workpiece (val @some-shelf-base-id) (base UNKNOWN) (rings none) (cap none) (place "agent" "gripper")))
	; 		(=> (holding NONE)) ;FAKE knowledge to let the robot goup for the base with not poblem..I want to keep the constraint of no holding to make sure what to do it i still habe
	; )

	; :effects ()
	; )

)