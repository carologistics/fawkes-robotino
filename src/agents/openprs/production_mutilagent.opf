;---------------------------------------------------------------------------
;  production-multiagent.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Mar 10 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(
	; (defop Produce-C0
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq)
		
	; 	:context ( 	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(game-phase production)
	; 				(~ (in-production))
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
		
	; 	:body (
	; 		(! (start-critical-section))
	; 		(=> (in-production))
 ; 			(! (kill-other-intentions))
 ; 			(! (end-critical-section))
 ; 			(! (print "Producing a c0..."))

	; 		; (! (choose-free-agent-for $agent))
	; 		; (? (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))
	; 		; (=> (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))	
			
	; 		 ; (// (	
	; 		 ; 		(! (Task-Retrive-Cap "R-1"))
	; 			; 	(! (Task-Deliver "R-1"))
	; 			; 	(! (Task-Mount-Cap "R-2"))
	; 			; 	(! (Task-Clear-Cap-Station "R-1"))
	; 			; ))

	; 			(! (= @goal-list (. .) ))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Deliver 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Mount-Cap 			"R-2"))) @goal-list )))
	; 			(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Clear-Cap-Station 	"R-1"))) @goal-list )))
	; 		 	(! (= @goal-list (cons  (BUILD-GOAL (! (Task-Retrive-Cap 		"R-1"))) @goal-list )))

	; 		 	(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		)
	; 	:effects ()
	; 	)


	; (defop Task--Retrive-Cap
	; 	:invocation ( ! (Task-Retrive-Cap $agent) )
	; 	:context( 	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		;Wait for preconditions
	; 		(^ (cap-station $cs-name $cap-color CAP_NOT_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap $cap-color) (place "agent" "gripper")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap $cap-color) (place $cs-name "input"))))

	; 		)
	; 	)

	; (defop Task--Clear-Cap-Station
	; 	:invocation ( ! (Task-Clear-Cap-Station $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) @wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id)(base UNKNOWN) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(if (? (& 	(ring-station $rs-name (avilible-colors $colors-list)  $selected-color $bases-loaded)
	; 					(< $bases-loaded 3)))
	; 			(! (print "Found a RS with less that 3 bases in slide"))
	; 			(! (achieve-workpiece (val $agent) (workpiece (val @id) (base UNKNOWN) (rings none) (cap none) (place $rs-name "slide"))))
	; 		)

	; 		)
	; 	)

	; (defop Task--Mount-Cap-c0
	; 	:invocation ( ! (Task-Mount-Cap $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) (rings none) (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(machine $mps-name "BS" $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (cap-station $cs-name $cap-color CAP_LOADED @some-on-shelf))

	; 		(! (achieve-workpiece (val $agent) (workpiece 0 (base $base-color) (rings none) (cap none) (place "agent" "gripper"))))

	; 		(^ (workpiece @id (base $base-color) (rings none) (cap none) (place "agent" "gripper")))
			
	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) (rings none) (cap none) (place $cs-name "input"))))
			
	; 		)
	; 	)

	; (defop Task--Deliver
	; 	:invocation ( ! (Task-Deliver $agent))
	; 	:context(	(goal-inmind (workpiece 0 (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate) ))
	; 				(cap-station $cs-name $cap-color @loaded-status @some-on-shelf)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				)
	; 	:body(

	; 		(^ (workpiece @id (base $base-color) $wp-rings (cap $cap-color) (place $cs-name "output")))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper"))))

	; 		(^ (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place "agent" "gripper")))

	; 		(! (printf (FORMAT "found the WP with id %s" (val @id))))

	; 		(! (achieve-workpiece (val $agent) (workpiece (val @id) (base $base-color) $wp-rings (cap $cap-color) (place $ds-name $delivery-gate))))

	; 		)
	; 	)



;-========================================================================================================================================================================

; (defop master-main
	; 	:invocation ( timer "beacon" $last-sec $last-usec $seq  )
	; 	:context ( 	(game-phase production)
	; 				(master-of REASONING $me)
	; 				(agent-name $me)
	; 				(~ (in-production))
	; 				)
	; 	:body(

	; 		(! (start-critical-section))
	; 		(=> (in-production))
	; 		; (! (kill-other-intentions))
	; 		(! (end-critical-section))

	; 		(if (! (choose-goal-inmind c0 $goal-inmind))
	; 			(if (! (Start-producing $goal-inmind))
	; 				(! (printf (FORMAT "Production of a goal is FINALIZED..Moving on")))
	; 				)
	; 			)

	; 			(^ (~ (& 	(agent-achieving @agent @status)
	; 						(~ (= @status IDLE))
	; 					)))		
	; 		)
	; 	:effects ( (~> (in-production)) )
	; 	)


	(defop worker-main
		:invocation ( game-phase production )
		:context ()
		:body(
			(if (! (execute (skill "drive_into_field") )))
			)
		:effects ( )
		)


	; (defop Produce-Cx
	; 	:invocation ( ! (Start-producing $goal-inmind) )		
	; 	:context ( 	(goal-inmind (workpiece $id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate)))
	; 				(= $goal-inmind 
	; 					(goal-inmind (workpiece $id (base $base-color) $g-rings (cap $cap-color) (place $ds-name $delivery-gate))))
	; 				(master-of REASONING $me)
	; 				(game-phase production)
	; 				(agent-name $me)
	; 				)
	; 				; (~ (in-production))
		
	; 	:body (
	; 		; (! (start-critical-section))
	; 		; (=> (in-production))
	; 		; (! (kill-other-intentions))
	; 		; (! (end-critical-section))
	; 		(! (printf (FORMAT "Producing a Cx \n..." )))

	; 		;======================This is the oldest intend goals..Directly intendting the task
	; 		; (! (= @goal-list (. .) ))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Retrive-Cap 		$agent))) @goal-list )))

	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Clear-Negative-WP-at-output	$clearing-agent))) @goal-list )))

	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay1-agent $workpiece-1))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay2-agent $workpiece-2))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Pay-Material	$pay3-agent $workpiece-3))) @goal-list )))
							
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-A-ring 		$ring-agent))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Mount-Cap 			$cap-agent))) @goal-list )))
	; 		; (! (= @goal-list (cons  (BUILD-GOAL (! (Task-Cx--Deliver 			$deli-agnet))) @goal-list )))
	; 		; (! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		;======================

	; 		;======================Intend the Achieve-task with the task name and parameters as roots in parallel
	; 		(! (= @goal-list (. .) ))
	; 		(! (= @goal-list (cons  
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Deliver $agent-deliver (precond TRUE) $goal-inmind )))
	; 							@goal-list )))

	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay1 (precond TRUE) )))
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay2 (precond TRUE) ))) 
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Pay-Material $agent-pay3 (precond TRUE) )))
	; 							@goal-list )))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Retrive-Cap $agent-retrive (precond TRUE) $goal-inmind ))) 
	; 							@goal-list)))

	; 		; (! (= @goal-list (cons
	; 		; 					(BUILD-GOAL (! (Achieve-Task Task-Cx--Clear-Negative-WP-at-output $agent-clessar (precond TRUE))))
	; 		; 					@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-A-Ring $agent-mount-ring (precond TRUE) $goal-inmind )))
	; 							@goal-list)))
			
	; 		(! (= @goal-list (cons
	; 							(BUILD-GOAL (! (Achieve-Task Task-Cx--Mount-Cap $agent-mount-cap (precond TRUE) $goal-inmind )))
	; 							@goal-list )))
			
	; 		(! (INTENDED-ALL-GOALS-//-AS-ROOTS (val @goal-list)))
	; 		(! (printf (Format "PRODUCTION COMPLETEEEEEEEEEEEEEEEEEEE\n" )))
	; 		;======================
	; 		)
	; 	:effects ()
	; 	)



;-========================================================================================================================================================================

; (defop produce-c0-imperative-multiagent
	; 	:invocation	(timer "beacon" $last-sec $last-usec $seq)
	; 	:context(	(order $id c0 $base-color $ring-colors $cap-color $quantity-requested $quantity-delivered $delivery-period-begin $delivery-period-end $delivery-gate)
	; 			 	(cap-station $cs-name $cap-color $cap-loaded-status $caps-on-shelf)
	; 			 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
	; 			 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
	; 			 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
	; 			 	(~ (= $cs-state BROKEN))
	; 			 	(~ (= $cs-state DOWN))
	; 				(peer-id private $peer-id)
	; 			   	(team-color $team-color )
	; 			   	(agent-state IDLE)
	; 			   	(~ (in-production))
	; 			   	(master-of REASONING $agent)
	; 			   	(agent-name $agent)
	; 			   	)

	; 	:body(
	; 		(! (start-critical-section))
	; 		(=> (in-production))
	; 		(! (kill-other-intentions))
	; 		(! (end-critical-section))
	; 		(! (print "Producing C0..."))
	; 		(=> (holding NONE))

	; 		(! (print "PRELOADING CAP STATION..."))
	; 		(=> (achieve-workpiece "R-1" (workpiece $new-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output")) REQUESTING ))

	; 		(=> (achieve-workpiece "R-2" (workpiece $new base-id (base $base-color) (rings none) (cap $cap-color) (place $cs-name "output")) REQUESTING ))

	; 		;clearing task
	; 		( ^ (workpiece @some-shelf-base-id (base UNKNOWN) (rings none) (cap none) (place $cs-name "output") ) )
	; 		(! (workpiece (val @some-shelf-base-id) (base UNKNOWN) (rings none) (cap none) (place "agent" "gripper")))
	; 		(=> (holding NONE)) ;FAKE knowledge to let the robot goup for the base with not poblem..I want to keep the constraint of no holding to make sure what to do it i still habe
	; )

	; :effects ()
	; )

)