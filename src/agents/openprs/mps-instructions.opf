;---------------------------------------------------------------------------
;  mps-instructions.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Tue Jan 24 15:43:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

;ToDo: Change the loop to a more reliable. None blocking way. 
;		Also might add time-outs and so on..Right now if the machine. 
;		Also Handle the Machine Broken more gracefully  (right now the intention just successes to prevent waiting)

(
	(defop mps-instruction-base-station
		:invocation ( !(instruct-mps machine $bs-name (args side $side color $color)) )
		:context( 	(machine $bs-name "BS" $bs-state $bs-prepared $bs-zone $bs-pose $bs-loaded-with)
				 	(team-color $team-color)
				  	(peer-id private $peer-id)
				)
		:body( 

			(! (= @bs-inst (pb-create "llsf_msgs.PrepareInstructionBS")))
			(! (pb-set-field @bs-inst "side" $side))
			(! (pb-set-field @bs-inst "color" $color))

			(=> (last-attempted-instruction $bs-name (args side $side color $color) ATTEMPTING))
			(! (send-instruction $bs-name (val @bs-inst)))
			
			 ;TODO: Add time out here and fail the intention if it was timed
			(^ (& 	(last-attempted-instruction $bs-name @args @state)
					(|| (= (val @state) FAILED)
						(= (val @state) FINISHED))))
			)
		:documentation "Send the Prepare instruction once to the BS"
 		)


 		(defop mps-instruction-cap-station
 			:invocation ( !(instruct-mps machine $cs-name (args operation $operation)) )
 			:context( 	(machine $cs-name "CS" $cs-state $cs-prepared $cs-zone $cs-pose $cs-loaded-with)
				  	 	(team-color $team-color)
				  		(peer-id private $peer-id)
				)
 			:body(
 				(! (= @cs-inst (pb-create "llsf_msgs.PrepareInstructionCS")))
				(! (pb-set-field @cs-inst "operation" $operation)) ;TODO check if the operation is allowed before sending it

				(=> (last-attempted-instruction $cs-name (args operation $operation) ATTEMPTING))
				(! (send-instruction $cs-name (val @cs-inst)))

				(^ (& 	(last-attempted-instruction $cs-name @args @state)
						(|| (= (val @state) FAILED)
							(= (val @state) FINISHED))))
 				)
			:documentation "Send the Prepare instruction once to the CS"
 			)

 		(defop mps-instruction-ring-station
 			:invocation ( !(instruct-mps machine $rs-name (args ring-color $ring-color)) )
 			:context( 	(machine $rs-name "RS" $rs-state $rs-prepared $rs-zone $rs-pose $rs-loaded-with)
				  	 	(team-color $team-color)
				  		(peer-id private $peer-id)
				)
 			:body(
 				(! (= @rs-inst (pb-create "llsf_msgs.PrepareInstructionRS")))
				(! (pb-set-field @rs-inst "ring-color" $ring-color)) ;TODO check if the operation is allowed before sending it

				(=> (last-attempted-instruction $rs-name (args ring-color $ring-color) ATTEMPTING))
				(! (send-instruction $rs-name (val @rs-inst)))

				(^ (& 	(last-attempted-instruction $rs-name @args @state)
						(|| (= (val @state) FAILED)
							(= (val @state) FINISHED))))
 				)
			:documentation "Send the Prepare instruction once to the RS"
 			)

 		(defop mps-instruction-delivery-station
 			:invocation ( !(instruct-mps machine $ds-name (args gate $gate)) )
 			:context( 	(machine $ds-name "DS" $ds-state $ds-prepared $ds-zone $ds-pose $ds-loaded-with)
				  	 	(team-color $team-color)
				  		(peer-id private $peer-id)
				)
 			:body(
 				(! (= @ds-inst (pb-create "llsf_msgs.PrepareInstructionDS")))
				(! (pb-set-field @ds-inst "gate" $gate)) ;TODO check if the operation is allowed before sending it

				(=> (last-attempted-instruction $ds-name (args gate $gate) ATTEMPTING))
				(! (send-instruction $ds-name (val @ds-inst)))

				(^ (& 	(last-attempted-instruction $ds-name @args @state)
						(|| (= (val @state) FAILED)
							(= (val @state) FINISHED))))
 				)
			:documentation "Send the Prepare instruction once to the DS"
 			)


 		(defop mps-instruction-common-send-instruction
 			:invocation( !( send-instruction $mps-name $mps-inst) )
 			:context( 	(machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
 						;(MEMQ $mps-state (. "PREPARED" "PROCESSING" "READY-AT-OUTPUT" "BROKEN" .))
 						(last-attempted-instruction $mps-name @args ATTEMPTING)
				  	 	(team-color $team-color)
				  		(peer-id private $peer-id)
				)
 			:body(
 				(! (= @instruction (pb-create "llsf_msgs.PrepareMachine")))
				(! (pb-set-field @instruction "team_color" $team-color))
				(! (pb-set-field @instruction "machine" $mps-name ))

				(if (? (= $mps-type "BS"))
					(! (pb-set-field @instruction "instruction_bs" $mps-inst )))

				(if (? (= $mps-type "DS"))
					(! (pb-set-field @instruction "instruction_ds" $mps-inst )))

				(if (? (= $mps-type "RS"))
					(! (pb-set-field @instruction "instruction_rs" $mps-inst )))

				(if (? (= $mps-type "CS"))
					(! (pb-set-field @instruction "instruction_cs" $mps-inst )))

				
				;Todo: raplce by a neater way 
				(! (printf (FORMAT "Broadcasting to machine %s ...while its %s \n " $mps-name $mps-state)))
				(while (?	(& (machine $mps-name $mps-type @new-state @prepared @zone @pose @loaded-with)
							 	(~ (= (val @new-state) "PREPARED"))
								(~ (= (val @new-state) "PROCESSING"))
								(~ (= (val @new-state) "READY-AT-OUTPUT")) 
								(~ (= (val @new-state) "BROKEN")) )); This is wrong a bit..Make sure that u stop sending only when the state u want happens 
					(! (pb-broadcast $peer-id @instruction))
					)
				(! (print "Broadcasted"))
				;This to make sure the unification is done correctly. If the while condition is not enough to bind the $new-state. The neater way should resolve that
				(? (machine $mps-name $mps-type @new-state @prepared @zone @pose @loaded-with))

				(if (? (= "BROKEN" @new-state))
					(! (printf (FORMAT "Instruction failed..machine %s is %s \n" $mps-name @new-state) ))
					(=> (last-attempted-instruction $mps-name @args FAILED))
					;(fail) For now let it send the ack till I make the sending neater

					else 
					(! (printf (FORMAT "The instruction sent successfully..machine %s is %s \n" $mps-name @new-state) ))
					(=> (last-attempted-instruction $mps-name @args FINISHED))

					) 				
 				)

			:effects  ()
 			:documentation "Embed the PrepareInstructionXS msg for an mps in a PrepareMachine msg and Broadcast it"
 			)


	)