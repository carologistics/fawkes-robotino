;---------------------------------------------------------------------------
;  worldmodel.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri Jan 27 11:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(
	(defop worldmodel--on-machine-ready-for-out
		:invocation ( time $sec $usec ) 
		:context(   (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					(last-attempted-instruction $mps-name $args $state);TODO:make sure state not failed
					(||	(workpiece $peace-id $base $rings $cap (place $mps-name "input"));to make sure what was at the input
						(= $mps-type "BS" ) ))
	 				
		:body(
			(! (printf (FORMAT "ON_READY-AT-OUTPUT: last-attempted-instruction %s \n" $state)))

			(if (? (= $mps-type "BS"))
				(! (= (args side $side color $base-color) $args))
				; (! (= $peace-id (rand 1000)))
				(! (= $peace-id 0))
				(=> (workpiece $peace-id (base $base-color) (rings none) (cap none) (place $mps-name (term-string-cat $side)) ))
				)

			; (if (? (workpiece $peace-id $base $rings $cap (place $mps-name "input")))

				(if (? (= $mps-type "CS"))
					(! (= (args operation $operation) $args))
					;TODO: check if there was something at input..if not then something went wrong
					;if there is something at output that u dont know what it was just take it and  throw it away
					(if (? (= $operation RETRIEVE_CAP)) 
						(?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
						(=> (cap-station $mps-name $cap-color CAP_LOADED 	 $caps-on-shelf ))
						(=> (workpiece $peace-id $base $rings (cap none) (place $mps-name "output") ))
						)
					(if (? (= $operation MOUNT_CAP))  
						(? 	(cap-station $mps-name $cap-color $loaded-status $caps-on-shelf))
						(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf )); To be removed
						(=> (workpiece $peace-id $base $rings (cap $cap-color) (place $mps-name "output") ))
						))

				(if (? (= $mps-type "RS"))
					(? (= (args ring_color $new-ring) $args))
					(if (? (= $rings (rings none)))													(! (= $updated-rings (rings $new-ring) ))
					else (if (? (& (= $rings (rings $first-ring)) (~ (= $first-ring none)) )) 		(! (= $updated-rings (rings $first-ring $new-ring) ))	
						else (if (? (= $rings (rings $first-ring $second-ring)))					(! (= $updated-rings (rings $first-ring $second-ring $new-ring) )) 
						)))
					
					(? (ring $new-ring $required-bases))
					(? (ring-station $mps-name (avilible-colors $avilible-colors) $selected-color $bases-loaded))
					(! (= $updated-bases-loaded (- $bases-loaded $required-bases)))
					
					(=> (ring-station $mps-name (avilible-colors $avilible-colors) $selected-color $updated-bases-loaded))
					(=> (workpiece $peace-id $base $updated-rings (cap none) (place $mps-name "output") ))	
					)
				
				; else
				;If we dont know what was this work peace that is ready. Give it a negative ID representing an unknown workpiece
				; (=> (workpiece (* -1 (rand 1000)) $base $rings (cap $cap-color) (place $mps-name "output") ))
				; )
			
			)
		:effects ( (~> (last-attempted-instruction $mps-name $args $state)) )
		:documentation " Base on the last instuction for a machine and the workpiece info aviliable when it was at the input of a machine,
						update the workpiece and the station (if affected). Excpetion :would be the base station. Just create a workpiece since
						this piece is new "
		)

	(defop worldmodel--On-CS-OUTPUT--cap-retrived
		:invocation (workpiece $id (base UNKOWN) (rings none) (cap none) (place $cs-name "output"))
		:context ( 	(cap-station $cs-name $cap-color CAP_NOT_LOADED $caps-on-shelf )
					(> $id 0)
					)
		:body(
				(=> (cap-station $mps-name $cap-color CAP_LOADED $caps-on-shelf ))
			)
		)

	(defop worldmodel--On-CS-OUTPUT--cap-mounted
		:invocation (workpiece $id (base $base-color) @rings (cap $cap-color) (place $cs-name "output"))
		:context ( 	(cap-station $cs-name $cap-color CAP_LOADED $caps-on-shelf )
					(~ (= $base-color UNKOWN))
					(> $id 0)
					)
		:body(
				(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))
			)
		)
	
	(defop worldmodel--ready-at-output-since--assertion
		:invocation ( time $sec $usec ) 
		:context	( (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					  (~ (ready-at-output-since $mps-name $some-mtime)))
		:body ()
		:effects( (=> (ready-at-output-since $mps-name (mtime))))
		)

	(defop worldmodel--ready-at-output-since--retraction 
		:invocation (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)  
		:context	( 	(~ (= $mps-state "READY-AT-OUTPUT"))
						(ready-at-output-since $mps-name $some-mtime) )
		:body ()
		:effects( (~> (ready-at-output-since $mps-name $some-mtime)))
		)


	(defop worldmodel--on-machine-ready-at-output---unkown-piece
		:invocation ( time $sec $usec ) 
		:context(   (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					(~ (last-attempted-instruction $mps-name $args $state))
					(~ (workpiece $any-id $any-base $any-rings $any-cap (place $mps-name $feature)))		
					(ready-at-output-since $mps-name $recoreded-mtime)
					(> 10000 (- (mtime) $recoreded-mtime));;only fire if
					)
	 				
		:body(
			;TODO: maybe wait a little and recheck the preconditions again. maybe it was just delayed
			(! (printf (FORMAT "ON_READY-AT-OUTPUT: potential unknown piece at %s \n" $mps-name )))


			(if (? (= $mps-type "BS"))
				(=> (workpiece (* -1 (rand 1000)) (base BASE_NOT_SURE) (rings none) (cap none) (place $mps-name "NOT_SURE" ) ))
				)

			(if (? (= $mps-type "CS"))
				(=> (workpiece (* -1 (rand 1000)) (base BASE_NOT_SURE) (rings RING_NOT_SURE) (cap CAP_NOT_SURE) (place $mps-name "output") ))
				)


			(if (? (= $mps-type "RS"))
				(=> (workpiece (* -1 (rand 1000)) (base BASE_NOT_SURE) (rings RING_NOT_SURE) (cap none) (place $mps-name "output") ))
				)

			; (if (? (= $mps-type "CS"))
			; 	(! (= (args operation $operation) $args))

			; 		(if (? (= $operation RETRIEVE_CAP)) 
			; 			(?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
			; 			(=> (cap-station $mps-name $cap-color CAP_LOADED 	 $caps-on-shelf ))
			; 			(=> (workpiece $peace-id $base $rings (cap none) (place $mps-name "output") ))
			; 			)
			; 		(if (? (= $operation MOUNT_CAP))  
			; 			(? 	(cap-station $mps-name $cap-color $loaded-status $caps-on-shelf))
			; 			(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))
			; 			(=> (workpiece $peace-id $base $rings (cap $cap-color) (place $mps-name "output") ))
			; 			))
				
			; 	else 
			; 	;If we dont know what was this work peace that is ready. Give it a negative ID representing an unknown workpiece
			; 	(=> (workpiece (* -1 (rand 1000)) $base $rings (cap $cap-color) (place $mps-name "output") ))
				
			
			)
		:effects ()
		:documentation " If a work piece was found in an output whithout knowing what it is or where it comes from. Try 
							to find out what it is or else assert in the dataebase with a negative id and any knowledge positive knowledege
							about it "
		)

	(defop worldmodel--investigate-unknown-piece
		:invocation( workpiece $id $base $rings $cap (place $mps-name $feature) )
		:context( 	(< $id 0 )
					(machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
					)
		:body( 

			(! (printf (FORMAT "ON_READY-AT-OUTPUT: investigating unknown piece at %s %s\n" $mps-name $side )))
			;( ask-other-robots (args (workpiece $id $base $rings $cap (place $mps-name $feature)))
													;id still -ev?
													;    /  \
					   	;issue a remove puck urgent goal      All good.U just found what it is and no detial should still be NOT_SURE
						;unless if base station then either 
						;reset machine or try both sides 
			)
		:documentation "investigate an unknown piece trying to find out what it is and hanld it if still not known"
		)

	(defop worldmodel--give-unknown-base-negative-id
		:invocation (workpiece $id (base UNKOWN) (rings none) (cap none) (place $cs-name "output"))
		:context ( 	(machine $cs-name "CS" "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with) 
					(>= 0 $id)
					)
		:body( 
			(~> (workpiece $id (base UNKOWN) (rings none) (cap none) (place $cs-name "output")))
			(=> (workpiece (* -1 (rand 1000)) (base UNKOWN) (rings none) (cap none) (place $cs-name "output")))
			)
		)


	(defop worldmodel--fix-negative-id-if-another-wp-at-sameplace-Found
		:invocation (workpiece $positive-id $base $rings $cap (place $place-name $feature))
		:context ( 	(workpiece $negative-id $any-base $any-rings $any-cap (place $place-name $some-feature))
					(< 0 $positive-id)
					(>= 0 $negative-id))
		:body(
			(if(? (|| 	(machine $place-name "BS" "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
						(= $some-feature $feature)))
				(! (printf (FORMAT "FIXIGN NEGATIVE: form %s => %s at  %s \n" $negative-id $positve-id  $place-name)))
				(~> (workpiece $negative-id $any-base $any-rings $any-cap (place $place-name $some-feature)))
				)
			)
		)


	;TODO: only update or fire when some passed or some
	(defop worldmodel--agent-position
	  :invocation (bb-data "type" "Position3DInterface" "id" "Pose" "time" $t_sec $t_usec $data)
	  :context ();do the updates on a timeout later	
	  :body(
		;Crashes..debug later
		; (! (= @floatarray (bb-value $data "translation")))

		( ! (= @translation-array (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr  $data))))))))))
		; (! (print @translation-array))
		(! (= $xpos (get-float-array @translation-array 0)))
		(! (= $ypos (get-float-array @translation-array 1)))
		(=> (agent-pose $xpos $ypos))
	  	)
	)


	(defop worldmodel--Remove-Zero-id-Bases-when-pickedup
		:invocation ( time $sec $usec )
		:context(   (machine $bs-name "BS" "IDLE" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					(workpiece 0 $base $rings $cap (place $bs-name $side ))
					)
	 	:body(
	 		 	(~> (workpiece 0 $base $rings $cap (place $bs-name $side )))
	 		)
	 	)


	(defop co-worldmodel--On-AchieveWorkpiece-SUCCEEDED--sync-WP-AT-OUTPUT
	  :invocation (achieve-workpiece $agent (workpiece $id $base $rings $cap (place $mps-name $feature)) SUCCEEDED)
	  :context ((agent-name $my-name)
	  	(~ (= $my-name $agent))
	  	(< 0 $id)
	  	)
	  :body(
	  	(if (? (~ (workpiece $id $base $rings $cap (place $mps-name @feature))))
			(=> (workpiece $id $base $rings $cap (place $mps-name $feature)))
			else
			(if (? 	(& 	(= $feature "output") (~ (= (val @feature) "output"))))
				(=> (workpiece $id $base $rings $cap (place $mps-name $feature)))
				)
			)
  		)
	  :documentation "On achieve-workpiece SUCCEEDED, If there is not such workpiece just assert it. 
	  					if such a workpiece exists somewhere, Only assert if it SUCCEEDED Newly at an OUTPUT "
	)


)

