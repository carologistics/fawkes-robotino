;---------------------------------------------------------------------------
;  worldmodel.opf - OpenPRS OP file for RCll2017 openprs-agent
;
;  Created: Fri Jan 27 11:50:00 2017
;  Copyright  2017  Mostafa Gomaa [gomaa@kbsg.rwth-aachen.de]
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(
	(defop worldmodel--on-machine-ready-for-out
		:invocation ( time $sec $usec ) 
		:context(   (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					(last-attempted-instruction $mps-name $args $state);TODO:make sure state not failed
					(|| (workpiece $any-id $any-base $any-rings $any-cap (place $mps-name "input"));to make sure what was at the input
						(= $mps-type "BS" ) ))
	 				
		:body(
			(! (printf (FORMAT "ON_READY-AT-OUTPUT: last-attempted-instruction %s \n" $state)))

			(if (? (= $mps-type "BS"))
				(! (= (args side $side color $base-color) $args))
				(! (= $peace-id (rand 1000)))
				(=> (workpiece $peace-id (base $base-color) (rings none) (cap none) (place $mps-name (term-string-cat $side)) ))
				)

			(if (? (workpiece $peace-id $base $rings $cap (place $mps-name "input")))

				(if (? (= $mps-type "CS"))
					(! (= (args operation $operation) $args))
					;TODO: check if there was something at input..if not then something went wrong
					;if there is something at output that u dont know what it was just take it and  throw it away
					(if (? (= $operation RETRIEVE_CAP)) 
						(?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
						(=> (cap-station $mps-name $cap-color CAP_LOADED 	 $caps-on-shelf ))
						(=> (workpiece $peace-id $base $rings (cap none) (place $mps-name "output") ))
						)
					(if (? (= $operation MOUNT_CAP))  
						(? 	(cap-station $mps-name $cap-color $loaded-status $caps-on-shelf))
						(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))
						(=> (workpiece $peace-id $base $rings (cap $cap-color) (place $mps-name "output") ))
						))

				(if (? (= $mps-type "RS"))
					(? (= (args ring_color $new-ring) $args))
					(if (? (= $rings (rings none)))													(! (= $updated-rings (rings $new-ring) ))
					else (if (? (& (= $rings (rings $first-ring)) (~ (= $first-ring none)) )) 		(! (= $updated-rings (rings $first-ring $new-ring) ))	
						else (if (? (= $rings (rings $first-ring $second-ring)))					(! (= $updated-rings (rings $first-ring $second-ring $new-ring) )) 
						)))
					(=> (workpiece $peace-id $base $updated-rings (cap none) (place $mps-name "output") ))	
					;TODO:UPDATE THE RING STATION
					)
				
				else 
				;If we dont know what was this work peace that is ready. Give it a negative ID representing an unknown workpiece
				(=> (workpiece (* -1 (rand 1000)) $base $rings (cap $cap-color) (place $mps-name "output") ))
				)
			
			)
		:effects ( (~> (last-attempted-instruction $mps-name $args $state)) )
		:documentation " Base on the last instuction for a machine and the workpiece info aviliable when it was at the input of a machine,
						update the workpiece and the station (if affected). Excpetion :would be the base station. Just create a workpiece since
						this piece is new "
		)

	(defop worldmodel--ready-at-output-since--assertion
		:invocation ( time $sec $usec ) 
		:context	( (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					  (~ (ready-at-output-since $mps-name $some-mtime)))
		:body ()
		:effects( (=> (ready-at-output-since $mps-name (mtime))))
		)

	(defop worldmodel--ready-at-output-since--retraction 
		:invocation (machine $mps-name $mps-type $mps-state $mps-prepared $mps-zone $mps-pose $mps-loaded-with)  
		:context	( 	(~ (= $mps-state "READY-AT-OUTPUT"))
						(ready-at-output-since $mps-name $some-mtime) )
		:body ()
		:effects( (~> (ready-at-output-since $mps-name $some-mtime)))
		)


	(defop worldmodel--on-machine-ready-at-output---unkown-piece
		:invocation ( time $sec $usec ) 
		:context(   (machine $mps-name $mps-type "READY-AT-OUTPUT" $mps-prepared $mps-zone $mps-pose $mps-loaded-with)
					(~ (last-attempted-instruction $mps-name $args $state))
					(~ (workpiece $any-id $any-base $any-rings $any-cap (place $mps-name $feature)))		
					(ready-at-output-since $mps-name $recoreded-mtime)
					(> 10000 (- (mtime) $recoreded-mtime));;only fire if
					)
	 				
		:body(
			;TODO: maybe wait a little and recheck the preconditions again. maybe it was just delayed
			(! (printf (FORMAT "ON_READY-AT-OUTPUT: potential unknown piece at %s \n" $mps-name )))


			(if (? (= $mps-type "BS"))
				(=> (workpiece (* -1 (rand 1000)) (base NOT_SURE) (rings none) (cap none) (place $mps-name NOT_SURE ) ))
				)

			(if (? (= $mps-type "CS"))
				(=> (workpiece (* -1 (rand 1000)) (base NOT_SURE) (rings NOT_SURE) (cap NOT_SURE) (place $mps-name "output") ))
				)


			(if (? (= $mps-type "RS"))
				(=> (workpiece (* -1 (rand 1000)) (base NOT_SURE) (rings NOT_SURE) (cap none) (place $mps-name "output") ))
				)

			; (if (? (= $mps-type "CS"))
			; 	(! (= (args operation $operation) $args))

			; 		(if (? (= $operation RETRIEVE_CAP)) 
			; 			(?  (cap-station $mps-name $cap-color $loaded-status $caps-on-shelf )) 
			; 			(=> (cap-station $mps-name $cap-color CAP_LOADED 	 $caps-on-shelf ))
			; 			(=> (workpiece $peace-id $base $rings (cap none) (place $mps-name "output") ))
			; 			)
			; 		(if (? (= $operation MOUNT_CAP))  
			; 			(? 	(cap-station $mps-name $cap-color $loaded-status $caps-on-shelf))
			; 			(=> (cap-station $mps-name $cap-color CAP_NOT_LOADED $caps-on-shelf ))
			; 			(=> (workpiece $peace-id $base $rings (cap $cap-color) (place $mps-name "output") ))
			; 			))
				
			; 	else 
			; 	;If we dont know what was this work peace that is ready. Give it a negative ID representing an unknown workpiece
			; 	(=> (workpiece (* -1 (rand 1000)) $base $rings (cap $cap-color) (place $mps-name "output") ))
				
			
			)
		:effects ()
		:documentation " If a work piece was found in an output whithout knowing what it is or where it comes from. Try 
							to find out what it is or else assert in the dataebase with a negative id and any knowledge positive knowledege
							about it "
		)
	

	)

