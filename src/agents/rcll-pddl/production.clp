;---------------------------------------------------------------------------
;  production.clp - Planning for PCCL production
;                   Plan execution is handled in this file
;                   Action execution is located in tasks.clp
;
;  Created: Sat Jun 16 12:35:16 2012 (Mexico City)
;  Copyright  2012  Tim Niemueller [www.niemueller.de]
;                   Frederik Zwilling
;                   Matthias Loebach
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

(defrule prod-propose-task-idle
  "If we are idle change state to the proposed task."
  (declare (salience ?*PRIORITY-HIGH*))
  (phase PRODUCTION)
  ?sf <- (state IDLE)
  (task (state proposed))
  =>
  (retract ?sf)
  (assert (state TASK-PROPOSED))
)

(defrule prod-change-to-more-important-task-when-waiting-for-lock
  "If we run a low-priority task and look for an alternative AND a task with a higher priority is proposed, drop the current work and change to the priorized task."
  (declare (salience ?*PRIORITY-LOW*))
  (phase PRODUCTION)
  ?t <- (task (state running) (priority ?old-p))
  ?pt <- (task (state proposed) (priority ?p&:(> ?p ?old-p)))
  ?sf1 <- (state WAIT_AND_LOOK_FOR_ALTERATIVE)
  ?sf2 <- (state WAIT-FOR-LOCK)
  ?lock-get <- (lock (type GET) (agent ?a&:(eq ?a ?*ROBOT-NAME*)) (resource ?res))
  ?lock-ref <- (lock (type REFUSE) (agent ?a&:(eq ?a ?*ROBOT-NAME*)) (resource ?res))
  ?wfl <- (wait-for-lock (res ?res) (state get))
  ?exec <- (execute-skill ? ?)
  =>
  (retract ?sf1 ?sf2 ?wfl ?lock-get ?exec ?lock-ref)
  (modify ?t (state finished))
  (assert
    (state TASK-PROPOSED)
	  (lock (type RELEASE) (agent ?*ROBOT-NAME*) (resource ?res))
  )
)

(defrule prod-remove-proposed-tasks
  "Remove all proposed tasks, when you are neither idle nor looking for an alternative."
  (declare (salience ?*PRIORITY-LOW*))
  (phase PRODUCTION)
  (not (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE))
  ?pt <- (task (state proposed))
  =>
  (retract ?pt)
)

(defrule prod-lock-position-not-holding
  (declare (salience ?*PRIORITY-LOCK*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (stn-action (id ?id)
              (name lock-position)
              (state pending)
              (cond-actions)
              (opts ?r ?action&:(or (eq ?action PICK-CC)
                                    (eq ?action PICK-FROM-CS)
                                    (eq ?action PICK-FROM-RS)
                                    (eq ?action PICK-FROM-BS)
                                ) ?to))
  (not (locked-resource (resource ?to)))
  (not (and (stn-action (id ?other-id&:(< ?other-id ?id))
                        (name lock-position)
                        (state pending)
                        (opts ?r ?other-action&:(or (eq ?other-action PICK-CC)
                                                    (eq ?other-action PICK-FROM-CS)
                                                    (eq ?other-action PICK-FROM-RS)
                                                    (eq ?other-action PICK-FROM-BS)
                                                ) ?other-to))
            (not (locked-resource (resource ?other-to)))))
  (holding NONE)
  (not (wait-for-lock (state use)))
  (stn-sync (state generated))
  =>
  (printout t "PROD: Locking " ?to " for action " ?action " with robot " ?*ROBOT-NAME* crlf)
  (bind ?task-id (random-id))
  (assert
    (wait-for-lock (res ?to))
    (action-lock-wait ?id)
  )
)

(defrule prod-lock-position-holding
  (declare (salience ?*PRIORITY-LOCK*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (last-stn-action-unlocked ?last-lock)
  (stn-action (id ?id&:(= ?id (+ ?last-lock 1)))
              (name lock-position)
              (state pending)
              (cond-actions)
              (opts ?r ?action&:(or (eq ?action ADD-BASE-SLIDE-ONE)
                                    (eq ?action ADD-BASE-SLIDE-TWO)
                                    (eq ?action ADD-BASE-SLIDE-THREE)
                                    (eq ?action LOAD-CS)
                                    (eq ?action ADD-RING-ONE)
                                    (eq ?action ADD-RING-TWO)
                                    (eq ?action ADD-RING-THREE)
                                    (eq ?action RESET-SLIDE)
                                    (eq ?action PROD-AT-CS)
                                    (eq ?action DELIVER-C0)
                                    (eq ?action DELIVER-C1)
                                    (eq ?action DELIVER-C2)
                                    (eq ?action DELIVER-C3)
                                ) ?to))
  (or (at-pos ?to)
      (not (locked-resource (resource ?to))))
  (holding ?base&~NONE)
  (not (wait-for-lock (state use)))
  (stn-sync (state generated))
  =>
  (printout t "PROD: Trying to lock" ?to " for action " ?action " with robot " ?*ROBOT-NAME* crlf)
  (bind ?task-id (random-id))
  (assert
    (wait-for-lock (res ?to))
    (action-lock-wait ?id)
  )
)

(defrule prod-start-action-after-lock
  (declare (salience ?*PRIORITY-LOCK*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  ?sa <- (stn-action (id ?id)
                     (name lock-position)
                     (state pending)
                     (cond-actions)
                     (opts ?r ?action ?to))
  (locked-resource (resource ?to)
                   (agent ?a&:(eq ?a ?*ROBOT-NAME*)))
  (wait-for-lock (res ?to)
                 (state use))
  ?alw <- (action-lock-wait ?id)
  =>
  (bind ?rname (sym-cat ?*ROBOT-NAME*))
  (printout t "PROD: Locking stn-action " ?id " for robot " ?rname crlf)
  (synced-modify ?sa state finished active-robot ?rname)
  (retract ?alw)
)

(defrule prod-lock-release
  (declare (salience ?*PRIORITY-LOCK*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  ?sal <- (stn-action (id ?lock-id)
                      (name lock-position)
                      (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*)))
                      (opts ?r ?action ?to))
  ?sa <- (stn-action (id ?id)
                     (name unlock-position)
                     (state pending) 
                     (cond-actions $?ca&:(member$ ?lock-id ?ca))
                     (opts ?r ?action ?to))
  (forall (stn-action (id ?id) 
                      (cond-actions $? ?other-id $?))
          (stn-action (id ?other-id) 
                      (state running | finished)))
  ?wfl <- (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  ?ll <- (last-stn-action-unlocked ?last-lock)
  =>
  (bind ?rname (sym-cat ?*ROBOT-NAME*))
  (printout t "PROD: Lock release " ?id " releasing lock " ?lock-id crlf)
  (synced-modify ?sa state finished)
  (synced-modify ?sal state finished active-robot ?rname)
  (modify ?wfl (state finished))
  (retract ?ll)
  (assert (last-stn-action-unlocked ?id))
)

(defrule prod-move-to-position-empty
  (declare (salience ?*PRIORITY-DRIVE*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r ?action ?to))
  ?sa <- (stn-action (id ?id) (name move-to-position-empty) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?action ?from ?to))
  (wait-for-lock (res ?to) (state use))
  =>
  (printout t "PROD: Move empty to " ?to crlf)
  (bind ?rname (sym-cat ?*ROBOT-NAME*))
  (synced-modify ?sa state running active-robot ?rname)
  (bind ?task-id (random-id))
  (assert (task (name move-to-position-empty) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-DRIVE*))
	  (step (name drive-to) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-DRIVE*)
		  (machine (get-mps-from-place ?to)) (side (get-side-from-place ?to)))
  )
)

(defrule prod-move-to-position-holding
  (declare (salience ?*PRIORITY-DRIVE*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?base)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r ?action ?to))
  ?sa <- (stn-action (id ?id) (name move-to-position-holding) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?action ?from ?to))
  (wait-for-lock (res ?to) (state use))
  =>
  (printout t "PROD: Move empty to " ?to crlf)
  (bind ?rname (sym-cat ?*ROBOT-NAME*))
  (synced-modify ?sa state running active-robot ?rname)
  (bind ?task-id (random-id))
  (assert (task (name move-to-position-holding) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-DRIVE*))
	  (step (name drive-to) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-DRIVE*)
		  (machine (get-mps-from-place ?to)) (side (get-side-from-place ?to)))
  )
)


(defrule prod-pick-cc-from-shelf
  (declare (salience ?*PRIORITY-PREFILL-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PICK-CC ?to))
  ?sa <- (stn-action (id ?id) (name pick-cc-from-shelf) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?slot ?cc))
  (machine (mtype CS) (loaded-id 0) (name ?mps) (produced-id 0) (team ?team-color))
  (cap-station (name ?mps) (cap-loaded NONE))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick from shelf at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name pick-cc-from-shelf) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PREFILL-CS*))
    (step (name get-from-shelf) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PREFILL-CS*)
		  (machine ?mps)
      (machine-feature SHELF))
  )
)

(defrule prod-load-cs
  (declare (salience ?*PRIORITY-PREFILL-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?base)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r LOAD-CS ?to))
  ?sa <- (stn-action (id ?id) (name load-cs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?cap ?cc))
  (machine (mtype CS) (loaded-id 0) (name ?mps) (produced-id 0) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (cap-station (name ?mps) (cap-loaded NONE))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick from shelf at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name load-cs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PREFILL-CS*))
  (step (name insert) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PREFILL-CS*)
		  (machine ?mps)
      (machine-feature CONVEYOR)
      (already-at-mps TRUE))
  )
)

(defrule prod-pick-wp-from-cs
  (declare (salience ?*PRIORITY-CLEAR-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?base)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PICK-FROM-CS ?to))
  ?sa <- (stn-action (id ?id) (name pick-wp-from-cs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?cc))
  (machine (mtype CS) (loaded-id 0)
           (name ?mps) (produced-id ?produced-id&~0) (team ?team-color)
           (state READY-AT-OUTPUT))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick workpiece at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name pick-wp-from-cs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-CLEAR-CS*))
    (step (name get-output) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-CLEAR-CS*)
		  (machine ?mps))
  )
)

(defrule prod-pick-wp-from-rs
  (declare (salience ?*PRIORITY-CLEAR-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PICK-FROM-RS ?to))
  ?sa <- (stn-action (id ?id) (name pick-wp-from-rs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?base))
  (machine (mtype RS)
           (name ?mps)
           (team ?team-color)
           (state READY-AT-OUTPUT)
           (produced-id ?produced-id))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick workpiece with mounted ring at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name pick-wp-from-rs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-CLEAR-CS*))
    (step (name get-output) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-CLEAR-CS*)
		  (machine ?mps)
      (machine-feature CONVEYOR))
  )
)


(defrule prod-discard-wp-start
  (declare (salience 96))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  ?holding <- (holding ?base)
  ?sa <- (stn-action (id ?id) (name discard-wp) (state pending))
  (forall (stn-action (id ?id)
                      (cond-actions $? ?other-id $?))
          (stn-action (id ?other-id)
                      (state finished)))
  =>
  (printout t "PROD: Discard WP " ?base crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert 
    (task (name discard-wp) (id ?task-id) (state proposed) (stn-action ?id)
      (steps (create$ (+ ?task-id 1)))
      (priority ?*PRIORITY-DISCARD-UNKNOWN*))
    (step (name discard) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-DISCARD-UNKNOWN*))
  )
)

(defrule prod-reset-rs-slide
  (declare (salience 96))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  ?sa <- (stn-action (id ?id) (name reset-rs-slide) (state pending))
  (forall (stn-action (id ?id)
                      (cond-actions $? ?other-id $?))
          (stn-action (id ?other-id)
                      (state finished)))
  =>
  (printout t "PROD: Reset RS slide dummy" crlf)
  (synced-modify ?sa state finished)
)

(defrule prod-pick-wp-from-bs-for-prod
  (declare (salience ?*PRIORITY-CLEAR-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PICK-FROM-BS ?to))
  ?sa <- (stn-action (id ?id) (name pick-wp-from-bs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?base))
  (stn-action (id ?prod-id) (name prod-at-cs|add-ring-one) (cond-actions $?pca&:(member$ ?id ?pca)))
  (stn-action (id ?del-id) (name deliver-c0|deliver-c1|deliver-c2|deliver-c3) (cond-actions $?dca&:(member$ ?prod-id ?dca))
              (opts $? ?order))
  (order (id ?o-id&:(eq (str-cat ?o-id) (sub-string 2 2 ?order))) (product-id ?product-id))
  (machine (mtype BS) 
    (name ?mps) (team ?team-color)
    (state ~DOWN&~BROKEN))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick from BS at " ?mps " for production and action " ?id crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (bind ?base-col (sym-cat (sub-string 1 (- (str-index "-" ?base) 1) ?base)))
  (bind ?side (get-side-from-place ?to))
  (assert (task (name pick-wp-from-bs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
		        (priority ?*PRIORITY-CLEAR-CS*))
    (step (name instruct-mps) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?mps) (base ?base-col) (side ?side))
    (step (name get-base) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?mps) (machine-feature CONVEYOR)
      (base ?base-col) (product-id ?product-id) (side ?side))
  )
)

(defrule prod-pick-wp-from-bs-for-rs-slide
  (declare (salience ?*PRIORITY-CLEAR-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PICK-FROM-BS ?to))
  ?sa <- (stn-action (id ?id) (name pick-wp-from-bs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?base))
  (stn-action (id ?prod-id) (name add-base-to-slide-one|add-base-to-slide-two|add-base-to-slide-three) (cond-actions $?pca&:(member$ ?id ?pca)))
  (machine (mtype BS) 
    (name ?mps) (team ?team-color)
    (state ~DOWN&~BROKEN))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Pick from BS at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (bind ?base-col (sym-cat (sub-string 1 (- (str-index "-" ?base) 1) ?base)))
  (bind ?side (get-side-from-place ?to))
  (bind ?product-id (random-id))
  (assert (task (name pick-wp-from-bs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
		        (priority ?*PRIORITY-CLEAR-CS*))
    (step (name instruct-mps) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?mps) (base ?base-col) (side ?side))
    (step (name get-base) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?mps) (machine-feature CONVEYOR)
      (base ?base-col) (product-id ?product-id) (side ?side))
  )
)

(defrule prod-prod-at-cs
  (declare (salience ?*PRIORITY-PRODUCE-C0*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?base)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*))) (opts ?r PROD-AT-CS ?to))
  ?sa <- (stn-action (id ?id) (name prod-at-cs) (state pending) 
              (cond-actions $?ca&:(member$ ?lock-id ?ca)) (opts ?r ?mps ?to ?product ?base-col ?cap ?order))
  (machine (mtype CS)
           (name ?mps) (team ?team-color) (produced-id 0)
           (state ~DOWN&~BROKEN))
  (cap-station (name ?mps) (cap-loaded ?cap-color) (assigned-cap-color ?cap-color))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Mount cap at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name prod-at-cs) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PRODUCE-C0*))
    (step (name insert) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PRODUCE-C0*)
		  (machine ?mps)
      (machine-feature CONVEYOR))
  )
)

(defrule prod-add-base-to-rs
  (declare (salience ?*PRIORITY-PRODUCE-C0*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?base)
  ?sal <- (stn-action (id ?lock-id) (name lock-position) (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*)))
                      (opts ?r ?action&:(or (eq ?action ADD-BASE-SLIDE-ONE)
                                            (eq ?action ADD-BASE-SLIDE-TWO)
                                            (eq ?action ADD-BASE-SLIDE-THREE)
                                        ) ?to))
  ?sa <- (stn-action (id ?id)
                     (name ?task-name&:(or (eq ?task-name add-base-to-slide-one)
                                           (eq ?task-name add-base-to-slide-two)
                                           (eq ?task-name add-base-to-slide-three)))
                     (state pending)
                     (cond-actions $?ca&:(member$ ?lock-id ?ca))
                     (opts ?r ?mps ?to ?product))
  (machine (mtype RS) (name ?rs) (team ?team-color) (state ~DOWN&~BROKEN))
  (ring-station (name ?rs) (bases-loaded ?bases&:(< ?bases 3)))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Drop base into slide of " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name ?task-name) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PRODUCE-C0*))
    (step (name insert) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PRODUCE-C0*)
		  (machine ?mps)
      (machine-feature SLIDE))
  )
)

(defrule prod-add-ring
  (declare (salience ?*PRIORITY-PREFILL-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?product-id&~NONE)
  ?sal <- (stn-action (id ?lock-id)
                      (name lock-position)
                      (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*)))
                      (opts ?r ?action&:(or (eq ?action ADD-RING-ONE)
                                            (eq ?action ADD-RING-TWO)
                                            (eq ?action ADD-RING-THREE)
                                        ) ?to))
  ?sa <- (stn-action (id ?id)
                     (name ?task-name&:(or (eq ?task-name add-ring-one)
                                           (eq ?task-name add-ring-two)
                                           (eq ?task-name add-ring-three)))
                     (state pending)
                     (cond-actions $?ca&:(member$ ?lock-id ?ca))
                     (opts ?r ?mps ?to $? ?ring-color ?base-color ?order ?num-bases))
  (machine (mtype RS)
           (name ?mps)
           (team ?team-color)
           (produced-id 0)
           (state ~DOWN&~BROKEN))
  ; FIXME has to be enabled, does not work yet
  ;(ring-station (name ?mps)
  ;              (availablecolors $?ac&:(member$ (get-ring-color-from-plan-action ?ring-color) ?ac))
  ;              (bases-loaded ?bl&:(>= ?bl (get-int-from-ring-enum ?num-bases))))
  (wait-for-lock (res ?to) (state use))
  (at-pos ?to)
  =>
  (printout t "PROD: Add ring " (get-ring-color-from-plan-action ?ring-color) " at "  ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name ?task-name) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PREFILL-CS*))
    (step (name insert) (id (+ ?task-id 1))
        (task-priority ?*PRIORITY-PREFILL-CS*)
        (machine ?mps)
        (machine-feature CONVEYOR)
        (ring (get-ring-color-from-plan-action ?ring-color)))
  )
)

(defrule prod-deliver
  (declare (salience ?*PRIORITY-PRODUCE-C0*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding ?product-id&~NONE)
  ?sal <- (stn-action (id ?lock-id)
                      (name lock-position)
                      (state finished)
                      (active-robot ?ar&:(eq ?ar (sym-cat ?*ROBOT-NAME*)))
                      (opts ?r ?action&:(or (eq ?action DELIVER-C0)
                                            (eq ?action DELIVER-C1)
                                            (eq ?action DELIVER-C2)
                                            (eq ?action DELIVER-C3)
                                        ) ?to))
  ?sa <- (stn-action (id ?id)
                     (name ?task-name&:(or (eq ?task-name deliver-c0)
                                           (eq ?task-name deliver-c1)
                                           (eq ?task-name deliver-c2)
                                           (eq ?task-name deliver-c3)))
                     (state pending) (cond-actions $?ca&:(member$ ?lock-id ?ca))
                     (opts ?r ?mps ?to ?wp $? ?order))
  (machine (mtype DS)
           (name ?mps) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (wait-for-lock (res ?to) (state use))
  (game-time $?game-time)
  (order (id ?o-id&:(eq (str-cat ?o-id) (sub-string 2 2 ?order)))
         (delivery-gate ?gate)
         (begin ?begin&:(< ?begin (nth$ 1 ?game-time))))
  (at-pos ?to)
  =>
  (printout t "PROD: Deliver at " ?mps crlf)
  (synced-modify ?sa state running)
  (bind ?task-id (random-id))
  (assert (task (name ?task-name) (id ?task-id) (state proposed) (stn-action ?id)
		        (steps (create$ (+ ?task-id 1)))
		        (priority ?*PRIORITY-PRODUCE-C0*))
    (step (name insert) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PRODUCE-C0*)
		  (machine ?mps)
      (machine-feature CONVEYOR)
      (gate ?gate))
  )
)
