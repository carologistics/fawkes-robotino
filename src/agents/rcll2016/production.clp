;---------------------------------------------------------------------------
;  production.clp - Planning for LLSF production
;                   Here we plan which job to execute when the robot is idle
;                   The job-execution is located in tasks.clp
;
;  Created: Sat Jun 16 12:35:16 2012 (Mexico City)
;  Copyright  2012  Tim Niemueller [www.niemueller.de]
;                   Frederik Zwilling
;  Licensed under GPLv2+ license, cf. LICENSE file
;---------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; decision rules for the next most important task to propose
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defrule prod-propose-task-idle
  "If we are idle change state to the proposed task."
  (declare (salience ?*PRIORITY-HIGH*))
  (phase PRODUCTION)
  ?sf <- (state IDLE)
  (task (state proposed))
  =>
  (retract ?sf)
  (assert (state TASK-PROPOSED))
)

(defrule prod-change-to-more-important-task-when-waiting-for-lock
  "If we run a low-priority task and look for an alternative AND a task with a higher priority is proposed, drop the current work and change to the priorized task."
  (declare (salience ?*PRIORITY-LOW*))
  (phase PRODUCTION)
  ?t <- (task (state running) (priority ?old-p))
  ?pt <- (task (state proposed) (priority ?p&:(> ?p ?old-p)))
  ?sf1 <- (state WAIT_AND_LOOK_FOR_ALTERATIVE)
  ?sf2 <- (state WAIT-FOR-LOCK)
  ?lock-get <- (lock (type GET) (agent ?a&:(eq ?a ?*ROBOT-NAME*)) (resource ?res))
  ?lock-ref <- (lock (type REFUSE) (agent ?a&:(eq ?a ?*ROBOT-NAME*)) (resource ?res))
  ?wfl <- (wait-for-lock (res ?res) (state get))
  ?exec <- (execute-skill ? ?)
  =>
  (retract ?sf1 ?sf2 ?wfl ?lock-get ?exec ?lock-ref)
  (modify ?t (state finished))
  (assert
    (state TASK-PROPOSED)
	  (lock (type RELEASE) (agent ?*ROBOT-NAME*) (resource ?res))
  )
)

(defrule prod-remove-proposed-tasks
  "Remove all proposed tasks, when you are neither idle nor looking for an alternative."
  (declare (salience ?*PRIORITY-LOW*))
  (phase PRODUCTION)
  (not (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE))
  ?pt <- (task (state proposed))
  =>
  (retract ?pt)
)


(defrule prod-prefill-cap-station
  "Feed a CS with a cap from its shelf so that afterwards it can directly put the cap on a product."
  (declare (salience ?*PRIORITY-PREFILL-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (machine (mtype CS) (loaded-id 0) (incoming $?i&~:(member$ FILL_CAP ?i))
           (name ?machine) (produced-id 0) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (cap-station (name ?machine) (cap-loaded NONE)
	  (assigned-cap-color ?cap-color&~NONE))
  ;check that the task was not rejected before
  (not (and (task (name fill-cap) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?machine))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PREFILL-CS*))))
  (found-tag (name ?machine))
  =>
  (printout t "PROD: FILL " ?machine " with " ?cap-color " cap from shelf" crlf)
  (bind ?task-id (random-id))
  (assert (task (name fill-cap) (id ?task-id) (state proposed)
		        (steps (create$ (+ ?task-id 1) (+ ?task-id 2) (+ ?task-id 3)))
		        (priority ?*PRIORITY-PREFILL-CS*))
	  (step (name get-from-shelf) (id (+ ?task-id 1))
		  (task-priority ?*PRIORITY-PREFILL-CS*)
		  (machine ?machine)
      (machine-feature SHELF))
	  (step (name insert) (id (+ ?task-id 2))
		  (task-priority ?*PRIORITY-PREFILL-CS*)
		  (machine ?machine)
      (machine-feature CONVEYOR))
	  (step (name get-output) (id (+ ?task-id 3))
		  (task-priority ?*PRIORITY-PREFILL-CS*)
		  (machine ?machine))
    (needed-task-lock (task-id ?task-id) (action FILL_CAP) (place ?machine))
  )
)

(defrule prod-prefill-ring-station
  "Feed a RS with a base from the BS so that it is ready for the next production."
  (declare (salience ?*PRIORITY-PREFILL-RS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (machine (mtype RS) (incoming $?i&~:(member$ PREFILL_RS ?i))
    (name ?rs) (team ?team-color)
    (state ~DOWN&~BROKEN))
  (ring-station (name ?rs) (bases-loaded ?bases&:(< ?bases 3)))
  (found-tag (name ?rs))
  (machine (mtype BS) 
    (name ?bs) (team ?team-color)
    (state ~DOWN&~BROKEN))
  (found-tag (name ?bs))
  ;check that the task was not rejected before
  (not (and (task (name fill-rs) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?rs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PREFILL-RS*))))
  =>
  (printout t "PROD: FILL " ?rs " with base from BS" crlf)
  (bind ?task-id (random-id))
  (assert (task (name fill-rs) (id ?task-id) (state proposed)
		        (steps (create$ (+ ?task-id 1) (+ ?task-id 2) (+ ?task-id 3)))
		        (priority ?*PRIORITY-PREFILL-RS*))
    (step (name get-base) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?bs) (machine-feature CONVEYOR)
      (base RED))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?rs) (machine-feature SLIDE))
    (needed-task-lock (task-id ?task-id) (action PREFILL-RS) (place ?rs))
  )
)

(defrule insert-unknown-base-to-rs
  "Insert a base with unknown color in a RS for preparation"
  (declare (salience ?*PRIORITY-PREFILL-RS*))
  (phase PRODUCTION)
  (state IDLE)
  (team-color ?team-color&~nil)
  (holding ?product-id&~NONE)
  (product (id ?product-id) (base UNKNOWN))
  (machine (mtype RS) (incoming $?i&~:(member$ PREFILL-RS ?i))
           (name ?rs) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (ring-station (name ?rs) (bases-loaded ?bases&:(< ?bases 3)))
  ;check that the task was not rejected before
  (not (and 
    (task (name fill-rs) (state rejected) (id ?rej-id))
    (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 1))) (machine ?rs) (machine-feature SLIDE))
  ))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PREFILL-RS*))))
  (found-tag (name ?rs))
  =>
  (printout t "PROD: INSERT unknown base " ?product-id " into " ?rs crlf)
  (bind ?task-id (random-id))
  (assert 
    (task (name fill-rs) (id ?task-id) (state proposed)
      (steps (create$ (+ ?task-id 1)))
      (priority ?*PRIORITY-PREFILL-RS*))
    (step (name insert) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PREFILL-RS*)
      (machine ?rs)
      (machine-feature SLIDE))
    (needed-task-lock (task-id ?task-id) (action PREFILL-RS) (place ?rs))
  )
)

(defrule insert-unintentioanlly-holding-base-to-rs
  "Insert a base we hold unintentionally (e.g. skill-fail) in a RS for preparation"
  (declare (salience ?*PRIORITY-PREFILL-RS-WITH-HOLDING-BASE*))
  (phase PRODUCTION)
  (state IDLE)
  (team-color ?team-color&~nil)
  (holding ?product-id&~NONE)
  (product (id ?product-id))
  (machine (mtype RS) (incoming $?i&~:(member$ PREFILL-RS ?i))
           (name ?rs) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (ring-station (name ?rs) (bases-loaded ?bases&:(< ?bases 3)))
  ;check that the task was not rejected before
  (not (and 
    (task (name fill-rs) (state rejected) (id ?rej-id))
    (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 1))) (machine ?rs) (machine-feature SLIDE))
  ))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PREFILL-RS-WITH-HOLDING-BASE*))))
  (found-tag (name ?rs))
  =>
  (printout t "PROD: INSERT unintentionally holding base " ?product-id " into " ?rs crlf)
  (bind ?task-id (random-id))
  (assert 
    (task (name fill-rs) (id ?task-id) (state proposed)
      (steps (create$ (+ ?task-id 1)))
      (priority ?*PRIORITY-PREFILL-RS-WITH-HOLDING-BASE*))
    (step (name insert) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PREFILL-RS-WITH-HOLDING-BASE*)
      (machine ?rs)
      (machine-feature SLIDE))
    (needed-task-lock (task-id ?task-id) (action PREFILL-RS) (place ?rs))
  )
)

(defrule discard-unneeded-base
  "Discard a base which is not needed if no RS can be pre-filled"
  (declare (salience ?*PRIORITY-DISCARD-UNKNOWN*))
  (phase PRODUCTION)
  (state IDLE)
  (team-color ?team-color&~nil)
  (holding ?product-id&~NONE)
  (product (id ?product-id))
  (machine (mtype RS) (name ?rs) (team ?team-color))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-DISCARD-UNKNOWN*))))
  =>
  (printout t "PROD: Discard unneeded or unknown base " ?product-id crlf)
  (bind ?task-id (random-id))
  (assert
    (task (name discard-unknown) (id ?task-id) (state proposed)
      (steps (create$ (+ ?task-id 1)))
      (priority ?*PRIORITY-DISCARD-UNKNOWN*))
    (step (name discard) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-DISCARD-UNKNOWN*))
  )
)
  
(defrule prod-produce-c0
  "Produce a C0"
  (declare (salience ?*PRIORITY-PRODUCE-C0*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (machine (mtype CS) (incoming $?i&~:(member$ PROD_CAP ?i))
           (name ?cs) (team ?team-color) (produced-id 0)
           (state ~DOWN&~BROKEN))
  (cap-station (name ?cs) (cap-loaded ?cap-color) (assigned-cap-color ?cap-color))
  (found-tag (name ?cs))
  (machine (mtype BS) 
    (name ?bs) (team ?team-color)
    (state ~DOWN&~BROKEN))
  (found-tag (name ?bs))
  ;check that the task was not rejected before
  (not (and (task (name produce-c0) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?cs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PRODUCE-C0*))))
  ;check for open C0 order
  (product (id ?product-id) (rings $?r&:(eq 0 (length$ ?r))) (cap ?cap-color) (base ?base-color))
  ?of <- (order (product-id ?product-id)
    (quantity-requested ?qr) (quantity-delivered ?qd&:(> ?qr ?qd))
    (begin ?begin&:(< ?begin (+ (nth$ 1 ?game-time) ?*PRODUCE-C0-AHEAD-TIME*)))
    (end ?end&:(> ?end (+ (nth$ 1 ?game-time) ?*PRODUCE-C0-LATEST-TIME*)))
    (in-production 0) (in-delivery ?id&:(> ?qr (+ ?qd ?id)))
  )
  =>
  (printout warn "TODO: production durations not yet implemented" crlf)
  (printout t "PROD: PRODUCE C0 with " ?cap-color " cap at " ?cs crlf)
  (bind ?task-id (random-id))
  (assert (task (name produce-c0) (id ?task-id) (state proposed)
    (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
    (priority ?*PRIORITY-PRODUCE-C0*))
    (step (name get-base) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PRODUCE-C0*)
      (machine ?bs) (machine-feature CONVEYOR)
      (base ?base-color) (product-id ?product-id))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-PRODUCE-C0*)
      (machine ?cs)
      (machine-feature CONVEYOR))
    (needed-task-lock (task-id ?task-id) (action PROD_CAP) (place ?cs))
  )
  (synced-modify ?of in-production 1)
)

(defrule prod-add-first-ring
  "Add first ring to a product"
  (declare (salience ?*PRIORITY-ADD-FIRST-RING*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (product
    (id ?product-id)
    (rings $?r&:(> (length$ ?r) 0))
    (base ?base-color)
  )
  (ring (color ?ring-color&:(eq (nth$ 1 ?r) ?ring-color)) (req-bases ?rb))
  (machine (mtype RS) (incoming $?i&~:(member$ PROD_RING ?i))
           (name ?rs) (team ?team-color) (produced-id 0)
           (state ~DOWN&~BROKEN)
  )
  (ring-station
    (name ?rs)
    (available-colors $?ac&:(member$ ?ring-color ?ac))
    (bases-loaded ?bl&:(>= ?bl ?rb))
  )
  (found-tag (name ?rs))
  (machine (mtype BS)
    (name ?bs) (team ?team-color)
    (state ~DOWN&~BROKEN)
  )
  (found-tag (name ?bs))
  ;check that the task was not rejected before
  (not (and (task (name add-first-ring) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?rs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-ADD-FIRST-RING*))))
  ?of <- (order (product-id ?product-id)
    (quantity-requested ?qr) (quantity-delivered ?qd&:(> ?qr ?qd))
    (begin ?begin&:(< ?begin (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-AHEAD-TIME*)))
    (end ?end&:(> ?end (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-LATEST-TIME*)))
    (in-production 0) (in-delivery ?id&:(> ?qr (+ ?qd ?id)))
  )
  =>
  (printout warn "TODO: production durations not yet implemented")
  (printout t "PROD: Add first ring to Cx with " ?ring-color " ring at " ?rs crlf)
  (bind ?task-id (random-id))
  (assert (task (name add-first-ring) (id ?task-id) (state proposed)
    (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
    (priority ?*PRIORITY-ADD-FIRST-RING*))
    (step (name get-base) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-ADD-FIRST-RING*)
      (machine ?bs) (machine-feature CONVEYOR)
      (base ?base-color) (product-id ?product-id))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-ADD-FIRST-RING*)
      (machine ?rs)
      (machine-feature CONVEYOR)
      (ring ?ring-color))
    (needed-task-lock (task-id ?task-id) (action PROD_RING) (place ?rs))
  )
  (synced-modify ?of in-production 1)
)

(defrule prod-add-additional-ring
  "Add ring 2 or 3 to a product"
  (declare (salience ?*PRIORITY-ADD-ADDITIONAL-RING*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (product
    (id ?product-id)
    (rings $?r&:(> (length$ ?r) 1))
  )
  (product
    (id ?produced-id)
    (product-id ?product-id)
    (rings $?assembled&:(> (length$ ?r) (length ?assembled)))
  )
  (ring (color ?ring-color&:(eq (nth$ (+ (length$ ?assembled) 1) ?r) ?ring-color)) (req-bases ?rb))
  (machine (mtype RS) (incoming $?i&~:(member$ PROD_RING ?i))
           (name ?rs) (team ?team-color) (produced-id 0|?produced-id)
           (state ~DOWN&~BROKEN)
  )
  (ring-station
    (name ?rs)
    (available-colors $?ac&:(member$ ?ring-color ?ac))
    (bases-loaded ?bl&:(>= ?bl ?rb))
  )
  (found-tag (name ?rs))
  (machine (mtype RS)
    (name ?oldrs) (team ?team-color) (produced-id ?produced-id)
    (state READY-AT-OUTPUT)
  )
  (not (and (task (name add-additional-ring) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?rs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-ADD-ADDITIONAL-RING*))))
  ?of <- (order (product-id ?product-id)
    (quantity-requested ?qr) (quantity-delivered ?qd&:(> ?qr ?qd))
    (begin ?begin&:(< ?begin (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-AHEAD-TIME*)))
    (end ?end&:(> ?end (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-LATEST-TIME*)))
    (in-production 1) (in-delivery ?id&:(> ?qr (+ ?qd ?id)))
  )
  =>
  (printout t "PROD: Add additional ring to Cx with " ?ring-color " ring at " ?rs crlf)
  (bind ?task-id (random-id))
  (assert (task (name add-additional-ring) (id ?task-id) (state proposed)
    (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
    (priority ?*PRIORITY-ADD-ADDITIONAL-RING*))
    (step (name get-output) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-ADD-ADDITIONAL-RING*)
      (machine ?oldrs) (machine-feature CONVEYOR)
      (product-id ?product-id))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-ADD-ADDITIONAL-RING*)
      (machine ?rs)
      (machine-feature CONVEYOR)
      (ring ?ring-color))
    (needed-task-lock (task-id ?task-id) (action PROD_RING) (place ?rs))
  )
)

(defrule prod-produce-cx
  "Produce a Cx"
  (declare (salience ?*PRIORITY-PRODUCE-CX*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (product
    (id ?produced-id)
    (product-id ?product-id)
    (rings $?rp)
    (cap NONE)
  )
  (machine (mtype CS) (incoming $?i&~:(member$ PROD_CAP ?i))
           (name ?cs) (team ?team-color) (produced-id 0)
           (state ~DOWN&~BROKEN))
  (cap-station (name ?cs) (cap-loaded ?cap-color) (assigned-cap-color ?cap-color))
  (found-tag (name ?cs))
  (machine (mtype RS)
    (name ?rs) (team ?team-color)
    (state ~DOWN&~BROKEN)
    (produced-id ?produced-id)
  )
  (found-tag (name ?rs))
  ;check that the task was not rejected before
  (not (and (task (name produce-cx) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?cs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-PRODUCE-CX*))))
  ;check for open C0 order
  (product
    (id ?product-id)
    (rings $?r&:(and (> (length$ ?r) 0) (eq ?rp ?r)))
    (cap ?cap-color)
  )
  ?of <- (order (product-id ?product-id)
    (quantity-requested ?qr) (quantity-delivered ?qd&:(> ?qr ?qd))
    (begin ?begin&:(< ?begin (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-AHEAD-TIME*)))
    (end ?end&:(> ?end (+ (nth$ 1 ?game-time) ?*PRODUCE-CX-LATEST-TIME*)))
    (in-production 1) (in-delivery ?id&:(> ?qr (+ ?qd ?id)))
  )
  =>
  (printout warn "TODO: production durations not yet implemented")
  (printout t "PROD: PRODUCE Cx with " ?cap-color " cap at " ?cs crlf)
  (bind ?task-id (random-id))
  (assert (task (name produce-cx) (id ?task-id) (state proposed)
    (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
    (priority ?*PRIORITY-PRODUCE-CX*))
    (step (name get-output) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-PRODUCE-CX*)
      (machine ?rs) (machine-feature CONVEYOR))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-PRODUCE-CX*)
      (machine ?cs)
      (machine-feature CONVEYOR))
    (needed-task-lock (task-id ?task-id) (action PROD-CAP) (place ?cs))
  )
)

(defrule prod-deliver
  "Deliver product"
  (declare (salience ?*PRIORITY-DELIVER*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (machine (mtype CS) (produced-id ?produced-id&~0)
           (name ?cs) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (product
    (id ?produced-id)
    (product-id ?product-id)
    (cap ?cap-color)
  )
  ?ds-f <- (machine (mtype DS)
                    (name ?ds) (team ?team-color)
                    (state ~DOWN&~BROKEN))
  ;check that the task was not rejected before
  (not (and (task (name deliver) (state rejected) (id ?rej-id))
            (step (name get-output) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 1))) (machine ?cs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-DELIVER*))))
  ?of <- (order (product-id ?product-id)
    (quantity-requested ?qr) (quantity-delivered ?qd&:(> ?qr ?qd))
    (begin ?begin&:(< ?begin (+ (nth$ 1 ?game-time) ?*DELIVER-AHEAD-TIME*)))
    (end ?end&:(> ?end (+ (nth$ 1 ?game-time) ?*DELIVER-LATEST-TIME*)))
    (delivery-gate ?gate) (in-production ?ip&:(> ?ip 0)) (in-delivery ?id)
  )
  =>
  (printout t "PROD: DELIVER C0 with " ?cap-color crlf)
  (bind ?task-id (random-id))
  (assert (task (name deliver) (id ?task-id) (state proposed)
    (steps (create$ (+ ?task-id 1) (+ ?task-id 2)))
    (priority ?*PRIORITY-DELIVER*))
    (step (name get-output) (id (+ ?task-id 1))
      (task-priority ?*PRIORITY-DELIVER*)
      (machine ?cs))
    (step (name insert) (id (+ ?task-id 2))
      (task-priority ?*PRIORITY-DELIVER*)
      (machine ?ds)
      (machine-feature CONVEYOR)
      (gate ?gate))
    (needed-task-lock (task-id ?task-id) (action GET-PROD) (place ?cs))
    (needed-task-lock (task-id ?task-id) (action DELIVER) (place ?ds))
  )
)

(defrule prod-remove-product-with-expired-order
  "If we couldn't deliver a product in time and it is still in the cs, we have to clear the cs. In the same task we can fill the cs with a cap again"
  (declare (salience ?*PRIORITY-CLEAR-CS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  (game-time $?game-time)
  (machine (mtype CS) (produced-id ?produced-id&~0)
           (name ?cs) (team ?team-color)
           (state ~DOWN&~BROKEN))
  (product
    (id ?produced-id)
    (product-id ?product-id)
    (cap ?cap-color)
  )
  ;check that the task was not rejected before
  (not (and (task (name clear-cs) (state rejected) (id ?rej-id))
            (step (name insert) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 2))) (machine ?cs))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-CLEAR-CS*))))
  (order (product-id ?product-id)
         (end ?end&:(< ?end (nth$ 1 ?game-time)))
  )
  =>
  (printout t "PROD: Clear " ?cs " and fill it again because the order is over" crlf)
  (bind ?task-id (random-id))
  (assert (task (name clear-cs) (id ?task-id) (state proposed)
                (steps (create$ (+ ?task-id 1) (+ ?task-id 2) (+ ?task-id 3)))
                (priority ?*PRIORITY-CLEAR-CS*))
    (step (name get-output) (id (+ ?task-id 1))
          (task-priority ?*PRIORITY-CLEAR-CS*)
          (machine ?cs))
    (step (name insert) (id (+ ?task-id 2))
          (task-priority ?*PRIORITY-CLEAR-CS*)
          (machine ?cs)
          (machine-feature CONVEYOR))
    (step (name get-output) (id (+ ?task-id 3))
          (task-priority ?*PRIORITY-CLEAR-CS*)
          (machine ?cs))
    (needed-task-lock (task-id ?task-id) (action GET-PROD) (place ?cs))
    (needed-task-lock (task-id ?task-id) (action FILL_CAP) (place ?cs))
  )
)
  
(defrule prod-find-missing-mps-exploration-catch-up
  "If we have not found all mps until the production phase, we have to find them now."
  (declare (salience ?*PRIORITY-FIND-MISSING-MPS*))
  (phase PRODUCTION)
  (state IDLE|WAIT_AND_LOOK_FOR_ALTERATIVE)
  (team-color ?team-color&~nil)
  (holding NONE)
  ; there is a mps not found jet
  (machine (name ?missing-mps) (team ?team-color) (mtype ~RS))
  (not (found-tag (name ?missing-mps)))
  ; zone-to-explore
  ?z-f <- (zone-exploration (name ?zone) (machine ~UNKNOWN) 
                            (still-to-explore TRUE) (team ?team-color)
                            (incoming $?i&~:(member$ FIND_TAG ?i))
                            (times-searched ?times-searched))
  ; no-zone searched less times
  (not (zone-exploration (name ?z2&:(neq ?zone ?z2)) (still-to-explore TRUE) (team ?team-color)
                         (incoming $?i&~:(member$ FIND_TAG ?i))
                         (times-searched ?less-times-searched&:(< ?less-times-searched ?times-searched))))
  ;check that the task was not rejected before
  (not (and (task (name exploration-catch-up) (state rejected) (id ?rej-id))
	    (step (name find-tag) (id ?rej-st&:(eq ?rej-st (+ ?rej-id 1))) (zone ?zone))))
  (not (task (state proposed) (priority ?max-prod&:(>= ?max-prod ?*PRIORITY-FIND-MISSING-MPS*))))
  =>
  (printout t "PROD: " ?missing-mps " still not found!" 
            " Searching for it in zone " ?zone crlf)
  (bind ?task-id (random-id))
  (assert (task (name exploration-catch-up) (id ?task-id) (state proposed)
		(steps (create$ (+ ?task-id 1)))
		(priority ?*PRIORITY-FIND-MISSING-MPS*))
	  (step (name find-tag) (id (+ ?task-id 1))
		(task-priority ?*PRIORITY-FIND-MISSING-MPS*)
		(zone ?zone) (machine ?missing-mps))
	  (needed-task-lock (task-id ?task-id) (action FIND_TAG) (place ?zone))
  )
)

(defrule prod-nothing-to-do-save-factbase
  "If the agent can't find any task, save the factbase to find problems"
  (declare (salience ?*PRIORITY-NOTHING-TO-DO*))
  (phase PRODUCTION)
  (state IDLE)
  (time $?now)
  (wait-point ?wait-point)
  (not (no-task-found))
  (not (task (state proposed|asked|ordered|running)))
  =>
  (printout error "Can't find any task!." crlf)
  (printout error " Waiting..." crlf)
  (save-facts (str-cat "agent-snapshot-no-task" (nth$ 1 ?now) ".clp") visible)
  (skill-call goto place (str-cat ?wait-point))
  (assert (no-task-found))
)

(defrule prod-remove-nothing-to-do-fact
  ?no-task <- (no-task-found)
  (state ~IDLE)
  =>
  (retract ?no-task)
)
