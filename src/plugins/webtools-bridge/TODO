TODO:

* Iterate over all the ifdefines and make the naming consistenet
* look how to adpt ur own namespace...call it bridge
* publish witha 



Changes and Why:
#Web_server on_msg handler moved fom disptech:
	-the handler is no longer ()instance specific 
	-I dont want to do websocket stuff from the BridgeManager (extracing the payload and finding the session by its handler)
	-its much cleaner to just make a call to the BrigeManager with the session_object and the json string.


#Nameing Convention:
	-Names of capabilities are gonna be named after the central data type they are managing (ex. SubscriptionCapability) and they can provide multiple operations.

#the cenrtalDataType instances list (ex Subscription_List). is owend and managed by the capability itself and passed to the processor by virtual inhertance. That means all the processors will be able to maintain the same list of data.
Processors could choose to impelment their own version of the dataObject and overwrite the generate_ and distory_ methods in the capability.
CapabilityManager will only acess this list when destrying a session (or processor. but that might not be needed)
The implementation of the basic processing of the dataObjet is in the operation named methods of the baseCapability class (ex. Subscription_capability.susbscribe()). Processors my override that behaviore if they wish to give the capability it a differnet semantic.

#the other option is to maintain the list on the CapabilityManager's side. That basically means that all the basic operations semantic and behavior will be coded in an operation named method in the manager (ex. CapabilityManager::subscibe()). The processors::operation() will only be called when generating_  an instace of the dataObject to get the overridden dataObjectType. and in ditsroying_ to destroy and processor specefic relation to that dataObject instance. 

#Shared Namespace between clinets. In our approach each topic has a unique name in the globale topic namspace and has one subscibtion instance. In each Subscription instance there could be mulitble clients subscrbing and for each multiple requests.
(takecare of the maping now a SubscriptionObject could have multiple identical requests but for differnet clients. The mapping is only unique by client&&request_ID).
what do i need to do is:
	-have multiple requests per client (with unique id for that client)
	-



CHECK:

	-what throttle rate and queuelenght on the JS side


Questions:
	-what if the frequency that the topic changes at is very high. then we will congest the network with trafice while it might not be importent at all to (if the publishing rate is high)
	-Do i need to mutex fawkes::clock?


	_________________________________________________

	-->Make a until/Protocol that contain all the msg formats and proper serializer for them





WESBSESSIOTN:

So now i am thinkiinng about how to implement the websession closing event
Option 1: centralized and all the way from the close handler to the (Manager) toeach of the capabilites each capability propagates the even to the all owened objects and they  (like Subscription) and they manage the session closing and deleting it from the list!!
Fine but there is a lot of indirection in between
And since tim had said that its poor design to jum a level when ur trying to go bach then I will satrt propagating from where ever i started propagating the on_msg() [either inside the websession itself of starting with the web_server]

Option 2: Let the handler be inside the websession itsefl and destroy that object.Now how do we tell other objects that has a pointer to that that it no longer exists. A solution would be to check each time ur trying to use that object if it is still valid and then delete it if not. This means there are points in time where i will have a reffrece to an empty session and that is a bit scary.

there is an idea that i can not quite formulate though. to have some form of central entity that manages this...So the objects will tell that entity that they have this session handler and when the session is closed an event fires all overthe places where this handler is registered ....Relitivly easy since u can make a pure virtual class that any one that has a session has to implement..this class has a punsh of sessions that know how to and when its closed in the sesison. it calles all instances that has this session