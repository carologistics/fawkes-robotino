/***************************************************************************
 *  tag_position_interface.cpp - Interface handler for tag position
 *
 *  Generated: Mon Mar 23 12:01:15 2015
 *  Copyright  2012  Randolph Maaßen
 *
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version. A runtime exception applies to
 *  this software (see LICENSE.GPL_WRE file mentioned below for details).
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
 */

#include "tag_position_interface_helper.h"

#include "tag_vision_thread.h"

/** @class TagPositionInterfaceHelper "tag_position_interface_helper.h"
 * This class is used to help handling of the Position3DInterface calss. It
 * Calculates the needed position values from the given alvar position and sets
 * the Position3DInterface accordingly. It also publishes Transforms for the
 * tag.
 *
 * @author Randolph Maaßen
 */

/**
 * @param position_interface The inerface, generated by the Blackboard, that
 * this instance handles.
 * @param index The position in the TagPositionList, or any other
 * enumeration.
 * @param clock The fawkes clock, used to stamp the transforms
 * @param tf_publisher The fawes transform publisher, used to publish the
 * transforms of the tags
 * @param cam_frame The frame of reference for the transforms published
 */
TagPositionInterfaceHelper::TagPositionInterfaceHelper(
  fawkes::Position3DInterface *   position_interface,
  u_int32_t                       index,
  fawkes::Clock *                 clock,
  fawkes::tf::TransformPublisher *tf_publisher,
  fawkes::tf::Transformer *       tf_listener,
  std::string                     cam_frame)
{
	pos_iface_          = position_interface;
	index_              = index;
	visibility_history_ = 0;
	marker_id_          = 0;
	was_seen_           = false;
	clock_              = clock;

	cam_frame_    = cam_frame;
	tag_frame_    = TagVisionThread::tag_frame_basename + std::to_string(index);
	tf_publisher_ = tf_publisher;
	tf_listener_  = tf_listener;
}

/**
 *
 */
TagPositionInterfaceHelper::~TagPositionInterfaceHelper()
{
	// no need to clear/free the interface, the TagPositionList takes care of it
}

/**
 * This method will update the position of the tag in the interface
 * according to the position got from the tag. Any transforming
 * calculation hapens here.
 * It also sets a marker for the visibility history, so using write()
 * updates the Interfae properly. It also publishes the transforms.
 *
 * @param new_pose The new Position of the marker, as got from alvar::MarkerData
 */
void
TagPositionInterfaceHelper::set_pose(alvar::Pose new_pose)
{
	// angles in quaternion
	double rot[4];
	// create the mat
	// temp mat to get cv data
	cv::Mat mat = cv::Mat(4, 1, CV_64F, rot);
	// get the angles in euler
	new_pose.GetQuaternion(mat);
	// get the temporary quaternion in wxyz
	rot[0] = mat.at<double>(0, 0);
	rot[1] = mat.at<double>(1, 0);
	rot[2] = mat.at<double>(2, 0);
	rot[3] = mat.at<double>(3, 0);
	// create a quaternion on the angles.
	fawkes::tf::Quaternion tag_rot(rot[ALVAR_ROT::A_X],
	                               rot[ALVAR_ROT::A_Y],
	                               rot[ALVAR_ROT::A_Z],
	                               rot[ALVAR_ROT::A_W]);
	fawkes::tf::Quaternion fix_tag_orientation(0, -M_PI_2, -M_PI_2); // yaw: 0° pitch: 90° roll: -90°
	fawkes::tf::Quaternion result = tag_rot * fix_tag_orientation;

	// publish the quaternion
	pos_iface_->set_rotation(ROT::X, result.getX());
	pos_iface_->set_rotation(ROT::Y, result.getY());
	pos_iface_->set_rotation(ROT::Z, result.getZ());
	pos_iface_->set_rotation(ROT::W, result.getW());
	// publish the translation
	pos_iface_->set_translation(TRANS::T_X /*1*/, new_pose.translation[TRANS::T_X /*0*/] / 1000);
	pos_iface_->set_translation(TRANS::T_Y /*2*/, new_pose.translation[TRANS::T_Y /*1*/] / 1000);
	pos_iface_->set_translation(TRANS::T_Z /*0*/, new_pose.translation[TRANS::T_Z /*2*/] / 1000);

	was_seen_ = true;

	// publish the transform
	fawkes::tf::Transform        transform(result,
                                  fawkes::tf::Vector3(new_pose.translation[0] / 1000,
                                                      new_pose.translation[1] / 1000,
                                                      new_pose.translation[2] / 1000));
	fawkes::Time                 time(clock_);
	fawkes::tf::StampedTransform stamped_transform(transform, time, cam_frame_, tag_frame_);

	try {
    fawkes::tf::Stamped<fawkes::tf::Pose> tag_in_cam_pose(
          fawkes::tf::Pose(fawkes::tf::Quaternion(result.getX(),result.getY(),result.getZ(),result.getW()),
                   fawkes::tf::Vector3(new_pose.translation[0] / 1000, new_pose.translation[1] / 1000, new_pose.translation[2] / 1000)),
          fawkes::Time(0, 0),
          cam_frame_);
      fawkes::tf::Stamped<fawkes::tf::Pose> tag_in_map_pose;
      tf_listener_->transform_pose("map", tag_in_cam_pose, tag_in_map_pose);

      fawkes::tf::Vector3     tf_pose_pos(tag_in_map_pose.getOrigin());
      fawkes::tf::Quaternion  tf_pose_ori(tag_in_map_pose.getRotation());
	    fawkes::tf::StampedTransform tag_to_map(fawkes::tf::Transform(tf_pose_ori, tf_pose_pos),
	                                            time,
	                                            "map",
	                                            tag_frame_ + "_to_map");
	    tf_publisher_->send_transform(tag_to_map);


  } catch (fawkes::tf::TransformException &e) {
    std::cout << "Can't transform to " << tag_frame_ << " " << e.what() << std::endl;
  }

}

/**
 * Set new marker ID
 * @param new_id The marker ID
 */
void
TagPositionInterfaceHelper::set_marker_id(unsigned long new_id)
{
	marker_id_ = new_id;
}

/**
 * @return Current marker ID
 */
unsigned long
TagPositionInterfaceHelper::marker_id() const
{
	return marker_id_;
}

/**
 * @return Current visibility history
 */
int32_t
TagPositionInterfaceHelper::visibility_history() const
{
	return visibility_history_;
}

/**
 * Set visibility history
 * @param vis_hist The visibility history
 */
void
TagPositionInterfaceHelper::set_visibility_history(int32_t vis_hist)
{
	visibility_history_ = vis_hist;
}

/**
 * Writes out the set pose and visibility history.
 * If the Pose was set since the last write the visibility history is
 * incremented and both information is writen to the Blackboard. If the pose was
 * no set, the visibility history is decremented and written to the Blackboard.
 * If the visibility changes (seen -> not seen or other way round) the
 * visibility_history will be reset to 0 and start counting directly. If the
 * visibility history is less than -1000, the interface is considered empty.
 */
void
TagPositionInterfaceHelper::write()
{
	// when the tag becomes visible or invisible reset the visibility history
	if ((was_seen_ && visibility_history_ < 0) || (!was_seen_ && visibility_history_ > 0)) {
		visibility_history_ = 0;
	}
	// update the visibility history according to the marker, weather this
	// interface got a new pose
	if (was_seen_) {
		visibility_history_++;
	} else {
		visibility_history_--;
	}
	// empty marker id if the tag is to long not visible
	if (marker_id_ != EMPTY_INTERFACE_MARKER_ID && visibility_history_ < INTERFACE_UNSEEN_BOUND) {
		marker_id_ = EMPTY_INTERFACE_MARKER_ID;
	}
	// set the new visibility history
	pos_iface_->set_visibility_history(visibility_history_);
	// write out the interface
	pos_iface_->write();
	// reset the update marker
	was_seen_ = false;
}
