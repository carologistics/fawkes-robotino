/***************************************************************************
 *  tag_position_interface.cpp - Interface handler for tag position
 *
 *  Generated: Mon Mar 23 12:01:15 2015
 *  Copyright  2012  Randolph Maaßen
 *
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version. A runtime exception applies to
 *  this software (see LICENSE.GPL_WRE file mentioned below for details).
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
 */

#include "tag_position_interface_helper.h"

#include "tag_vision_thread.h"

#include <cmath>
#include <sstream>

/** @class TagPositionInterfaceHelper "tag_position_interface_helper.h"
 * This class is used to help handling of the Position3DInterface calss. It
 * Calculates the needed position values from the given alvar position and sets
 * the Position3DInterface accordingly. It also publishes Transforms for the
 * tag.
 *
 * @author Randolph Maaßen
 */

/**
 * @param position_interface The interface, generated by the Blackboard, that
 * this instance handles.
 * @param position_interface_map Alternative interface to publish directly in
 * map frame
 * @param index The position in the TagPositionList, or any other
 * enumeration.
 * @param clock The fawkes clock, used to stamp the transforms
 * @param tf_publisher The fawkes transform publisher, used to publish the
 * transforms of the tags
 * @param map_tf_publisher The publisher for tags in map frame
 * @param tf_listener Transformer to compute tags in map frame
 * @param cam_frame The frame of reference for the transforms published
 */
TagPositionInterfaceHelper::TagPositionInterfaceHelper(
  u_int32_t                       index,
  fawkes::Clock                  *clock,
  fawkes::tf::TransformPublisher *tf_publisher,
  fawkes::tf::TransformPublisher *map_tf_publisher,
  fawkes::tf::Transformer        *tf_listener,
  std::string                     cam_frame)
{
	index_              = index;
	marker_id_          = index;
	visibility_history_ = 0;
	was_seen_           = false;
	clock_              = clock;

	cam_frame_        = cam_frame;
	tag_frame_        = TagVisionThread::tag_frame_basename + std::to_string(index);
	tf_publisher_     = tf_publisher;
	map_tf_publisher_ = map_tf_publisher;
	tf_listener_      = tf_listener;

	map_pose_.tvec = {-1, -1, -1};
}

/**
 *
 */
TagPositionInterfaceHelper::~TagPositionInterfaceHelper()
{
	// no need to clear/free the interface, the TagPositionList takes care of it
}

/**
 * This method will update the position of the tag in the interface
 * according to the position got from the tag. Any transforming
 * calculation hapens here.
 * It also sets a marker for the visibility history, so using write()
 * updates the Interfae properly. It also publishes the transforms.
 *
 * @param new_pose The new Position of the marker
 * @param marker_type The type of the marker
 */
void
TagPositionInterfaceHelper::set_pose(TagPose new_pose, MarkerType marker_type)
{
	marker_type_ = marker_type;
	// create a quaternion on the angles.
	fawkes::tf::Quaternion tag_rot(new_pose.quaternion[CV_ROT::CV_X],
	                               new_pose.quaternion[CV_ROT::CV_Y],
	                               new_pose.quaternion[CV_ROT::CV_Z],
	                               new_pose.quaternion[CV_ROT::CV_W]);
	if (marker_type == MarkerType::ARUCO) {
		tag_rot = fawkes::tf::Quaternion(new_pose.quaternion[ALVAR_ROT::A_X],
		                                 new_pose.quaternion[ALVAR_ROT::A_Y],
		                                 new_pose.quaternion[ALVAR_ROT::A_Z],
		                                 new_pose.quaternion[ALVAR_ROT::A_W]);
	}
	fawkes::tf::Quaternion fix_tag_orientation(0, 0, 0);
	switch (marker_type) {
	case MarkerType::ARUCO:
		fix_tag_orientation =
		  fawkes::tf::Quaternion(0, -M_PI_2, 0) * fawkes::tf::Quaternion(0, 0, -M_PI_2);
		break;
	case MarkerType::ALVAR:
		fix_tag_orientation =
		  fawkes::tf::Quaternion(0, -M_PI_2, -M_PI_2); // yaw: 0° pitch: 90° roll: -90°
		break;
	}
	fawkes::tf::Quaternion result = tag_rot * fix_tag_orientation;
	switch (marker_type) {
	case MarkerType::ARUCO:
		cam_pose_.quaternion[CV_ROT::CV_X] = result.getX();
		cam_pose_.quaternion[CV_ROT::CV_Y] = result.getY();
		cam_pose_.quaternion[CV_ROT::CV_Z] = result.getZ();
		cam_pose_.quaternion[CV_ROT::CV_W] = result.getW();
		break;
	case MarkerType::ALVAR:
		cam_pose_.quaternion[ALVAR_ROT::A_X] = result.getX();
		cam_pose_.quaternion[ALVAR_ROT::A_Y] = result.getY();
		cam_pose_.quaternion[ALVAR_ROT::A_Z] = result.getZ();
		cam_pose_.quaternion[ALVAR_ROT::A_W] = result.getW();
		break;
	}
	cam_pose_.tvec = new_pose.tvec / 1000;
	// publish the translation
	was_seen_ = true;

	// publish the transform
	fawkes::tf::Transform        transform(result,
                                  fawkes::tf::Vector3(new_pose.tvec[0] / 1000,
                                                      new_pose.tvec[1] / 1000,
                                                      new_pose.tvec[2] / 1000));
	fawkes::Time                 time(clock_);
	fawkes::tf::StampedTransform stamped_transform(transform, time, cam_frame_, tag_frame_);
	tf_publisher_->send_transform(stamped_transform);

	try {
		fawkes::tf::Stamped<fawkes::tf::Pose> tag_in_cam_pose(
		  fawkes::tf::Pose(
		    fawkes::tf::Quaternion(result.getX(), result.getY(), result.getZ(), result.getW()),
		    fawkes::tf::Vector3(new_pose.tvec[0] / 1000,
		                        new_pose.tvec[1] / 1000,
		                        new_pose.tvec[2] / 1000)),
		  fawkes::Time(0, 0),
		  cam_frame_);
		fawkes::tf::Stamped<fawkes::tf::Pose> tag_in_map_pose;
		tf_listener_->transform_pose("map", tag_in_cam_pose, tag_in_map_pose);

		fawkes::tf::Vector3          tf_pose_pos(tag_in_map_pose.getOrigin());
		fawkes::tf::Quaternion       tf_pose_ori(tag_in_map_pose.getRotation());
		fawkes::tf::StampedTransform tag_to_map(fawkes::tf::Transform(tf_pose_ori, tf_pose_pos),
		                                        time,
		                                        "map",
		                                        tag_frame_ + "_to_map");
		// publish the quaternion in map frame
		switch (marker_type) {
		case MarkerType::ARUCO:
			map_pose_.quaternion[CV_ROT::CV_X] = tag_in_map_pose.getRotation().getX();
			map_pose_.quaternion[CV_ROT::CV_Y] = tag_in_map_pose.getRotation().getY();
			map_pose_.quaternion[CV_ROT::CV_Z] = tag_in_map_pose.getRotation().getZ();
			map_pose_.quaternion[CV_ROT::CV_W] = tag_in_map_pose.getRotation().getW();
			break;
		case MarkerType::ALVAR:
			map_pose_.quaternion[ALVAR_ROT::A_X] = tag_in_map_pose.getRotation().getX();
			map_pose_.quaternion[ALVAR_ROT::A_Y] = tag_in_map_pose.getRotation().getY();
			map_pose_.quaternion[ALVAR_ROT::A_Z] = tag_in_map_pose.getRotation().getZ();
			map_pose_.quaternion[ALVAR_ROT::A_W] = tag_in_map_pose.getRotation().getW();
			break;
		}
		map_pose_.tvec                   = new_pose.tvec / 1000;
		map_pose_.tvec[TRANS::T_X /*1*/] = tag_in_map_pose.getOrigin().getX();
		map_pose_.tvec[TRANS::T_Y /*2*/] = tag_in_map_pose.getOrigin().getY();
		map_pose_.tvec[TRANS::T_Z /*0*/] = tag_in_map_pose.getOrigin().getZ();
	} catch (fawkes::tf::TransformException &e) {
		std::cout << "Can't transform to " << tag_frame_ << " " << e.what() << std::endl;
	}
}

/**
 * Set new marker ID
 * @param new_id The marker ID
 */
void
TagPositionInterfaceHelper::set_marker_id(unsigned long new_id)
{
	marker_id_ = new_id;
}

/**
 * Calculate zone of current marker, (e.g., M-Z61)
 */
std::string
TagPositionInterfaceHelper::get_zone()
{
	std::string prefix = "C";
	auto        x      = map_pose_.tvec[TRANS::T_X];
	auto        y      = map_pose_.tvec[TRANS::T_Y];

	if (y < 0)
		return "M_Z00";

	if (x < 0) {
		x *= -1;
		prefix = "M";
	}

	x = round(x + 0.5);
	y = round(y + 0.5);

	std::stringstream ss;
	ss << prefix << "_Z" << x << y;
	return ss.str();
}

/**
 * Calculate ori of a given marker, discretized in 45 degree steps
 */
int
TagPositionInterfaceHelper::get_discrete_ori()
{
	fawkes::tf::Quaternion fawkes_rot(map_pose_.quaternion[CV_ROT::CV_X],
	                                  map_pose_.quaternion[CV_ROT::CV_Y],
	                                  map_pose_.quaternion[CV_ROT::CV_Z],
	                                  map_pose_.quaternion[CV_ROT::CV_W]);
	if (marker_type_ == MarkerType::ARUCO) {
		fawkes_rot = fawkes::tf::Quaternion(map_pose_.quaternion[ALVAR_ROT::A_X],
		                                    map_pose_.quaternion[ALVAR_ROT::A_Y],
		                                    map_pose_.quaternion[ALVAR_ROT::A_Z],
		                                    map_pose_.quaternion[ALVAR_ROT::A_W]);
	}
	constexpr double PI = 3.14159265358979323846;

	double ori = fawkes::tf::get_yaw(fawkes_rot);
	if (index_ % 2 == 1) {
		ori += PI;
	}
	if (ori < 0) {
		ori += (2 * PI);
	}
	ori            = ori / PI * 4.0;
	double ori_deg = round(ori) * 45.0;

	int result = static_cast<int>(ori_deg);
	if (result == 360) {
		result = 0;
	}
	return result;
}

/**
 * @return Current marker ID
 */
unsigned long
TagPositionInterfaceHelper::marker_id() const
{
	return marker_id_;
}

/**
 * @return Current visibility history
 */
int32_t
TagPositionInterfaceHelper::visibility_history() const
{
	return visibility_history_;
}

/**
 * Set visibility history
 * @param vis_hist The visibility history
 */
void
TagPositionInterfaceHelper::set_visibility_history(int32_t vis_hist)
{
	visibility_history_ = vis_hist;
}

/**
 * Writes out the set pose and visibility history.
 * If the Pose was set since the last write the visibility history is
 * incremented and both information is writen to the Blackboard. If the pose was
 * no set, the visibility history is decremented and written to the Blackboard.
 * If the visibility changes (seen -> not seen or other way round) the
 * visibility_history will be reset to 0 and start counting directly. If the
 * visibility history is less than -1000, the interface is considered empty.
 */
void
TagPositionInterfaceHelper::write()
{
	// when the tag becomes visible or invisible reset the visibility history
	if ((was_seen_ && visibility_history_ < 0) || (!was_seen_ && visibility_history_ > 0)) {
		visibility_history_ = 0;
	}
	// update the visibility history according to the marker, weather this
	// interface got a new pose
	if (was_seen_) {
		visibility_history_++;
	} else {
		visibility_history_--;
	}
	// empty marker id if the tag is to long not visible
	//if (marker_id_ != EMPTY_INTERFACE_MARKER_ID && visibility_history_ < INTERFACE_UNSEEN_BOUND) {
	//	marker_id_ = EMPTY_INTERFACE_MARKER_ID;
	//}
	// set the new visibility history
	// pos_iface_->set_visibility_history(visibility_history_);
	// pos_iface_map_->set_visibility_history(visibility_history_);
	// // write out the interface
	// pos_iface_->write();
	// pos_iface_map_->write();
	// reset the update marker
	was_seen_ = false;
}
