
/***************************************************************************
 *  AX12GripperInterface.h - Fawkes BlackBoard Interface - AX12GripperInterface
 *
 *  Templated created:   Thu Oct 12 10:49:19 2006
 *  Copyright  2015  Tim Niemueller, Nicolas Limpert
 *
 ****************************************************************************/

/*  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version. A runtime exception applies to
 *  this software (see LICENSE.GPL_WRE file mentioned below for details).
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  Read the full text in the LICENSE.GPL_WRE file in the doc directory.
 */

#ifndef __INTERFACES_AX12GRIPPERINTERFACE_H_
#define __INTERFACES_AX12GRIPPERINTERFACE_H_

#include <interface/interface.h>
#include <interface/message.h>
#include <interface/field_iterator.h>

namespace fawkes {

class AX12GripperInterface : public Interface
{
 /// @cond INTERNALS
 INTERFACE_MGMT_FRIENDS(AX12GripperInterface)
 /// @endcond
 public:
  /* constants */
  static const uint32_t FLAG_SUPPORTS_LEFT;
  static const uint32_t FLAG_SUPPORTS_RIGHT;
  static const uint32_t ERROR_NONE;
  static const uint32_t ERROR_UNSPECIFIC;
  static const uint32_t ERROR_COMMUNICATION;
  static const uint32_t ERROR_LEFT_OUTOFRANGE;
  static const uint32_t ERROR_RIGHT_OUTOFRANGE;

  /** Either close the gripper only on the left or on the right side. */
  typedef enum {
    LEFT = 0 /**< Slap left */,
    RIGHT = 1 /**< Slap right */
  } SlapMode;
  const char * tostring_SlapMode(SlapMode value) const;

 private:
  /** Internal data storage, do NOT modify! */
  typedef struct __attribute__((packed)) {
    int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
    int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    uint32_t flags; /**< Flags. */
    int32_t z_position; /**< Z-Position. */
    int32_t z_upper_bound; /**< Z-upper bound. */
    int32_t z_lower_bound; /**< Z-lower bound. */
    float left; /**< Current left. */
    float right; /**< Current right. */
    int32_t left_load; /**< Current left load. */
    int32_t right_load; /**< Current right load. */
    float angle; /**< Current angle. */
    float offset; /**< Current offset. */
    uint32_t msgid; /**< The ID of the message that is currently being
      processed, or 0 if no message is being processed. */
    bool final; /**< True, if the last goto command has been finished,
      false if it is still running */
    uint32_t error_code; /**< Failure code set if
    final is true. 0 if no error occured, an error code from ERROR_*
    constants otherwise (or a bit-wise combination). */
    bool enabled; /**< Is the left/right unit enabled? */
    bool calibrated; /**< Is the left/right unit calibrated? */
    float min_left; /**< Minimum left possible. */
    float max_left; /**< Maximum left possible. */
    float min_right; /**< Minimum right possible. */
    float max_right; /**< Maximum right possible. */
    float max_left_velocity; /**< Maximum supported left velocity. */
    float max_right_velocity; /**< Maximum supported right velocity. */
    float left_velocity; /**< Maximum left velocity currently reached. */
    float right_velocity; /**< Maximum right velocity currently reached. */
    float left_margin; /**< Margin in radians around a
    target left value to consider the motion as final. */
    float right_margin; /**< Margin in radians around a
    target right value to consider the motion as final. */
    bool holds_puck; /**< True if the gripper holds a puck */
  } AX12GripperInterface_data_t;

  AX12GripperInterface_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
 public:
  /* messages */
  class Open_AngleMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float angle; /**< Current angle. */
    } Open_AngleMessage_data_t;

    Open_AngleMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    Open_AngleMessage(const float ini_angle);
    Open_AngleMessage();
    ~Open_AngleMessage();

    Open_AngleMessage(const Open_AngleMessage *m);
    /* Methods */
    float angle() const;
    void set_angle(const float new_angle);
    size_t maxlenof_angle() const;
    virtual Message * clone() const;
  };

  class CloseLoadMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float offset; /**< Current offset. */
    } CloseLoadMessage_data_t;

    CloseLoadMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    CloseLoadMessage(const float ini_offset);
    CloseLoadMessage();
    ~CloseLoadMessage();

    CloseLoadMessage(const CloseLoadMessage *m);
    /* Methods */
    float offset() const;
    void set_offset(const float new_offset);
    size_t maxlenof_offset() const;
    virtual Message * clone() const;
  };

  class CenterMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } CenterMessage_data_t;

    CenterMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    CenterMessage();
    ~CenterMessage();

    CenterMessage(const CenterMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class CloseMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float offset; /**< Current offset. */
    } CloseMessage_data_t;

    CloseMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    CloseMessage(const float ini_offset);
    CloseMessage();
    ~CloseMessage();

    CloseMessage(const CloseMessage *m);
    /* Methods */
    float offset() const;
    void set_offset(const float new_offset);
    size_t maxlenof_offset() const;
    virtual Message * clone() const;
  };

  class OpenMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float offset; /**< Current offset. */
    } OpenMessage_data_t;

    OpenMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    OpenMessage(const float ini_offset);
    OpenMessage();
    ~OpenMessage();

    OpenMessage(const OpenMessage *m);
    /* Methods */
    float offset() const;
    void set_offset(const float new_offset);
    size_t maxlenof_offset() const;
    virtual Message * clone() const;
  };

  class RelGotoZMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      int32_t rel_z; /**< New z relative to the current z, in mm. */
    } RelGotoZMessage_data_t;

    RelGotoZMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    RelGotoZMessage(const int32_t ini_rel_z);
    RelGotoZMessage();
    ~RelGotoZMessage();

    RelGotoZMessage(const RelGotoZMessage *m);
    /* Methods */
    int32_t rel_z() const;
    void set_rel_z(const int32_t new_rel_z);
    size_t maxlenof_rel_z() const;
    virtual Message * clone() const;
  };

  class StopLeftMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } StopLeftMessage_data_t;

    StopLeftMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    StopLeftMessage();
    ~StopLeftMessage();

    StopLeftMessage(const StopLeftMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class StopRightMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } StopRightMessage_data_t;

    StopRightMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    StopRightMessage();
    ~StopRightMessage();

    StopRightMessage(const StopRightMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class StopMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } StopMessage_data_t;

    StopMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    StopMessage();
    ~StopMessage();

    StopMessage(const StopMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class FlushMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } FlushMessage_data_t;

    FlushMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    FlushMessage();
    ~FlushMessage();

    FlushMessage(const FlushMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class CalibrateMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } CalibrateMessage_data_t;

    CalibrateMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    CalibrateMessage();
    ~CalibrateMessage();

    CalibrateMessage(const CalibrateMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class ParkMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
    } ParkMessage_data_t;

    ParkMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    ParkMessage();
    ~ParkMessage();

    ParkMessage(const ParkMessage *m);
    /* Methods */
    virtual Message * clone() const;
  };

  class GotoMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float left; /**< Current left. */
      float right; /**< Current right. */
    } GotoMessage_data_t;

    GotoMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    GotoMessage(const float ini_left, const float ini_right);
    GotoMessage();
    ~GotoMessage();

    GotoMessage(const GotoMessage *m);
    /* Methods */
    float left() const;
    void set_left(const float new_left);
    size_t maxlenof_left() const;
    float right() const;
    void set_right(const float new_right);
    size_t maxlenof_right() const;
    virtual Message * clone() const;
  };

  class TimedGotoMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float time_sec; /**< Time in seconds when to reach
    the final position. */
      float left; /**< Current left. */
      float right; /**< Current right. */
    } TimedGotoMessage_data_t;

    TimedGotoMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    TimedGotoMessage(const float ini_time_sec, const float ini_left, const float ini_right);
    TimedGotoMessage();
    ~TimedGotoMessage();

    TimedGotoMessage(const TimedGotoMessage *m);
    /* Methods */
    float time_sec() const;
    void set_time_sec(const float new_time_sec);
    size_t maxlenof_time_sec() const;
    float left() const;
    void set_left(const float new_left);
    size_t maxlenof_left() const;
    float right() const;
    void set_right(const float new_right);
    size_t maxlenof_right() const;
    virtual Message * clone() const;
  };

  class SetServoMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      uint32_t servoID; /**< Servo ID. */
      float angle; /**< Target Servo angle. */
    } SetServoMessage_data_t;

    SetServoMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SetServoMessage(const uint32_t ini_servoID, const float ini_angle);
    SetServoMessage();
    ~SetServoMessage();

    SetServoMessage(const SetServoMessage *m);
    /* Methods */
    uint32_t servoID() const;
    void set_servoID(const uint32_t new_servoID);
    size_t maxlenof_servoID() const;
    float angle() const;
    void set_angle(const float new_angle);
    size_t maxlenof_angle() const;
    virtual Message * clone() const;
  };

  class SetEnabledMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      bool enabled; /**< Is the left/right unit enabled? */
    } SetEnabledMessage_data_t;

    SetEnabledMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SetEnabledMessage(const bool ini_enabled);
    SetEnabledMessage();
    ~SetEnabledMessage();

    SetEnabledMessage(const SetEnabledMessage *m);
    /* Methods */
    bool is_enabled() const;
    void set_enabled(const bool new_enabled);
    size_t maxlenof_enabled() const;
    virtual Message * clone() const;
  };

  class SetVelocityMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float left_velocity; /**< Maximum left velocity currently reached. */
      float right_velocity; /**< Maximum right velocity currently reached. */
    } SetVelocityMessage_data_t;

    SetVelocityMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SetVelocityMessage(const float ini_left_velocity, const float ini_right_velocity);
    SetVelocityMessage();
    ~SetVelocityMessage();

    SetVelocityMessage(const SetVelocityMessage *m);
    /* Methods */
    float left_velocity() const;
    void set_left_velocity(const float new_left_velocity);
    size_t maxlenof_left_velocity() const;
    float right_velocity() const;
    void set_right_velocity(const float new_right_velocity);
    size_t maxlenof_right_velocity() const;
    virtual Message * clone() const;
  };

  class SetMarginMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float left_margin; /**< Margin in radians around a
    target left value to consider the motion as final. */
      float right_margin; /**< Margin in radians around a
    target right value to consider the motion as final. */
    } SetMarginMessage_data_t;

    SetMarginMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SetMarginMessage(const float ini_left_margin, const float ini_right_margin);
    SetMarginMessage();
    ~SetMarginMessage();

    SetMarginMessage(const SetMarginMessage *m);
    /* Methods */
    float left_margin() const;
    void set_left_margin(const float new_left_margin);
    size_t maxlenof_left_margin() const;
    float right_margin() const;
    void set_right_margin(const float new_right_margin);
    size_t maxlenof_right_margin() const;
    virtual Message * clone() const;
  };

  class SetTorqueMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      float torque; /**< torque */
    } SetTorqueMessage_data_t;

    SetTorqueMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SetTorqueMessage(const float ini_torque);
    SetTorqueMessage();
    ~SetTorqueMessage();

    SetTorqueMessage(const SetTorqueMessage *m);
    /* Methods */
    float torque() const;
    void set_torque(const float new_torque);
    size_t maxlenof_torque() const;
    virtual Message * clone() const;
  };

  class SlapMessage : public Message
  {
   private:
    /** Internal data storage, do NOT modify! */
    typedef struct __attribute__((packed)) {
      int64_t timestamp_sec;  /**< Interface Unix timestamp, seconds */
      int64_t timestamp_usec; /**< Interface Unix timestamp, micro-seconds */
      uint8_t slapmode; /**< Either 0 for left, 1 for right. */
    } SlapMessage_data_t;

    SlapMessage_data_t *data;

  interface_enum_map_t enum_map_SlapMode;
   public:
    SlapMessage(const uint8_t ini_slapmode);
    SlapMessage();
    ~SlapMessage();

    SlapMessage(const SlapMessage *m);
    /* Methods */
    uint8_t slapmode() const;
    void set_slapmode(const uint8_t new_slapmode);
    size_t maxlenof_slapmode() const;
    virtual Message * clone() const;
  };

  virtual bool message_valid(const Message *message) const;
 private:
  AX12GripperInterface();
  ~AX12GripperInterface();

 public:
  /* Methods */
  uint32_t flags() const;
  void set_flags(const uint32_t new_flags);
  size_t maxlenof_flags() const;
  int32_t z_position() const;
  void set_z_position(const int32_t new_z_position);
  size_t maxlenof_z_position() const;
  int32_t z_upper_bound() const;
  void set_z_upper_bound(const int32_t new_z_upper_bound);
  size_t maxlenof_z_upper_bound() const;
  int32_t z_lower_bound() const;
  void set_z_lower_bound(const int32_t new_z_lower_bound);
  size_t maxlenof_z_lower_bound() const;
  float left() const;
  void set_left(const float new_left);
  size_t maxlenof_left() const;
  float right() const;
  void set_right(const float new_right);
  size_t maxlenof_right() const;
  int32_t left_load() const;
  void set_left_load(const int32_t new_left_load);
  size_t maxlenof_left_load() const;
  int32_t right_load() const;
  void set_right_load(const int32_t new_right_load);
  size_t maxlenof_right_load() const;
  float angle() const;
  void set_angle(const float new_angle);
  size_t maxlenof_angle() const;
  float offset() const;
  void set_offset(const float new_offset);
  size_t maxlenof_offset() const;
  uint32_t msgid() const;
  void set_msgid(const uint32_t new_msgid);
  size_t maxlenof_msgid() const;
  bool is_final() const;
  void set_final(const bool new_final);
  size_t maxlenof_final() const;
  uint32_t error_code() const;
  void set_error_code(const uint32_t new_error_code);
  size_t maxlenof_error_code() const;
  bool is_enabled() const;
  void set_enabled(const bool new_enabled);
  size_t maxlenof_enabled() const;
  bool is_calibrated() const;
  void set_calibrated(const bool new_calibrated);
  size_t maxlenof_calibrated() const;
  float min_left() const;
  void set_min_left(const float new_min_left);
  size_t maxlenof_min_left() const;
  float max_left() const;
  void set_max_left(const float new_max_left);
  size_t maxlenof_max_left() const;
  float min_right() const;
  void set_min_right(const float new_min_right);
  size_t maxlenof_min_right() const;
  float max_right() const;
  void set_max_right(const float new_max_right);
  size_t maxlenof_max_right() const;
  float max_left_velocity() const;
  void set_max_left_velocity(const float new_max_left_velocity);
  size_t maxlenof_max_left_velocity() const;
  float max_right_velocity() const;
  void set_max_right_velocity(const float new_max_right_velocity);
  size_t maxlenof_max_right_velocity() const;
  float left_velocity() const;
  void set_left_velocity(const float new_left_velocity);
  size_t maxlenof_left_velocity() const;
  float right_velocity() const;
  void set_right_velocity(const float new_right_velocity);
  size_t maxlenof_right_velocity() const;
  float left_margin() const;
  void set_left_margin(const float new_left_margin);
  size_t maxlenof_left_margin() const;
  float right_margin() const;
  void set_right_margin(const float new_right_margin);
  size_t maxlenof_right_margin() const;
  bool is_holds_puck() const;
  void set_holds_puck(const bool new_holds_puck);
  size_t maxlenof_holds_puck() const;
  virtual Message * create_message(const char *type) const;

  virtual void copy_values(const Interface *other);
  virtual const char * enum_tostring(const char *enumtype, int val) const;

};

} // end namespace fawkes

#endif
